/* tslint:disable */
/* eslint-disable */
/**
 * OSIDB API
 * REST API autogenerated docs for the OSIDB and its components
 *
 * The version of the OpenAPI document: 3.5.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * Affect serializer
 * @export
 * @interface Affect
 */
export interface Affect {
    /**
     * 
     * @type {string}
     * @memberof Affect
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof Affect
     */
    'flaw': string | null;
    /**
     * 
     * @type {AffectType}
     * @memberof Affect
     */
    'type'?: AffectType;
    /**
     * 
     * @type {AffectAffectedness}
     * @memberof Affect
     */
    'affectedness'?: AffectAffectedness;
    /**
     * 
     * @type {AffectResolution}
     * @memberof Affect
     */
    'resolution'?: AffectResolution;
    /**
     * 
     * @type {string}
     * @memberof Affect
     */
    'ps_module': string;
    /**
     * 
     * @type {string}
     * @memberof Affect
     */
    'ps_component': string;
    /**
     * 
     * @type {AffectImpact}
     * @memberof Affect
     */
    'impact'?: AffectImpact;
    /**
     * 
     * @type {string}
     * @memberof Affect
     * @deprecated
     */
    'cvss2'?: string;
    /**
     * 
     * @type {number}
     * @memberof Affect
     * @deprecated
     */
    'cvss2_score'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Affect
     * @deprecated
     */
    'cvss3'?: string;
    /**
     * 
     * @type {number}
     * @memberof Affect
     * @deprecated
     */
    'cvss3_score'?: number | null;
    /**
     * 
     * @type {Array<Tracker>}
     * @memberof Affect
     */
    'trackers': Array<Tracker>;
    /**
     * 
     * @type {AffectMetaAttr}
     * @memberof Affect
     */
    'meta_attr': AffectMetaAttr;
    /**
     * 
     * @type {string}
     * @memberof Affect
     */
    'delegated_resolution': string;
    /**
     * 
     * @type {Array<AffectCVSS>}
     * @memberof Affect
     */
    'cvss_scores': Array<AffectCVSS>;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof Affect
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof Affect
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof Affect
     */
    'updated_dt': string;
}


/**
 * @type AffectAffectedness
 * @export
 */
export type AffectAffectedness = AffectednessEnum | BlankEnum;

/**
 * AffectCVSS serializer
 * @export
 * @interface AffectCVSS
 */
export interface AffectCVSS {
    /**
     * 
     * @type {string}
     * @memberof AffectCVSS
     */
    'affect'?: string;
    /**
     * 
     * @type {string}
     * @memberof AffectCVSS
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof AffectCVSS
     */
    'cvss_version': string;
    /**
     * 
     * @type {IssuerEnum}
     * @memberof AffectCVSS
     */
    'issuer': IssuerEnum;
    /**
     * 
     * @type {number}
     * @memberof AffectCVSS
     */
    'score'?: number;
    /**
     * 
     * @type {string}
     * @memberof AffectCVSS
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof AffectCVSS
     */
    'vector': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof AffectCVSS
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof AffectCVSS
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof AffectCVSS
     */
    'updated_dt': string;
}


/**
 * AffectCVSS serializer
 * @export
 * @interface AffectCVSSPost
 */
export interface AffectCVSSPost {
    /**
     * 
     * @type {string}
     * @memberof AffectCVSSPost
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof AffectCVSSPost
     */
    'cvss_version': string;
    /**
     * 
     * @type {IssuerEnum}
     * @memberof AffectCVSSPost
     */
    'issuer': IssuerEnum;
    /**
     * 
     * @type {number}
     * @memberof AffectCVSSPost
     */
    'score'?: number;
    /**
     * 
     * @type {string}
     * @memberof AffectCVSSPost
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof AffectCVSSPost
     */
    'vector': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof AffectCVSSPost
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof AffectCVSSPost
     */
    'created_dt': string;
}


/**
 * AffectCVSS serializer
 * @export
 * @interface AffectCVSSPut
 */
export interface AffectCVSSPut {
    /**
     * 
     * @type {string}
     * @memberof AffectCVSSPut
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof AffectCVSSPut
     */
    'cvss_version': string;
    /**
     * 
     * @type {IssuerEnum}
     * @memberof AffectCVSSPut
     */
    'issuer': IssuerEnum;
    /**
     * 
     * @type {number}
     * @memberof AffectCVSSPut
     */
    'score'?: number;
    /**
     * 
     * @type {string}
     * @memberof AffectCVSSPut
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof AffectCVSSPut
     */
    'vector': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof AffectCVSSPut
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof AffectCVSSPut
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof AffectCVSSPut
     */
    'updated_dt': string;
}


/**
 * @type AffectImpact
 * @export
 */
export type AffectImpact = BlankEnum | ImpactEnum;

/**
 * 
 * @export
 * @interface AffectMetaAttr
 */
export interface AffectMetaAttr {
    /**
     * 
     * @type {string}
     * @memberof AffectMetaAttr
     */
    'affectedness'?: string;
    /**
     * 
     * @type {string}
     * @memberof AffectMetaAttr
     */
    'component'?: string;
    /**
     * 
     * @type {string}
     * @memberof AffectMetaAttr
     */
    'cvss2'?: string;
    /**
     * 
     * @type {string}
     * @memberof AffectMetaAttr
     */
    'cvss3'?: string;
    /**
     * 
     * @type {string}
     * @memberof AffectMetaAttr
     */
    'impact'?: string;
    /**
     * 
     * @type {string}
     * @memberof AffectMetaAttr
     */
    'module_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AffectMetaAttr
     */
    'module_stream'?: string;
    /**
     * 
     * @type {string}
     * @memberof AffectMetaAttr
     */
    'ps_component'?: string;
    /**
     * 
     * @type {string}
     * @memberof AffectMetaAttr
     */
    'ps_module'?: string;
    /**
     * 
     * @type {string}
     * @memberof AffectMetaAttr
     */
    'resolution'?: string;
}
/**
 * Affect serializer
 * @export
 * @interface AffectPost
 */
export interface AffectPost {
    /**
     * 
     * @type {string}
     * @memberof AffectPost
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof AffectPost
     */
    'flaw': string | null;
    /**
     * 
     * @type {AffectType}
     * @memberof AffectPost
     */
    'type'?: AffectType;
    /**
     * 
     * @type {AffectAffectedness}
     * @memberof AffectPost
     */
    'affectedness'?: AffectAffectedness;
    /**
     * 
     * @type {AffectResolution}
     * @memberof AffectPost
     */
    'resolution'?: AffectResolution;
    /**
     * 
     * @type {string}
     * @memberof AffectPost
     */
    'ps_module': string;
    /**
     * 
     * @type {string}
     * @memberof AffectPost
     */
    'ps_component': string;
    /**
     * 
     * @type {AffectImpact}
     * @memberof AffectPost
     */
    'impact'?: AffectImpact;
    /**
     * 
     * @type {string}
     * @memberof AffectPost
     * @deprecated
     */
    'cvss2'?: string;
    /**
     * 
     * @type {number}
     * @memberof AffectPost
     * @deprecated
     */
    'cvss2_score'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AffectPost
     * @deprecated
     */
    'cvss3'?: string;
    /**
     * 
     * @type {number}
     * @memberof AffectPost
     * @deprecated
     */
    'cvss3_score'?: number | null;
    /**
     * 
     * @type {Array<Tracker>}
     * @memberof AffectPost
     */
    'trackers': Array<Tracker>;
    /**
     * 
     * @type {AffectMetaAttr}
     * @memberof AffectPost
     */
    'meta_attr': AffectMetaAttr;
    /**
     * 
     * @type {string}
     * @memberof AffectPost
     */
    'delegated_resolution': string;
    /**
     * 
     * @type {Array<AffectCVSS>}
     * @memberof AffectPost
     */
    'cvss_scores': Array<AffectCVSS>;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof AffectPost
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof AffectPost
     */
    'created_dt': string;
}


/**
 * 
 * @export
 * @interface AffectReportData
 */
export interface AffectReportData {
    /**
     * 
     * @type {string}
     * @memberof AffectReportData
     */
    'ps_module': string;
    /**
     * 
     * @type {string}
     * @memberof AffectReportData
     */
    'ps_component': string;
    /**
     * 
     * @type {AffectAffectedness}
     * @memberof AffectReportData
     */
    'affectedness'?: AffectAffectedness;
    /**
     * 
     * @type {AffectResolution}
     * @memberof AffectReportData
     */
    'resolution'?: AffectResolution;
    /**
     * 
     * @type {Array<TrackerReportData>}
     * @memberof AffectReportData
     */
    'trackers'?: Array<TrackerReportData>;
}
/**
 * @type AffectResolution
 * @export
 */
export type AffectResolution = BlankEnum | ResolutionEnum;

/**
 * 
 * @export
 * @enum {string}
 */

export const AffectType = {
    Default: 'DEFAULT'
} as const;

export type AffectType = typeof AffectType[keyof typeof AffectType];


/**
 * 
 * @export
 * @enum {string}
 */

export const AffectednessEnum = {
    New: 'NEW',
    Affected: 'AFFECTED',
    Notaffected: 'NOTAFFECTED'
} as const;

export type AffectednessEnum = typeof AffectednessEnum[keyof typeof AffectednessEnum];


/**
 * 
 * @export
 * @interface AuthTokenCreate200Response
 */
export interface AuthTokenCreate200Response {
    /**
     * 
     * @type {string}
     * @memberof AuthTokenCreate200Response
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenCreate200Response
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenCreate200Response
     */
    'access': string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenCreate200Response
     */
    'refresh': string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenCreate200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenCreate200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenCreate200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenCreate200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface AuthTokenCreate200ResponseAllOf
 */
export interface AuthTokenCreate200ResponseAllOf {
    /**
     * 
     * @type {string}
     * @memberof AuthTokenCreate200ResponseAllOf
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenCreate200ResponseAllOf
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenCreate200ResponseAllOf
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenCreate200ResponseAllOf
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface AuthTokenRefreshCreate200Response
 */
export interface AuthTokenRefreshCreate200Response {
    /**
     * 
     * @type {string}
     * @memberof AuthTokenRefreshCreate200Response
     */
    'access': string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenRefreshCreate200Response
     */
    'refresh': string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenRefreshCreate200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenRefreshCreate200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenRefreshCreate200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenRefreshCreate200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface AuthTokenRetrieve200Response
 */
export interface AuthTokenRetrieve200Response {
    /**
     * 
     * @type {string}
     * @memberof AuthTokenRetrieve200Response
     */
    'access'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenRetrieve200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenRetrieve200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenRetrieve200Response
     */
    'refresh'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenRetrieve200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenRetrieve200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface AuthTokenVerifyCreate200Response
 */
export interface AuthTokenVerifyCreate200Response {
    /**
     * 
     * @type {string}
     * @memberof AuthTokenVerifyCreate200Response
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenVerifyCreate200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenVerifyCreate200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenVerifyCreate200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenVerifyCreate200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const BlankEnum = {
    Empty: ''
} as const;

export type BlankEnum = typeof BlankEnum[keyof typeof BlankEnum];


/**
 * 
 * @export
 * @interface CollectorsApiV1StatusRetrieve200Response
 */
export interface CollectorsApiV1StatusRetrieve200Response {
    /**
     * 
     * @type {Array<CollectorsApiV1StatusRetrieve200ResponseCollectorsInner>}
     * @memberof CollectorsApiV1StatusRetrieve200Response
     */
    'collectors'?: Array<CollectorsApiV1StatusRetrieve200ResponseCollectorsInner>;
    /**
     * 
     * @type {string}
     * @memberof CollectorsApiV1StatusRetrieve200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof CollectorsApiV1StatusRetrieve200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof CollectorsApiV1StatusRetrieve200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof CollectorsApiV1StatusRetrieve200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface CollectorsApiV1StatusRetrieve200ResponseCollectorsInner
 */
export interface CollectorsApiV1StatusRetrieve200ResponseCollectorsInner {
    /**
     * 
     * @type {string}
     * @memberof CollectorsApiV1StatusRetrieve200ResponseCollectorsInner
     */
    'data'?: CollectorsApiV1StatusRetrieve200ResponseCollectorsInnerDataEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof CollectorsApiV1StatusRetrieve200ResponseCollectorsInner
     */
    'depends_on'?: Array<string>;
    /**
     * 
     * @type {object}
     * @memberof CollectorsApiV1StatusRetrieve200ResponseCollectorsInner
     */
    'error'?: object | null;
    /**
     * 
     * @type {boolean}
     * @memberof CollectorsApiV1StatusRetrieve200ResponseCollectorsInner
     */
    'is_complete'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CollectorsApiV1StatusRetrieve200ResponseCollectorsInner
     */
    'is_up2date'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof CollectorsApiV1StatusRetrieve200ResponseCollectorsInner
     */
    'data_models'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CollectorsApiV1StatusRetrieve200ResponseCollectorsInner
     */
    'state'?: CollectorsApiV1StatusRetrieve200ResponseCollectorsInnerStateEnum;
    /**
     * 
     * @type {string}
     * @memberof CollectorsApiV1StatusRetrieve200ResponseCollectorsInner
     */
    'updated_until'?: string;
}

export const CollectorsApiV1StatusRetrieve200ResponseCollectorsInnerDataEnum = {
    Empty: 'EMPTY',
    Partial: 'PARTIAL',
    Complete: 'COMPLETE'
} as const;

export type CollectorsApiV1StatusRetrieve200ResponseCollectorsInnerDataEnum = typeof CollectorsApiV1StatusRetrieve200ResponseCollectorsInnerDataEnum[keyof typeof CollectorsApiV1StatusRetrieve200ResponseCollectorsInnerDataEnum];
export const CollectorsApiV1StatusRetrieve200ResponseCollectorsInnerStateEnum = {
    Pending: 'PENDING',
    Blocked: 'BLOCKED',
    Ready: 'READY',
    Running: 'RUNNING'
} as const;

export type CollectorsApiV1StatusRetrieve200ResponseCollectorsInnerStateEnum = typeof CollectorsApiV1StatusRetrieve200ResponseCollectorsInnerStateEnum[keyof typeof CollectorsApiV1StatusRetrieve200ResponseCollectorsInnerStateEnum];

/**
 * 
 * @export
 * @interface CollectorsRetrieve200Response
 */
export interface CollectorsRetrieve200Response {
    /**
     * 
     * @type {string}
     * @memberof CollectorsRetrieve200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof CollectorsRetrieve200Response
     */
    'env'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CollectorsRetrieve200Response
     */
    'index'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CollectorsRetrieve200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof CollectorsRetrieve200Response
     */
    'version'?: string;
}
/**
 * FlawComment serializer for use by FlawSerializer
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'uuid': string;
    /**
     * 
     * @type {FlawCommentType}
     * @memberof Comment
     */
    'type'?: FlawCommentType;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'external_system_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof Comment
     */
    'order'?: number | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Comment
     */
    'meta_attr'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof Comment
     */
    'updated_dt': string;
}


/**
 * 
 * @export
 * @interface EPSS
 */
export interface EPSS {
    /**
     * 
     * @type {string}
     * @memberof EPSS
     */
    'cve': string;
    /**
     * 
     * @type {number}
     * @memberof EPSS
     */
    'epss': number;
}
/**
 * Erratum serializer
 * @export
 * @interface Erratum
 */
export interface Erratum {
    /**
     * 
     * @type {number}
     * @memberof Erratum
     */
    'et_id': number;
    /**
     * 
     * @type {string}
     * @memberof Erratum
     */
    'advisory_name': string;
    /**
     * 
     * @type {string}
     * @memberof Erratum
     */
    'shipped_dt': string | null;
    /**
     * 
     * @type {string}
     * @memberof Erratum
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof Erratum
     */
    'updated_dt': string;
}
/**
 * 
 * @export
 * @interface ExploitOnlyReportData
 */
export interface ExploitOnlyReportData {
    /**
     * 
     * @type {string}
     * @memberof ExploitOnlyReportData
     */
    'cve': string;
    /**
     * 
     * @type {string}
     * @memberof ExploitOnlyReportData
     */
    'date'?: string | null;
    /**
     * 
     * @type {ExploitOnlyReportDataSourceEnum}
     * @memberof ExploitOnlyReportData
     */
    'source': ExploitOnlyReportDataSourceEnum;
    /**
     * 
     * @type {string}
     * @memberof ExploitOnlyReportData
     */
    'reference'?: string;
    /**
     * 
     * @type {MaturityPreliminaryEnum}
     * @memberof ExploitOnlyReportData
     */
    'maturity_preliminary': MaturityPreliminaryEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ExploitOnlyReportData
     */
    'flaw': boolean;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ExploitOnlyReportDataSourceEnum = {
    Cisa: 'CISA',
    Metasploit: 'Metasploit',
    ExploitDb: 'Exploit-DB'
} as const;

export type ExploitOnlyReportDataSourceEnum = typeof ExploitOnlyReportDataSourceEnum[keyof typeof ExploitOnlyReportDataSourceEnum];


/**
 * 
 * @export
 * @interface ExploitsApiV1CollectUpdate200Response
 */
export interface ExploitsApiV1CollectUpdate200Response {
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1CollectUpdate200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1CollectUpdate200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1CollectUpdate200Response
     */
    'result_cisa'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1CollectUpdate200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1CollectUpdate200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface ExploitsApiV1CveMapRetrieve200Response
 */
export interface ExploitsApiV1CveMapRetrieve200Response {
    /**
     * 
     * @type {object}
     * @memberof ExploitsApiV1CveMapRetrieve200Response
     */
    'cves'?: object;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1CveMapRetrieve200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1CveMapRetrieve200Response
     */
    'env'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExploitsApiV1CveMapRetrieve200Response
     */
    'page_size'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1CveMapRetrieve200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1CveMapRetrieve200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface ExploitsApiV1EpssList200Response
 */
export interface ExploitsApiV1EpssList200Response {
    /**
     * 
     * @type {number}
     * @memberof ExploitsApiV1EpssList200Response
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1EpssList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1EpssList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<EPSS>}
     * @memberof ExploitsApiV1EpssList200Response
     */
    'results'?: Array<EPSS>;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1EpssList200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1EpssList200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1EpssList200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1EpssList200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface ExploitsApiV1FlawDataList200Response
 */
export interface ExploitsApiV1FlawDataList200Response {
    /**
     * 
     * @type {number}
     * @memberof ExploitsApiV1FlawDataList200Response
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1FlawDataList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1FlawDataList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<FlawReportData>}
     * @memberof ExploitsApiV1FlawDataList200Response
     */
    'results'?: Array<FlawReportData>;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1FlawDataList200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1FlawDataList200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1FlawDataList200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1FlawDataList200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface ExploitsApiV1ReportDataList200Response
 */
export interface ExploitsApiV1ReportDataList200Response {
    /**
     * 
     * @type {number}
     * @memberof ExploitsApiV1ReportDataList200Response
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportDataList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportDataList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<ExploitOnlyReportData>}
     * @memberof ExploitsApiV1ReportDataList200Response
     */
    'results'?: Array<ExploitOnlyReportData>;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportDataList200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportDataList200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportDataList200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportDataList200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface ExploitsApiV1ReportDateRetrieve200Response
 */
export interface ExploitsApiV1ReportDateRetrieve200Response {
    /**
     * 
     * @type {Array<object>}
     * @memberof ExploitsApiV1ReportDateRetrieve200Response
     */
    'action_required'?: Array<object>;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportDateRetrieve200Response
     */
    'cutoff_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportDateRetrieve200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportDateRetrieve200Response
     */
    'env'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExploitsApiV1ReportDateRetrieve200Response
     */
    'evaluated_cves'?: number;
    /**
     * 
     * @type {Array<object>}
     * @memberof ExploitsApiV1ReportDateRetrieve200Response
     */
    'no_action'?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof ExploitsApiV1ReportDateRetrieve200Response
     */
    'not_relevant'?: Array<object>;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportDateRetrieve200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportDateRetrieve200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface ExploitsApiV1ReportExplanationsRetrieve200Response
 */
export interface ExploitsApiV1ReportExplanationsRetrieve200Response {
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportExplanationsRetrieve200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportExplanationsRetrieve200Response
     */
    'env'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof ExploitsApiV1ReportExplanationsRetrieve200Response
     */
    'explanations'?: Array<object>;
    /**
     * 
     * @type {number}
     * @memberof ExploitsApiV1ReportExplanationsRetrieve200Response
     */
    'page_size'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportExplanationsRetrieve200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportExplanationsRetrieve200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface ExploitsApiV1ReportPendingRetrieve200Response
 */
export interface ExploitsApiV1ReportPendingRetrieve200Response {
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportPendingRetrieve200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportPendingRetrieve200Response
     */
    'env'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof ExploitsApiV1ReportPendingRetrieve200Response
     */
    'pending_actions'?: Array<object>;
    /**
     * 
     * @type {number}
     * @memberof ExploitsApiV1ReportPendingRetrieve200Response
     */
    'pending_actions_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportPendingRetrieve200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportPendingRetrieve200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface ExploitsApiV1StatusRetrieve200Response
 */
export interface ExploitsApiV1StatusRetrieve200Response {
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1StatusRetrieve200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1StatusRetrieve200Response
     */
    'env'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExploitsApiV1StatusRetrieve200Response
     */
    'exploits_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExploitsApiV1StatusRetrieve200Response
     */
    'exploits_count_relevant'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExploitsApiV1StatusRetrieve200Response
     */
    'last_exploit'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1StatusRetrieve200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1StatusRetrieve200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface ExploitsApiV1SupportedProductsList200Response
 */
export interface ExploitsApiV1SupportedProductsList200Response {
    /**
     * 
     * @type {number}
     * @memberof ExploitsApiV1SupportedProductsList200Response
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1SupportedProductsList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1SupportedProductsList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<SupportedProducts>}
     * @memberof ExploitsApiV1SupportedProductsList200Response
     */
    'results'?: Array<SupportedProducts>;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1SupportedProductsList200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1SupportedProductsList200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1SupportedProductsList200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1SupportedProductsList200Response
     */
    'version'?: string;
}
/**
 * serialize flaw model
 * @export
 * @interface Flaw
 */
export interface Flaw {
    /**
     * 
     * @type {string}
     * @memberof Flaw
     */
    'uuid': string;
    /**
     * 
     * @type {FlawType}
     * @memberof Flaw
     */
    'type'?: FlawType;
    /**
     * 
     * @type {string}
     * @memberof Flaw
     */
    'cve_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Flaw
     * @deprecated
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof Flaw
     * @deprecated
     */
    'resolution': string;
    /**
     * 
     * @type {AffectImpact}
     * @memberof Flaw
     */
    'impact'?: AffectImpact;
    /**
     * 
     * @type {string}
     * @memberof Flaw
     */
    'component'?: string;
    /**
     * 
     * @type {string}
     * @memberof Flaw
     */
    'title': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Flaw
     */
    'trackers': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Flaw
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Flaw
     */
    'summary'?: string;
    /**
     * 
     * @type {FlawRequiresSummary}
     * @memberof Flaw
     */
    'requires_summary'?: FlawRequiresSummary;
    /**
     * 
     * @type {string}
     * @memberof Flaw
     */
    'statement'?: string;
    /**
     * 
     * @type {string}
     * @memberof Flaw
     */
    'cwe_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Flaw
     */
    'unembargo_dt'?: string | null;
    /**
     * 
     * @type {FlawSource}
     * @memberof Flaw
     */
    'source'?: FlawSource;
    /**
     * 
     * @type {string}
     * @memberof Flaw
     */
    'reported_dt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Flaw
     */
    'mitigation'?: string;
    /**
     * 
     * @type {string}
     * @memberof Flaw
     * @deprecated
     */
    'cvss2'?: string;
    /**
     * 
     * @type {number}
     * @memberof Flaw
     * @deprecated
     */
    'cvss2_score'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Flaw
     * @deprecated
     */
    'nvd_cvss2'?: string;
    /**
     * 
     * @type {string}
     * @memberof Flaw
     * @deprecated
     */
    'cvss3'?: string;
    /**
     * 
     * @type {number}
     * @memberof Flaw
     * @deprecated
     */
    'cvss3_score'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Flaw
     * @deprecated
     */
    'nvd_cvss3'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Flaw
     * @deprecated
     */
    'is_major_incident'?: boolean;
    /**
     * 
     * @type {FlawMajorIncidentState}
     * @memberof Flaw
     */
    'major_incident_state'?: FlawMajorIncidentState;
    /**
     * 
     * @type {FlawNistCvssValidation}
     * @memberof Flaw
     */
    'nist_cvss_validation'?: FlawNistCvssValidation;
    /**
     * 
     * @type {Array<Affect>}
     * @memberof Flaw
     */
    'affects': Array<Affect>;
    /**
     * 
     * @type {Array<Meta>}
     * @memberof Flaw
     */
    'meta': Array<Meta>;
    /**
     * 
     * @type {Array<Comment>}
     * @memberof Flaw
     */
    'comments': Array<Comment>;
    /**
     * 
     * @type {FlawMetaAttr}
     * @memberof Flaw
     */
    'meta_attr': FlawMetaAttr;
    /**
     * 
     * @type {Array<Package>}
     * @memberof Flaw
     */
    'package_versions': Array<Package>;
    /**
     * 
     * @type {Array<FlawAcknowledgment>}
     * @memberof Flaw
     */
    'acknowledgments': Array<FlawAcknowledgment>;
    /**
     * 
     * @type {Array<FlawReference>}
     * @memberof Flaw
     */
    'references': Array<FlawReference>;
    /**
     * 
     * @type {Array<FlawCVSS>}
     * @memberof Flaw
     */
    'cvss_scores': Array<FlawCVSS>;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof Flaw
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof Flaw
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof Flaw
     */
    'updated_dt': string;
    /**
     * 
     * @type {FlawClassification}
     * @memberof Flaw
     */
    'classification': FlawClassification;
}


/**
 * FlawAcknowledgment serializer
 * @export
 * @interface FlawAcknowledgment
 */
export interface FlawAcknowledgment {
    /**
     * 
     * @type {string}
     * @memberof FlawAcknowledgment
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof FlawAcknowledgment
     */
    'affiliation': string;
    /**
     * 
     * @type {boolean}
     * @memberof FlawAcknowledgment
     */
    'from_upstream': boolean;
    /**
     * 
     * @type {string}
     * @memberof FlawAcknowledgment
     */
    'flaw': string;
    /**
     * 
     * @type {string}
     * @memberof FlawAcknowledgment
     */
    'uuid': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof FlawAcknowledgment
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof FlawAcknowledgment
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof FlawAcknowledgment
     */
    'updated_dt': string;
}
/**
 * FlawAcknowledgment serializer
 * @export
 * @interface FlawAcknowledgmentPost
 */
export interface FlawAcknowledgmentPost {
    /**
     * 
     * @type {string}
     * @memberof FlawAcknowledgmentPost
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof FlawAcknowledgmentPost
     */
    'affiliation': string;
    /**
     * 
     * @type {boolean}
     * @memberof FlawAcknowledgmentPost
     */
    'from_upstream': boolean;
    /**
     * 
     * @type {string}
     * @memberof FlawAcknowledgmentPost
     */
    'uuid': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof FlawAcknowledgmentPost
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof FlawAcknowledgmentPost
     */
    'created_dt': string;
}
/**
 * FlawAcknowledgment serializer
 * @export
 * @interface FlawAcknowledgmentPut
 */
export interface FlawAcknowledgmentPut {
    /**
     * 
     * @type {string}
     * @memberof FlawAcknowledgmentPut
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof FlawAcknowledgmentPut
     */
    'affiliation': string;
    /**
     * 
     * @type {boolean}
     * @memberof FlawAcknowledgmentPut
     */
    'from_upstream': boolean;
    /**
     * 
     * @type {string}
     * @memberof FlawAcknowledgmentPut
     */
    'uuid': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof FlawAcknowledgmentPut
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof FlawAcknowledgmentPut
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof FlawAcknowledgmentPut
     */
    'updated_dt': string;
}
/**
 * FlawCVSS serializer
 * @export
 * @interface FlawCVSS
 */
export interface FlawCVSS {
    /**
     * 
     * @type {string}
     * @memberof FlawCVSS
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawCVSS
     */
    'cvss_version': string;
    /**
     * 
     * @type {string}
     * @memberof FlawCVSS
     */
    'flaw'?: string;
    /**
     * 
     * @type {IssuerEnum}
     * @memberof FlawCVSS
     */
    'issuer': IssuerEnum;
    /**
     * 
     * @type {number}
     * @memberof FlawCVSS
     */
    'score'?: number;
    /**
     * 
     * @type {string}
     * @memberof FlawCVSS
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof FlawCVSS
     */
    'vector': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof FlawCVSS
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof FlawCVSS
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof FlawCVSS
     */
    'updated_dt': string;
}


/**
 * FlawCVSS serializer
 * @export
 * @interface FlawCVSSPost
 */
export interface FlawCVSSPost {
    /**
     * 
     * @type {string}
     * @memberof FlawCVSSPost
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawCVSSPost
     */
    'cvss_version': string;
    /**
     * 
     * @type {IssuerEnum}
     * @memberof FlawCVSSPost
     */
    'issuer': IssuerEnum;
    /**
     * 
     * @type {number}
     * @memberof FlawCVSSPost
     */
    'score'?: number;
    /**
     * 
     * @type {string}
     * @memberof FlawCVSSPost
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof FlawCVSSPost
     */
    'vector': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof FlawCVSSPost
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof FlawCVSSPost
     */
    'created_dt': string;
}


/**
 * FlawCVSS serializer
 * @export
 * @interface FlawCVSSPut
 */
export interface FlawCVSSPut {
    /**
     * 
     * @type {string}
     * @memberof FlawCVSSPut
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawCVSSPut
     */
    'cvss_version': string;
    /**
     * 
     * @type {IssuerEnum}
     * @memberof FlawCVSSPut
     */
    'issuer': IssuerEnum;
    /**
     * 
     * @type {number}
     * @memberof FlawCVSSPut
     */
    'score'?: number;
    /**
     * 
     * @type {string}
     * @memberof FlawCVSSPut
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof FlawCVSSPut
     */
    'vector': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof FlawCVSSPut
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof FlawCVSSPut
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof FlawCVSSPut
     */
    'updated_dt': string;
}


/**
 * 
 * @export
 * @interface FlawClassification
 */
export interface FlawClassification {
    /**
     * 
     * @type {string}
     * @memberof FlawClassification
     */
    'workflow'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawClassification
     */
    'state'?: FlawClassificationStateEnum;
}

export const FlawClassificationStateEnum = {
    Draft: 'DRAFT',
    New: 'NEW',
    Analysis: 'ANALYSIS',
    Review: 'REVIEW',
    Fix: 'FIX',
    Done: 'DONE'
} as const;

export type FlawClassificationStateEnum = typeof FlawClassificationStateEnum[keyof typeof FlawClassificationStateEnum];

/**
 * FlawComment serializer for use by flaw_comments endpoint
 * @export
 * @interface FlawComment
 */
export interface FlawComment {
    /**
     * 
     * @type {string}
     * @memberof FlawComment
     */
    'flaw': string;
    /**
     * 
     * @type {string}
     * @memberof FlawComment
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof FlawComment
     */
    'uuid': string;
    /**
     * 
     * @type {FlawCommentType}
     * @memberof FlawComment
     */
    'type'?: FlawCommentType;
    /**
     * 
     * @type {string}
     * @memberof FlawComment
     */
    'external_system_id': string;
    /**
     * 
     * @type {number}
     * @memberof FlawComment
     */
    'order'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FlawComment
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof FlawComment
     */
    'updated_dt': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof FlawComment
     */
    'embargoed': boolean;
}


/**
 * FlawComment serializer for use by flaw_comments endpoint
 * @export
 * @interface FlawCommentPost
 */
export interface FlawCommentPost {
    /**
     * 
     * @type {string}
     * @memberof FlawCommentPost
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof FlawCommentPost
     */
    'uuid': string;
    /**
     * 
     * @type {FlawCommentType}
     * @memberof FlawCommentPost
     */
    'type'?: FlawCommentType;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof FlawCommentPost
     */
    'meta_attr'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof FlawCommentPost
     */
    'created_dt': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof FlawCommentPost
     */
    'embargoed': boolean;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const FlawCommentType = {
    Bugzilla: 'BUGZILLA'
} as const;

export type FlawCommentType = typeof FlawCommentType[keyof typeof FlawCommentType];


/**
 * @type FlawMajorIncidentState
 * @export
 */
export type FlawMajorIncidentState = BlankEnum | MajorIncidentStateEnum;

/**
 * 
 * @export
 * @interface FlawMetaAttr
 */
export interface FlawMetaAttr {
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'acknowledgments'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'acks_not_needed'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'affects'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'alias'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'bz_datascore'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'bz_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'checklists'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'classification'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'cvss2'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'cvss2_score'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'cvss2_vector'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'cvss3'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'cvss3_comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'cvss3_score'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'cvss3_vector'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'cwe'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'depends_on'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'impact'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'jira_trackers'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'mitigate'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'mitigation'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'public'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'references'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'related_cves'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'reported'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'resolution'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'source'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'statement'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'task_owner'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const FlawMetaType = {
    Errata: 'ERRATA',
    Reference: 'REFERENCE',
    Acknowledgment: 'ACKNOWLEDGMENT',
    Exploit: 'EXPLOIT',
    MajorIncident: 'MAJOR_INCIDENT',
    MajorIncidentLite: 'MAJOR_INCIDENT_LITE',
    RequiresSummary: 'REQUIRES_SUMMARY',
    NistCvssValidation: 'NIST_CVSS_VALIDATION',
    NeedInfo: 'NEED_INFO',
    Checklist: 'CHECKLIST',
    NvdCvss: 'NVD_CVSS'
} as const;

export type FlawMetaType = typeof FlawMetaType[keyof typeof FlawMetaType];


/**
 * @type FlawNistCvssValidation
 * @export
 */
export type FlawNistCvssValidation = BlankEnum | NistCvssValidationEnum;

/**
 * Package model serializer
 * @export
 * @interface FlawPackageVersion
 */
export interface FlawPackageVersion {
    /**
     * 
     * @type {string}
     * @memberof FlawPackageVersion
     */
    'package': string;
    /**
     * 
     * @type {Array<FlawVersion>}
     * @memberof FlawPackageVersion
     */
    'versions': Array<FlawVersion>;
    /**
     * 
     * @type {string}
     * @memberof FlawPackageVersion
     */
    'flaw': string;
    /**
     * 
     * @type {string}
     * @memberof FlawPackageVersion
     */
    'uuid': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof FlawPackageVersion
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof FlawPackageVersion
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof FlawPackageVersion
     */
    'updated_dt': string;
}
/**
 * Package model serializer
 * @export
 * @interface FlawPackageVersionPost
 */
export interface FlawPackageVersionPost {
    /**
     * 
     * @type {string}
     * @memberof FlawPackageVersionPost
     */
    'package': string;
    /**
     * 
     * @type {Array<FlawVersion>}
     * @memberof FlawPackageVersionPost
     */
    'versions': Array<FlawVersion>;
    /**
     * 
     * @type {string}
     * @memberof FlawPackageVersionPost
     */
    'uuid': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof FlawPackageVersionPost
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof FlawPackageVersionPost
     */
    'created_dt': string;
}
/**
 * Package model serializer
 * @export
 * @interface FlawPackageVersionPut
 */
export interface FlawPackageVersionPut {
    /**
     * 
     * @type {string}
     * @memberof FlawPackageVersionPut
     */
    'package': string;
    /**
     * 
     * @type {Array<FlawVersion>}
     * @memberof FlawPackageVersionPut
     */
    'versions': Array<FlawVersion>;
    /**
     * 
     * @type {string}
     * @memberof FlawPackageVersionPut
     */
    'uuid': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof FlawPackageVersionPut
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof FlawPackageVersionPut
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof FlawPackageVersionPut
     */
    'updated_dt': string;
}
/**
 * serialize flaw model
 * @export
 * @interface FlawPost
 */
export interface FlawPost {
    /**
     * 
     * @type {string}
     * @memberof FlawPost
     */
    'uuid': string;
    /**
     * 
     * @type {FlawType}
     * @memberof FlawPost
     */
    'type'?: FlawType;
    /**
     * 
     * @type {string}
     * @memberof FlawPost
     */
    'cve_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlawPost
     * @deprecated
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof FlawPost
     * @deprecated
     */
    'resolution': string;
    /**
     * 
     * @type {AffectImpact}
     * @memberof FlawPost
     */
    'impact'?: AffectImpact;
    /**
     * 
     * @type {string}
     * @memberof FlawPost
     */
    'component'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawPost
     */
    'title': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof FlawPost
     */
    'trackers': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof FlawPost
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof FlawPost
     */
    'summary'?: string;
    /**
     * 
     * @type {FlawRequiresSummary}
     * @memberof FlawPost
     */
    'requires_summary'?: FlawRequiresSummary;
    /**
     * 
     * @type {string}
     * @memberof FlawPost
     */
    'statement'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawPost
     */
    'cwe_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawPost
     */
    'unembargo_dt'?: string | null;
    /**
     * 
     * @type {FlawSource}
     * @memberof FlawPost
     */
    'source'?: FlawSource;
    /**
     * 
     * @type {string}
     * @memberof FlawPost
     */
    'reported_dt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlawPost
     */
    'mitigation'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawPost
     * @deprecated
     */
    'cvss2'?: string;
    /**
     * 
     * @type {number}
     * @memberof FlawPost
     * @deprecated
     */
    'cvss2_score'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FlawPost
     * @deprecated
     */
    'nvd_cvss2'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawPost
     * @deprecated
     */
    'cvss3'?: string;
    /**
     * 
     * @type {number}
     * @memberof FlawPost
     * @deprecated
     */
    'cvss3_score'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FlawPost
     * @deprecated
     */
    'nvd_cvss3'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FlawPost
     * @deprecated
     */
    'is_major_incident'?: boolean;
    /**
     * 
     * @type {FlawMajorIncidentState}
     * @memberof FlawPost
     */
    'major_incident_state'?: FlawMajorIncidentState;
    /**
     * 
     * @type {FlawNistCvssValidation}
     * @memberof FlawPost
     */
    'nist_cvss_validation'?: FlawNistCvssValidation;
    /**
     * 
     * @type {Array<Affect>}
     * @memberof FlawPost
     */
    'affects': Array<Affect>;
    /**
     * 
     * @type {Array<Meta>}
     * @memberof FlawPost
     */
    'meta': Array<Meta>;
    /**
     * 
     * @type {Array<Comment>}
     * @memberof FlawPost
     */
    'comments': Array<Comment>;
    /**
     * 
     * @type {FlawMetaAttr}
     * @memberof FlawPost
     */
    'meta_attr': FlawMetaAttr;
    /**
     * 
     * @type {Array<Package>}
     * @memberof FlawPost
     */
    'package_versions': Array<Package>;
    /**
     * 
     * @type {Array<FlawAcknowledgment>}
     * @memberof FlawPost
     */
    'acknowledgments': Array<FlawAcknowledgment>;
    /**
     * 
     * @type {Array<FlawReference>}
     * @memberof FlawPost
     */
    'references': Array<FlawReference>;
    /**
     * 
     * @type {Array<FlawCVSS>}
     * @memberof FlawPost
     */
    'cvss_scores': Array<FlawCVSS>;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof FlawPost
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof FlawPost
     */
    'created_dt': string;
    /**
     * 
     * @type {FlawClassification}
     * @memberof FlawPost
     */
    'classification': FlawClassification;
}


/**
 * FlawReference serializer
 * @export
 * @interface FlawReference
 */
export interface FlawReference {
    /**
     * 
     * @type {string}
     * @memberof FlawReference
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawReference
     */
    'flaw': string;
    /**
     * 
     * @type {FlawReferenceType}
     * @memberof FlawReference
     */
    'type'?: FlawReferenceType;
    /**
     * 
     * @type {string}
     * @memberof FlawReference
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof FlawReference
     */
    'uuid': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof FlawReference
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof FlawReference
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof FlawReference
     */
    'updated_dt': string;
}


/**
 * FlawReference serializer
 * @export
 * @interface FlawReferencePost
 */
export interface FlawReferencePost {
    /**
     * 
     * @type {string}
     * @memberof FlawReferencePost
     */
    'description'?: string;
    /**
     * 
     * @type {FlawReferenceType}
     * @memberof FlawReferencePost
     */
    'type'?: FlawReferenceType;
    /**
     * 
     * @type {string}
     * @memberof FlawReferencePost
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof FlawReferencePost
     */
    'uuid': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof FlawReferencePost
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof FlawReferencePost
     */
    'created_dt': string;
}


/**
 * FlawReference serializer
 * @export
 * @interface FlawReferencePut
 */
export interface FlawReferencePut {
    /**
     * 
     * @type {string}
     * @memberof FlawReferencePut
     */
    'description'?: string;
    /**
     * 
     * @type {FlawReferenceType}
     * @memberof FlawReferencePut
     */
    'type'?: FlawReferenceType;
    /**
     * 
     * @type {string}
     * @memberof FlawReferencePut
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof FlawReferencePut
     */
    'uuid': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof FlawReferencePut
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof FlawReferencePut
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof FlawReferencePut
     */
    'updated_dt': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const FlawReferenceType = {
    Article: 'ARTICLE',
    External: 'EXTERNAL',
    Source: 'SOURCE'
} as const;

export type FlawReferenceType = typeof FlawReferenceType[keyof typeof FlawReferenceType];


/**
 * 
 * @export
 * @interface FlawReportData
 */
export interface FlawReportData {
    /**
     * 
     * @type {string}
     * @memberof FlawReportData
     */
    'cve_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlawReportData
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof FlawReportData
     */
    'resolution': string;
    /**
     * 
     * @type {Array<AffectReportData>}
     * @memberof FlawReportData
     */
    'affects'?: Array<AffectReportData>;
}
/**
 * @type FlawRequiresSummary
 * @export
 */
export type FlawRequiresSummary = BlankEnum | RequiresSummaryEnum;

/**
 * @type FlawSource
 * @export
 */
export type FlawSource = BlankEnum | Source666Enum;

/**
 * 
 * @export
 * @enum {string}
 */

export const FlawType = {
    Vulnerability: 'VULNERABILITY',
    Weakness: 'WEAKNESS'
} as const;

export type FlawType = typeof FlawType[keyof typeof FlawType];


/**
 * 
 * @export
 * @interface FlawUUIDList
 */
export interface FlawUUIDList {
    /**
     * 
     * @type {Array<string>}
     * @memberof FlawUUIDList
     */
    'flaw_uuids': Array<string>;
}
/**
 * PackageVer serializer used by FlawPackageVersionSerializer.
 * @export
 * @interface FlawVersion
 */
export interface FlawVersion {
    /**
     * 
     * @type {string}
     * @memberof FlawVersion
     */
    'version': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ImpactEnum = {
    Low: 'LOW',
    Moderate: 'MODERATE',
    Important: 'IMPORTANT',
    Critical: 'CRITICAL'
} as const;

export type ImpactEnum = typeof ImpactEnum[keyof typeof ImpactEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const IssuerEnum = {
    Rh: 'RH',
    Nist: 'NIST'
} as const;

export type IssuerEnum = typeof IssuerEnum[keyof typeof IssuerEnum];


/**
 * 
 * @export
 * @interface JiraComment
 */
export interface JiraComment {
    /**
     * 
     * @type {number}
     * @memberof JiraComment
     */
    'id': number;
    /**
     * 
     * @type {JiraUser}
     * @memberof JiraComment
     */
    'author': JiraUser;
    /**
     * 
     * @type {string}
     * @memberof JiraComment
     */
    'body': string;
    /**
     * 
     * @type {string}
     * @memberof JiraComment
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof JiraComment
     */
    'updated': string;
}
/**
 * 
 * @export
 * @interface JiraIssue
 */
export interface JiraIssue {
    /**
     * 
     * @type {number}
     * @memberof JiraIssue
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof JiraIssue
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof JiraIssue
     */
    'name': string;
    /**
     * 
     * @type {JiraIssueFields}
     * @memberof JiraIssue
     */
    'fields': JiraIssueFields;
}
/**
 * 
 * @export
 * @interface JiraIssueFields
 */
export interface JiraIssueFields {
    /**
     * 
     * @type {JiraIssueType}
     * @memberof JiraIssueFields
     */
    'issuetype': JiraIssueType;
    /**
     * 
     * @type {string}
     * @memberof JiraIssueFields
     */
    'summary': string;
    /**
     * 
     * @type {string}
     * @memberof JiraIssueFields
     */
    'description': string;
    /**
     * 
     * @type {JiraUser}
     * @memberof JiraIssueFields
     */
    'assignee': JiraUser;
    /**
     * 
     * @type {JiraUser}
     * @memberof JiraIssueFields
     */
    'reporter': JiraUser;
    /**
     * 
     * @type {JiraUser}
     * @memberof JiraIssueFields
     */
    'creator': JiraUser;
    /**
     * Task group key
     * @type {string}
     * @memberof JiraIssueFields
     */
    'customfield_12311140': string;
}
/**
 * 
 * @export
 * @interface JiraIssueQueryResult
 */
export interface JiraIssueQueryResult {
    /**
     * 
     * @type {number}
     * @memberof JiraIssueQueryResult
     */
    'total': number;
    /**
     * 
     * @type {Array<JiraIssue>}
     * @memberof JiraIssueQueryResult
     */
    'issues': Array<JiraIssue>;
}
/**
 * Jira issue type, can be a Task, Story or Epic.
 * @export
 * @interface JiraIssueType
 */
export interface JiraIssueType {
    /**
     * 
     * @type {number}
     * @memberof JiraIssueType
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof JiraIssueType
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface JiraUser
 */
export interface JiraUser {
    /**
     * 
     * @type {string}
     * @memberof JiraUser
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof JiraUser
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof JiraUser
     */
    'emailAddress': string;
    /**
     * 
     * @type {string}
     * @memberof JiraUser
     */
    'displayName': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const MajorIncidentStateEnum = {
    Requested: 'REQUESTED',
    Rejected: 'REJECTED',
    Approved: 'APPROVED',
    CisaApproved: 'CISA_APPROVED',
    Invalid: 'INVALID'
} as const;

export type MajorIncidentStateEnum = typeof MajorIncidentStateEnum[keyof typeof MajorIncidentStateEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const MaturityPreliminaryEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;

export type MaturityPreliminaryEnum = typeof MaturityPreliminaryEnum[keyof typeof MaturityPreliminaryEnum];


/**
 * FlawMeta serializer
 * @export
 * @interface Meta
 */
export interface Meta {
    /**
     * 
     * @type {string}
     * @memberof Meta
     */
    'uuid': string;
    /**
     * 
     * @type {FlawMetaType}
     * @memberof Meta
     */
    'type': FlawMetaType;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Meta
     */
    'meta_attr'?: { [key: string]: string; };
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof Meta
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof Meta
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof Meta
     */
    'updated_dt': string;
}


/**
 * 
 * @export
 * @interface ModuleComponent
 */
export interface ModuleComponent {
    /**
     * 
     * @type {string}
     * @memberof ModuleComponent
     */
    'ps_module': string;
    /**
     * 
     * @type {string}
     * @memberof ModuleComponent
     */
    'ps_component': string;
    /**
     * 
     * @type {Array<PsStreamSelection>}
     * @memberof ModuleComponent
     */
    'streams': Array<PsStreamSelection>;
    /**
     * 
     * @type {boolean}
     * @memberof ModuleComponent
     */
    'selected': boolean;
    /**
     * 
     * @type {string}
     * @memberof ModuleComponent
     */
    'affect': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const NistCvssValidationEnum = {
    Requested: 'REQUESTED',
    Approved: 'APPROVED',
    Rejected: 'REJECTED'
} as const;

export type NistCvssValidationEnum = typeof NistCvssValidationEnum[keyof typeof NistCvssValidationEnum];


/**
 * 
 * @export
 * @interface OsidbApiV1AffectsCreate201Response
 */
export interface OsidbApiV1AffectsCreate201Response {
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'flaw': string | null;
    /**
     * 
     * @type {AffectType}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'type'?: AffectType;
    /**
     * 
     * @type {AffectAffectedness}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'affectedness'?: AffectAffectedness;
    /**
     * 
     * @type {AffectResolution}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'resolution'?: AffectResolution;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'ps_module': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'ps_component': string;
    /**
     * 
     * @type {AffectImpact}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'impact'?: AffectImpact;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCreate201Response
     * @deprecated
     */
    'cvss2'?: string;
    /**
     * 
     * @type {number}
     * @memberof OsidbApiV1AffectsCreate201Response
     * @deprecated
     */
    'cvss2_score'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCreate201Response
     * @deprecated
     */
    'cvss3'?: string;
    /**
     * 
     * @type {number}
     * @memberof OsidbApiV1AffectsCreate201Response
     * @deprecated
     */
    'cvss3_score'?: number | null;
    /**
     * 
     * @type {Array<Tracker>}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'trackers': Array<Tracker>;
    /**
     * 
     * @type {AffectMetaAttr}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'meta_attr': AffectMetaAttr;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'delegated_resolution': string;
    /**
     * 
     * @type {Array<AffectCVSS>}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'cvss_scores': Array<AffectCVSS>;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'updated_dt': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'version'?: string;
}


/**
 * 
 * @export
 * @interface OsidbApiV1AffectsCvssScoresCreate201Response
 */
export interface OsidbApiV1AffectsCvssScoresCreate201Response {
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCvssScoresCreate201Response
     */
    'affect'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCvssScoresCreate201Response
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCvssScoresCreate201Response
     */
    'cvss_version': string;
    /**
     * 
     * @type {IssuerEnum}
     * @memberof OsidbApiV1AffectsCvssScoresCreate201Response
     */
    'issuer': IssuerEnum;
    /**
     * 
     * @type {number}
     * @memberof OsidbApiV1AffectsCvssScoresCreate201Response
     */
    'score'?: number;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCvssScoresCreate201Response
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCvssScoresCreate201Response
     */
    'vector': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof OsidbApiV1AffectsCvssScoresCreate201Response
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCvssScoresCreate201Response
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof OsidbApiV1AffectsCvssScoresCreate201Response
     */
    'updated_dt': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCvssScoresCreate201Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCvssScoresCreate201Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCvssScoresCreate201Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCvssScoresCreate201Response
     */
    'version'?: string;
}


/**
 * 
 * @export
 * @interface OsidbApiV1AffectsCvssScoresList200Response
 */
export interface OsidbApiV1AffectsCvssScoresList200Response {
    /**
     * 
     * @type {number}
     * @memberof OsidbApiV1AffectsCvssScoresList200Response
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCvssScoresList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCvssScoresList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<AffectCVSS>}
     * @memberof OsidbApiV1AffectsCvssScoresList200Response
     */
    'results'?: Array<AffectCVSS>;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCvssScoresList200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCvssScoresList200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCvssScoresList200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCvssScoresList200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface OsidbApiV1AffectsList200Response
 */
export interface OsidbApiV1AffectsList200Response {
    /**
     * 
     * @type {number}
     * @memberof OsidbApiV1AffectsList200Response
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Affect>}
     * @memberof OsidbApiV1AffectsList200Response
     */
    'results'?: Array<Affect>;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsList200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsList200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsList200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsList200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface OsidbApiV1FlawsAcknowledgmentsCreate201Response
 */
export interface OsidbApiV1FlawsAcknowledgmentsCreate201Response {
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsAcknowledgmentsCreate201Response
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsAcknowledgmentsCreate201Response
     */
    'affiliation': string;
    /**
     * 
     * @type {boolean}
     * @memberof OsidbApiV1FlawsAcknowledgmentsCreate201Response
     */
    'from_upstream': boolean;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsAcknowledgmentsCreate201Response
     */
    'flaw': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsAcknowledgmentsCreate201Response
     */
    'uuid': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof OsidbApiV1FlawsAcknowledgmentsCreate201Response
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsAcknowledgmentsCreate201Response
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof OsidbApiV1FlawsAcknowledgmentsCreate201Response
     */
    'updated_dt': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsAcknowledgmentsCreate201Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsAcknowledgmentsCreate201Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsAcknowledgmentsCreate201Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsAcknowledgmentsCreate201Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface OsidbApiV1FlawsAcknowledgmentsList200Response
 */
export interface OsidbApiV1FlawsAcknowledgmentsList200Response {
    /**
     * 
     * @type {number}
     * @memberof OsidbApiV1FlawsAcknowledgmentsList200Response
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsAcknowledgmentsList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsAcknowledgmentsList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<FlawAcknowledgment>}
     * @memberof OsidbApiV1FlawsAcknowledgmentsList200Response
     */
    'results'?: Array<FlawAcknowledgment>;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsAcknowledgmentsList200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsAcknowledgmentsList200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsAcknowledgmentsList200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsAcknowledgmentsList200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface OsidbApiV1FlawsCommentsCreate201Response
 */
export interface OsidbApiV1FlawsCommentsCreate201Response {
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCommentsCreate201Response
     */
    'flaw': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCommentsCreate201Response
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCommentsCreate201Response
     */
    'uuid': string;
    /**
     * 
     * @type {FlawCommentType}
     * @memberof OsidbApiV1FlawsCommentsCreate201Response
     */
    'type'?: FlawCommentType;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCommentsCreate201Response
     */
    'external_system_id': string;
    /**
     * 
     * @type {number}
     * @memberof OsidbApiV1FlawsCommentsCreate201Response
     */
    'order'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCommentsCreate201Response
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof OsidbApiV1FlawsCommentsCreate201Response
     */
    'updated_dt': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof OsidbApiV1FlawsCommentsCreate201Response
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCommentsCreate201Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCommentsCreate201Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCommentsCreate201Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCommentsCreate201Response
     */
    'version'?: string;
}


/**
 * 
 * @export
 * @interface OsidbApiV1FlawsCommentsList200Response
 */
export interface OsidbApiV1FlawsCommentsList200Response {
    /**
     * 
     * @type {number}
     * @memberof OsidbApiV1FlawsCommentsList200Response
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCommentsList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCommentsList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<FlawComment>}
     * @memberof OsidbApiV1FlawsCommentsList200Response
     */
    'results'?: Array<FlawComment>;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCommentsList200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCommentsList200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCommentsList200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCommentsList200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface OsidbApiV1FlawsCreate201Response
 */
export interface OsidbApiV1FlawsCreate201Response {
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'uuid': string;
    /**
     * 
     * @type {FlawType}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'type'?: FlawType;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'cve_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     * @deprecated
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     * @deprecated
     */
    'resolution': string;
    /**
     * 
     * @type {AffectImpact}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'impact'?: AffectImpact;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'component'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'title': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'trackers': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'summary'?: string;
    /**
     * 
     * @type {FlawRequiresSummary}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'requires_summary'?: FlawRequiresSummary;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'statement'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'cwe_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'unembargo_dt'?: string | null;
    /**
     * 
     * @type {FlawSource}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'source'?: FlawSource;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'reported_dt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'mitigation'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     * @deprecated
     */
    'cvss2'?: string;
    /**
     * 
     * @type {number}
     * @memberof OsidbApiV1FlawsCreate201Response
     * @deprecated
     */
    'cvss2_score'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     * @deprecated
     */
    'nvd_cvss2'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     * @deprecated
     */
    'cvss3'?: string;
    /**
     * 
     * @type {number}
     * @memberof OsidbApiV1FlawsCreate201Response
     * @deprecated
     */
    'cvss3_score'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     * @deprecated
     */
    'nvd_cvss3'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OsidbApiV1FlawsCreate201Response
     * @deprecated
     */
    'is_major_incident'?: boolean;
    /**
     * 
     * @type {FlawMajorIncidentState}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'major_incident_state'?: FlawMajorIncidentState;
    /**
     * 
     * @type {FlawNistCvssValidation}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'nist_cvss_validation'?: FlawNistCvssValidation;
    /**
     * 
     * @type {Array<Affect>}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'affects': Array<Affect>;
    /**
     * 
     * @type {Array<Meta>}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'meta': Array<Meta>;
    /**
     * 
     * @type {Array<Comment>}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'comments': Array<Comment>;
    /**
     * 
     * @type {FlawMetaAttr}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'meta_attr': FlawMetaAttr;
    /**
     * 
     * @type {Array<Package>}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'package_versions': Array<Package>;
    /**
     * 
     * @type {Array<FlawAcknowledgment>}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'acknowledgments': Array<FlawAcknowledgment>;
    /**
     * 
     * @type {Array<FlawReference>}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'references': Array<FlawReference>;
    /**
     * 
     * @type {Array<FlawCVSS>}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'cvss_scores': Array<FlawCVSS>;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'updated_dt': string;
    /**
     * 
     * @type {FlawClassification}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'classification': FlawClassification;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'version'?: string;
}


/**
 * 
 * @export
 * @interface OsidbApiV1FlawsCvssScoresCreate201Response
 */
export interface OsidbApiV1FlawsCvssScoresCreate201Response {
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCvssScoresCreate201Response
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCvssScoresCreate201Response
     */
    'cvss_version': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCvssScoresCreate201Response
     */
    'flaw'?: string;
    /**
     * 
     * @type {IssuerEnum}
     * @memberof OsidbApiV1FlawsCvssScoresCreate201Response
     */
    'issuer': IssuerEnum;
    /**
     * 
     * @type {number}
     * @memberof OsidbApiV1FlawsCvssScoresCreate201Response
     */
    'score'?: number;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCvssScoresCreate201Response
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCvssScoresCreate201Response
     */
    'vector': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof OsidbApiV1FlawsCvssScoresCreate201Response
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCvssScoresCreate201Response
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof OsidbApiV1FlawsCvssScoresCreate201Response
     */
    'updated_dt': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCvssScoresCreate201Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCvssScoresCreate201Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCvssScoresCreate201Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCvssScoresCreate201Response
     */
    'version'?: string;
}


/**
 * 
 * @export
 * @interface OsidbApiV1FlawsCvssScoresList200Response
 */
export interface OsidbApiV1FlawsCvssScoresList200Response {
    /**
     * 
     * @type {number}
     * @memberof OsidbApiV1FlawsCvssScoresList200Response
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCvssScoresList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCvssScoresList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<FlawCVSS>}
     * @memberof OsidbApiV1FlawsCvssScoresList200Response
     */
    'results'?: Array<FlawCVSS>;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCvssScoresList200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCvssScoresList200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCvssScoresList200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCvssScoresList200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface OsidbApiV1FlawsList200Response
 */
export interface OsidbApiV1FlawsList200Response {
    /**
     * 
     * @type {number}
     * @memberof OsidbApiV1FlawsList200Response
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Flaw>}
     * @memberof OsidbApiV1FlawsList200Response
     */
    'results'?: Array<Flaw>;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsList200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsList200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsList200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsList200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface OsidbApiV1FlawsPackageVersionsCreate201Response
 */
export interface OsidbApiV1FlawsPackageVersionsCreate201Response {
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsPackageVersionsCreate201Response
     */
    'package': string;
    /**
     * 
     * @type {Array<FlawVersion>}
     * @memberof OsidbApiV1FlawsPackageVersionsCreate201Response
     */
    'versions': Array<FlawVersion>;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsPackageVersionsCreate201Response
     */
    'flaw': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsPackageVersionsCreate201Response
     */
    'uuid': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof OsidbApiV1FlawsPackageVersionsCreate201Response
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsPackageVersionsCreate201Response
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof OsidbApiV1FlawsPackageVersionsCreate201Response
     */
    'updated_dt': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsPackageVersionsCreate201Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsPackageVersionsCreate201Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsPackageVersionsCreate201Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsPackageVersionsCreate201Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface OsidbApiV1FlawsPackageVersionsList200Response
 */
export interface OsidbApiV1FlawsPackageVersionsList200Response {
    /**
     * 
     * @type {number}
     * @memberof OsidbApiV1FlawsPackageVersionsList200Response
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsPackageVersionsList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsPackageVersionsList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<FlawPackageVersion>}
     * @memberof OsidbApiV1FlawsPackageVersionsList200Response
     */
    'results'?: Array<FlawPackageVersion>;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsPackageVersionsList200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsPackageVersionsList200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsPackageVersionsList200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsPackageVersionsList200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface OsidbApiV1FlawsReferencesCreate201Response
 */
export interface OsidbApiV1FlawsReferencesCreate201Response {
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsReferencesCreate201Response
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsReferencesCreate201Response
     */
    'flaw': string;
    /**
     * 
     * @type {FlawReferenceType}
     * @memberof OsidbApiV1FlawsReferencesCreate201Response
     */
    'type'?: FlawReferenceType;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsReferencesCreate201Response
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsReferencesCreate201Response
     */
    'uuid': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof OsidbApiV1FlawsReferencesCreate201Response
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsReferencesCreate201Response
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof OsidbApiV1FlawsReferencesCreate201Response
     */
    'updated_dt': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsReferencesCreate201Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsReferencesCreate201Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsReferencesCreate201Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsReferencesCreate201Response
     */
    'version'?: string;
}


/**
 * 
 * @export
 * @interface OsidbApiV1FlawsReferencesList200Response
 */
export interface OsidbApiV1FlawsReferencesList200Response {
    /**
     * 
     * @type {number}
     * @memberof OsidbApiV1FlawsReferencesList200Response
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsReferencesList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsReferencesList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<FlawReference>}
     * @memberof OsidbApiV1FlawsReferencesList200Response
     */
    'results'?: Array<FlawReference>;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsReferencesList200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsReferencesList200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsReferencesList200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsReferencesList200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface OsidbApiV1SchemaRetrieve200Response
 */
export interface OsidbApiV1SchemaRetrieve200Response {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1SchemaRetrieve200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1SchemaRetrieve200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1SchemaRetrieve200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1SchemaRetrieve200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface OsidbApiV1StatusRetrieve200Response
 */
export interface OsidbApiV1StatusRetrieve200Response {
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1StatusRetrieve200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1StatusRetrieve200Response
     */
    'env'?: string;
    /**
     * 
     * @type {OsidbApiV1StatusRetrieve200ResponseOsidbData}
     * @memberof OsidbApiV1StatusRetrieve200Response
     */
    'osidb_data'?: OsidbApiV1StatusRetrieve200ResponseOsidbData;
    /**
     * 
     * @type {object}
     * @memberof OsidbApiV1StatusRetrieve200Response
     */
    'osidb_service'?: object;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1StatusRetrieve200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1StatusRetrieve200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface OsidbApiV1StatusRetrieve200ResponseOsidbData
 */
export interface OsidbApiV1StatusRetrieve200ResponseOsidbData {
    /**
     * 
     * @type {number}
     * @memberof OsidbApiV1StatusRetrieve200ResponseOsidbData
     */
    'flaw_count'?: number;
}
/**
 * 
 * @export
 * @interface OsidbApiV1TrackersCreate201Response
 */
export interface OsidbApiV1TrackersCreate201Response {
    /**
     * 
     * @type {Array<string>}
     * @memberof OsidbApiV1TrackersCreate201Response
     */
    'affects'?: Array<string>;
    /**
     * 
     * @type {Array<Erratum>}
     * @memberof OsidbApiV1TrackersCreate201Response
     */
    'errata': Array<Erratum>;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1TrackersCreate201Response
     */
    'external_system_id': string;
    /**
     * 
     * @type {TrackerMetaAttr}
     * @memberof OsidbApiV1TrackersCreate201Response
     */
    'meta_attr': TrackerMetaAttr;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1TrackersCreate201Response
     */
    'ps_update_stream'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1TrackersCreate201Response
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1TrackersCreate201Response
     */
    'resolution'?: string;
    /**
     * 
     * @type {TrackerType}
     * @memberof OsidbApiV1TrackersCreate201Response
     */
    'type': TrackerType;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1TrackersCreate201Response
     */
    'uuid': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof OsidbApiV1TrackersCreate201Response
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1TrackersCreate201Response
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof OsidbApiV1TrackersCreate201Response
     */
    'updated_dt': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1TrackersCreate201Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1TrackersCreate201Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1TrackersCreate201Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1TrackersCreate201Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface OsidbApiV1TrackersList200Response
 */
export interface OsidbApiV1TrackersList200Response {
    /**
     * 
     * @type {number}
     * @memberof OsidbApiV1TrackersList200Response
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1TrackersList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1TrackersList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Tracker>}
     * @memberof OsidbApiV1TrackersList200Response
     */
    'results'?: Array<Tracker>;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1TrackersList200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1TrackersList200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1TrackersList200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1TrackersList200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface OsidbWhoamiRetrieve200Response
 */
export interface OsidbWhoamiRetrieve200Response {
    /**
     * 
     * @type {string}
     * @memberof OsidbWhoamiRetrieve200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbWhoamiRetrieve200Response
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbWhoamiRetrieve200Response
     */
    'env'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof OsidbWhoamiRetrieve200Response
     */
    'groups'?: Array<string>;
    /**
     * 
     * @type {OsidbWhoamiRetrieve200ResponseProfile}
     * @memberof OsidbWhoamiRetrieve200Response
     */
    'profile'?: OsidbWhoamiRetrieve200ResponseProfile;
    /**
     * 
     * @type {string}
     * @memberof OsidbWhoamiRetrieve200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbWhoamiRetrieve200Response
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbWhoamiRetrieve200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface OsidbWhoamiRetrieve200ResponseProfile
 */
export interface OsidbWhoamiRetrieve200ResponseProfile {
    /**
     * 
     * @type {string}
     * @memberof OsidbWhoamiRetrieve200ResponseProfile
     */
    'bz_user_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbWhoamiRetrieve200ResponseProfile
     */
    'jira_user_id'?: string;
}
/**
 * package_versions (Package model) serializer for read-only use in FlawSerializer.
 * @export
 * @interface Package
 */
export interface Package {
    /**
     * 
     * @type {string}
     * @memberof Package
     */
    'package': string;
    /**
     * 
     * @type {Array<PackageVer>}
     * @memberof Package
     */
    'versions': Array<PackageVer>;
}
/**
 * PackageVer model serializer for read-only use in FlawSerializer via PackageVerSerializer.
 * @export
 * @interface PackageVer
 */
export interface PackageVer {
    /**
     * 
     * @type {string}
     * @memberof PackageVer
     */
    'version': string;
    /**
     * 
     * @type {string}
     * @memberof PackageVer
     * @deprecated
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface PaginatedAffectCVSSList
 */
export interface PaginatedAffectCVSSList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedAffectCVSSList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAffectCVSSList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAffectCVSSList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<AffectCVSS>}
     * @memberof PaginatedAffectCVSSList
     */
    'results'?: Array<AffectCVSS>;
}
/**
 * 
 * @export
 * @interface PaginatedAffectList
 */
export interface PaginatedAffectList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedAffectList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAffectList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAffectList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Affect>}
     * @memberof PaginatedAffectList
     */
    'results'?: Array<Affect>;
}
/**
 * 
 * @export
 * @interface PaginatedEPSSList
 */
export interface PaginatedEPSSList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedEPSSList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedEPSSList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedEPSSList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<EPSS>}
     * @memberof PaginatedEPSSList
     */
    'results'?: Array<EPSS>;
}
/**
 * 
 * @export
 * @interface PaginatedExploitOnlyReportDataList
 */
export interface PaginatedExploitOnlyReportDataList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedExploitOnlyReportDataList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedExploitOnlyReportDataList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedExploitOnlyReportDataList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<ExploitOnlyReportData>}
     * @memberof PaginatedExploitOnlyReportDataList
     */
    'results'?: Array<ExploitOnlyReportData>;
}
/**
 * 
 * @export
 * @interface PaginatedFlawAcknowledgmentList
 */
export interface PaginatedFlawAcknowledgmentList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedFlawAcknowledgmentList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFlawAcknowledgmentList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFlawAcknowledgmentList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<FlawAcknowledgment>}
     * @memberof PaginatedFlawAcknowledgmentList
     */
    'results'?: Array<FlawAcknowledgment>;
}
/**
 * 
 * @export
 * @interface PaginatedFlawCVSSList
 */
export interface PaginatedFlawCVSSList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedFlawCVSSList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFlawCVSSList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFlawCVSSList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<FlawCVSS>}
     * @memberof PaginatedFlawCVSSList
     */
    'results'?: Array<FlawCVSS>;
}
/**
 * 
 * @export
 * @interface PaginatedFlawCommentList
 */
export interface PaginatedFlawCommentList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedFlawCommentList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFlawCommentList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFlawCommentList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<FlawComment>}
     * @memberof PaginatedFlawCommentList
     */
    'results'?: Array<FlawComment>;
}
/**
 * 
 * @export
 * @interface PaginatedFlawList
 */
export interface PaginatedFlawList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedFlawList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFlawList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFlawList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Flaw>}
     * @memberof PaginatedFlawList
     */
    'results'?: Array<Flaw>;
}
/**
 * 
 * @export
 * @interface PaginatedFlawPackageVersionList
 */
export interface PaginatedFlawPackageVersionList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedFlawPackageVersionList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFlawPackageVersionList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFlawPackageVersionList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<FlawPackageVersion>}
     * @memberof PaginatedFlawPackageVersionList
     */
    'results'?: Array<FlawPackageVersion>;
}
/**
 * 
 * @export
 * @interface PaginatedFlawReferenceList
 */
export interface PaginatedFlawReferenceList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedFlawReferenceList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFlawReferenceList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFlawReferenceList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<FlawReference>}
     * @memberof PaginatedFlawReferenceList
     */
    'results'?: Array<FlawReference>;
}
/**
 * 
 * @export
 * @interface PaginatedFlawReportDataList
 */
export interface PaginatedFlawReportDataList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedFlawReportDataList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFlawReportDataList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFlawReportDataList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<FlawReportData>}
     * @memberof PaginatedFlawReportDataList
     */
    'results'?: Array<FlawReportData>;
}
/**
 * 
 * @export
 * @interface PaginatedSupportedProductsList
 */
export interface PaginatedSupportedProductsList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSupportedProductsList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSupportedProductsList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSupportedProductsList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<SupportedProducts>}
     * @memberof PaginatedSupportedProductsList
     */
    'results'?: Array<SupportedProducts>;
}
/**
 * 
 * @export
 * @interface PaginatedTrackerList
 */
export interface PaginatedTrackerList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedTrackerList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedTrackerList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedTrackerList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Tracker>}
     * @memberof PaginatedTrackerList
     */
    'results'?: Array<Tracker>;
}
/**
 * 
 * @export
 * @interface PsStreamSelection
 */
export interface PsStreamSelection {
    /**
     * 
     * @type {string}
     * @memberof PsStreamSelection
     */
    'ps_update_stream': string;
    /**
     * 
     * @type {boolean}
     * @memberof PsStreamSelection
     */
    'selected': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PsStreamSelection
     */
    'acked': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PsStreamSelection
     */
    'eus': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PsStreamSelection
     */
    'aus': boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const RequiresSummaryEnum = {
    Requested: 'REQUESTED',
    Approved: 'APPROVED',
    Rejected: 'REJECTED'
} as const;

export type RequiresSummaryEnum = typeof RequiresSummaryEnum[keyof typeof RequiresSummaryEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const ResolutionEnum = {
    Fix: 'FIX',
    Defer: 'DEFER',
    Wontfix: 'WONTFIX',
    Ooss: 'OOSS',
    Delegated: 'DELEGATED',
    Wontreport: 'WONTREPORT'
} as const;

export type ResolutionEnum = typeof ResolutionEnum[keyof typeof ResolutionEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const Source666Enum = {
    Adobe: 'ADOBE',
    Apple: 'APPLE',
    Asf: 'ASF',
    Bind: 'BIND',
    Bk: 'BK',
    Bugtraq: 'BUGTRAQ',
    Bugzilla: 'BUGZILLA',
    Cert: 'CERT',
    Certifi: 'CERTIFI',
    Corelabs: 'CORELABS',
    Customer: 'CUSTOMER',
    Cve: 'CVE',
    Dailydave: 'DAILYDAVE',
    Debian: 'DEBIAN',
    Distros: 'DISTROS',
    Fedora: 'FEDORA',
    Fetchmail: 'FETCHMAIL',
    Freedesktop: 'FREEDESKTOP',
    Freeradius: 'FREERADIUS',
    Frsirt: 'FRSIRT',
    Fulldisclosure: 'FULLDISCLOSURE',
    Gaim: 'GAIM',
    Gentoo: 'GENTOO',
    Gentoobz: 'GENTOOBZ',
    Git: 'GIT',
    Gnome: 'GNOME',
    Gnupg: 'GNUPG',
    Google: 'GOOGLE',
    Hp: 'HP',
    HwVendor: 'HW_VENDOR',
    Ibm: 'IBM',
    Idefense: 'IDEFENSE',
    Internet: 'INTERNET',
    Isc: 'ISC',
    Isec: 'ISEC',
    It: 'IT',
    Jboss: 'JBOSS',
    Jpcert: 'JPCERT',
    Kernelbugzilla: 'KERNELBUGZILLA',
    Kernelsec: 'KERNELSEC',
    Lkml: 'LKML',
    Lwn: 'LWN',
    Macromedia: 'MACROMEDIA',
    Mageia: 'MAGEIA',
    Mailinglist: 'MAILINGLIST',
    Milw0Rm: 'MILW0RM',
    Mit: 'MIT',
    Mitre: 'MITRE',
    Mozilla: 'MOZILLA',
    Muttdev: 'MUTTDEV',
    Netdev: 'NETDEV',
    Niscc: 'NISCC',
    Ocert: 'OCERT',
    Openoffice: 'OPENOFFICE',
    Openssl: 'OPENSSL',
    Opensuse: 'OPENSUSE',
    Oracle: 'ORACLE',
    Oss: 'OSS',
    Osssecurity: 'OSSSECURITY',
    Php: 'PHP',
    Pidgin: 'PIDGIN',
    Postgresql: 'POSTGRESQL',
    Press: 'PRESS',
    Real: 'REAL',
    Redhat: 'REDHAT',
    Researcher: 'RESEARCHER',
    Rt: 'RT',
    Samba: 'SAMBA',
    Secalert: 'SECALERT',
    Secunia: 'SECUNIA',
    Securityfocus: 'SECURITYFOCUS',
    Sko: 'SKO',
    Squid: 'SQUID',
    Squirrelmail: 'SQUIRRELMAIL',
    Sun: 'SUN',
    Sunsolve: 'SUNSOLVE',
    Suse: 'SUSE',
    Twitter: 'TWITTER',
    Ubuntu: 'UBUNTU',
    Upstream: 'UPSTREAM',
    Vendorsec: 'VENDORSEC',
    Vulnwatch: 'VULNWATCH',
    Wireshark: 'WIRESHARK',
    Xchat: 'XCHAT',
    Xen: 'XEN',
    Xpdf: 'XPDF'
} as const;

export type Source666Enum = typeof Source666Enum[keyof typeof Source666Enum];


/**
 * 
 * @export
 * @interface SupportedProducts
 */
export interface SupportedProducts {
    /**
     * 
     * @type {string}
     * @memberof SupportedProducts
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface TaskmanApiV1GroupCreate200Response
 */
export interface TaskmanApiV1GroupCreate200Response {
    /**
     * 
     * @type {number}
     * @memberof TaskmanApiV1GroupCreate200Response
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof TaskmanApiV1GroupCreate200Response
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof TaskmanApiV1GroupCreate200Response
     */
    'name': string;
    /**
     * 
     * @type {JiraIssueFields}
     * @memberof TaskmanApiV1GroupCreate200Response
     */
    'fields': JiraIssueFields;
    /**
     * 
     * @type {string}
     * @memberof TaskmanApiV1GroupCreate200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskmanApiV1GroupCreate200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskmanApiV1GroupCreate200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskmanApiV1GroupCreate200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface TaskmanApiV1GroupRetrieve200Response
 */
export interface TaskmanApiV1GroupRetrieve200Response {
    /**
     * 
     * @type {number}
     * @memberof TaskmanApiV1GroupRetrieve200Response
     */
    'total': number;
    /**
     * 
     * @type {Array<JiraIssue>}
     * @memberof TaskmanApiV1GroupRetrieve200Response
     */
    'issues': Array<JiraIssue>;
    /**
     * 
     * @type {string}
     * @memberof TaskmanApiV1GroupRetrieve200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskmanApiV1GroupRetrieve200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskmanApiV1GroupRetrieve200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskmanApiV1GroupRetrieve200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface TaskmanApiV1TaskCommentCreate200Response
 */
export interface TaskmanApiV1TaskCommentCreate200Response {
    /**
     * 
     * @type {number}
     * @memberof TaskmanApiV1TaskCommentCreate200Response
     */
    'id': number;
    /**
     * 
     * @type {JiraUser}
     * @memberof TaskmanApiV1TaskCommentCreate200Response
     */
    'author': JiraUser;
    /**
     * 
     * @type {string}
     * @memberof TaskmanApiV1TaskCommentCreate200Response
     */
    'body': string;
    /**
     * 
     * @type {string}
     * @memberof TaskmanApiV1TaskCommentCreate200Response
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof TaskmanApiV1TaskCommentCreate200Response
     */
    'updated': string;
    /**
     * 
     * @type {string}
     * @memberof TaskmanApiV1TaskCommentCreate200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskmanApiV1TaskCommentCreate200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskmanApiV1TaskCommentCreate200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskmanApiV1TaskCommentCreate200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface TokenObtainPair
 */
export interface TokenObtainPair {
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    'access': string;
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    'refresh': string;
}
/**
 * 
 * @export
 * @interface TokenRefresh
 */
export interface TokenRefresh {
    /**
     * 
     * @type {string}
     * @memberof TokenRefresh
     */
    'access': string;
    /**
     * 
     * @type {string}
     * @memberof TokenRefresh
     */
    'refresh': string;
}
/**
 * 
 * @export
 * @interface TokenVerify
 */
export interface TokenVerify {
    /**
     * 
     * @type {string}
     * @memberof TokenVerify
     */
    'token': string;
}
/**
 * Tracker serializer
 * @export
 * @interface Tracker
 */
export interface Tracker {
    /**
     * 
     * @type {Array<string>}
     * @memberof Tracker
     */
    'affects'?: Array<string>;
    /**
     * 
     * @type {Array<Erratum>}
     * @memberof Tracker
     */
    'errata': Array<Erratum>;
    /**
     * 
     * @type {string}
     * @memberof Tracker
     */
    'external_system_id': string;
    /**
     * 
     * @type {TrackerMetaAttr}
     * @memberof Tracker
     */
    'meta_attr': TrackerMetaAttr;
    /**
     * 
     * @type {string}
     * @memberof Tracker
     */
    'ps_update_stream'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tracker
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof Tracker
     */
    'resolution'?: string;
    /**
     * 
     * @type {TrackerType}
     * @memberof Tracker
     */
    'type': TrackerType;
    /**
     * 
     * @type {string}
     * @memberof Tracker
     */
    'uuid': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof Tracker
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof Tracker
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof Tracker
     */
    'updated_dt': string;
}
/**
 * 
 * @export
 * @interface TrackerMetaAttr
 */
export interface TrackerMetaAttr {
    /**
     * 
     * @type {string}
     * @memberof TrackerMetaAttr
     */
    'bz_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrackerMetaAttr
     */
    'owner'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrackerMetaAttr
     */
    'qe_owner'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrackerMetaAttr
     */
    'ps_component'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrackerMetaAttr
     */
    'ps_module'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrackerMetaAttr
     */
    'ps_update_stream'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrackerMetaAttr
     */
    'resolution'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrackerMetaAttr
     */
    'status'?: string;
}
/**
 * Tracker serializer
 * @export
 * @interface TrackerPost
 */
export interface TrackerPost {
    /**
     * 
     * @type {Array<string>}
     * @memberof TrackerPost
     */
    'affects'?: Array<string>;
    /**
     * 
     * @type {Array<Erratum>}
     * @memberof TrackerPost
     */
    'errata': Array<Erratum>;
    /**
     * 
     * @type {TrackerMetaAttr}
     * @memberof TrackerPost
     */
    'meta_attr': TrackerMetaAttr;
    /**
     * 
     * @type {string}
     * @memberof TrackerPost
     */
    'ps_update_stream'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrackerPost
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof TrackerPost
     */
    'resolution'?: string;
    /**
     * 
     * @type {TrackerType}
     * @memberof TrackerPost
     */
    'type': TrackerType;
    /**
     * 
     * @type {string}
     * @memberof TrackerPost
     */
    'uuid': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof TrackerPost
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof TrackerPost
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof TrackerPost
     */
    'updated_dt': string;
}
/**
 * 
 * @export
 * @interface TrackerReportData
 */
export interface TrackerReportData {
    /**
     * 
     * @type {TrackerType}
     * @memberof TrackerReportData
     */
    'type': TrackerType;
    /**
     * 
     * @type {string}
     * @memberof TrackerReportData
     */
    'external_system_id': string;
    /**
     * 
     * @type {string}
     * @memberof TrackerReportData
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof TrackerReportData
     */
    'resolution'?: string;
}


/**
 * 
 * @export
 * @interface TrackerSuggestion
 */
export interface TrackerSuggestion {
    /**
     * 
     * @type {Array<ModuleComponent>}
     * @memberof TrackerSuggestion
     */
    'modules_components': Array<ModuleComponent>;
    /**
     * 
     * @type {string}
     * @memberof TrackerSuggestion
     */
    'not_applicable': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TrackerType = {
    Jira: 'JIRA',
    Bugzilla: 'BUGZILLA'
} as const;

export type TrackerType = typeof TrackerType[keyof typeof TrackerType];



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPair} tokenObtainPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenCreate: async (tokenObtainPair: TokenObtainPair, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenObtainPair' is not null or undefined
            assertParamExists('authTokenCreate', 'tokenObtainPair', tokenObtainPair)
            const localVarPath = `/auth/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenObtainPair, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefresh} tokenRefresh 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenRefreshCreate: async (tokenRefresh: TokenRefresh, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenRefresh' is not null or undefined
            assertParamExists('authTokenRefreshCreate', 'tokenRefresh', tokenRefresh)
            const localVarPath = `/auth/token/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRefresh, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a kerberos ticket and returns an access and refresh JWT pair.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication KerberosAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
         * @param {TokenVerify} tokenVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenVerifyCreate: async (tokenVerify: TokenVerify, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenVerify' is not null or undefined
            assertParamExists('authTokenVerifyCreate', 'tokenVerify', tokenVerify)
            const localVarPath = `/auth/token/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenVerify, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPair} tokenObtainPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTokenCreate(tokenObtainPair: TokenObtainPair, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authTokenCreate(tokenObtainPair, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefresh} tokenRefresh 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTokenRefreshCreate(tokenRefresh: TokenRefresh, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenRefreshCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authTokenRefreshCreate(tokenRefresh, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Takes a kerberos ticket and returns an access and refresh JWT pair.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTokenRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenRetrieve200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authTokenRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
         * @param {TokenVerify} tokenVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTokenVerifyCreate(tokenVerify: TokenVerify, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenVerifyCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authTokenVerifyCreate(tokenVerify, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPair} tokenObtainPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenCreate(tokenObtainPair: TokenObtainPair, options?: any): AxiosPromise<AuthTokenCreate200Response> {
            return localVarFp.authTokenCreate(tokenObtainPair, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefresh} tokenRefresh 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenRefreshCreate(tokenRefresh: TokenRefresh, options?: any): AxiosPromise<AuthTokenRefreshCreate200Response> {
            return localVarFp.authTokenRefreshCreate(tokenRefresh, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a kerberos ticket and returns an access and refresh JWT pair.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenRetrieve(options?: any): AxiosPromise<AuthTokenRetrieve200Response> {
            return localVarFp.authTokenRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
         * @param {TokenVerify} tokenVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenVerifyCreate(tokenVerify: TokenVerify, options?: any): AxiosPromise<AuthTokenVerifyCreate200Response> {
            return localVarFp.authTokenVerifyCreate(tokenVerify, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
     * @param {TokenObtainPair} tokenObtainPair 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authTokenCreate(tokenObtainPair: TokenObtainPair, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authTokenCreate(tokenObtainPair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
     * @param {TokenRefresh} tokenRefresh 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authTokenRefreshCreate(tokenRefresh: TokenRefresh, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authTokenRefreshCreate(tokenRefresh, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a kerberos ticket and returns an access and refresh JWT pair.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authTokenRetrieve(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authTokenRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
     * @param {TokenVerify} tokenVerify 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authTokenVerifyCreate(tokenVerify: TokenVerify, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authTokenVerifyCreate(tokenVerify, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CollectorsApi - axios parameter creator
 * @export
 */
export const CollectorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * get the overall status of all collectors and the collected data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectorsApiV1StatusRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/collectors/api/v1/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * unauthenticated health check API endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectorsHealthyRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/collectors/healthy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * index API endpoint listing available collector API endpoints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectorsRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/collectors/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectorsApi - functional programming interface
 * @export
 */
export const CollectorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CollectorsApiAxiosParamCreator(configuration)
    return {
        /**
         * get the overall status of all collectors and the collected data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectorsApiV1StatusRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectorsApiV1StatusRetrieve200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectorsApiV1StatusRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * unauthenticated health check API endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectorsHealthyRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200ResponseAllOf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectorsHealthyRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * index API endpoint listing available collector API endpoints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectorsRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectorsRetrieve200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectorsRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CollectorsApi - factory interface
 * @export
 */
export const CollectorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CollectorsApiFp(configuration)
    return {
        /**
         * get the overall status of all collectors and the collected data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectorsApiV1StatusRetrieve(options?: any): AxiosPromise<CollectorsApiV1StatusRetrieve200Response> {
            return localVarFp.collectorsApiV1StatusRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * unauthenticated health check API endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectorsHealthyRetrieve(options?: any): AxiosPromise<AuthTokenCreate200ResponseAllOf> {
            return localVarFp.collectorsHealthyRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * index API endpoint listing available collector API endpoints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectorsRetrieve(options?: any): AxiosPromise<CollectorsRetrieve200Response> {
            return localVarFp.collectorsRetrieve(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CollectorsApi - object-oriented interface
 * @export
 * @class CollectorsApi
 * @extends {BaseAPI}
 */
export class CollectorsApi extends BaseAPI {
    /**
     * get the overall status of all collectors and the collected data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectorsApi
     */
    public collectorsApiV1StatusRetrieve(options?: AxiosRequestConfig) {
        return CollectorsApiFp(this.configuration).collectorsApiV1StatusRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * unauthenticated health check API endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectorsApi
     */
    public collectorsHealthyRetrieve(options?: AxiosRequestConfig) {
        return CollectorsApiFp(this.configuration).collectorsHealthyRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * index API endpoint listing available collector API endpoints
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectorsApi
     */
    public collectorsRetrieve(options?: AxiosRequestConfig) {
        return CollectorsApiFp(this.configuration).collectorsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ExploitsApi - axios parameter creator
 * @export
 */
export const ExploitsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * API endpoint for re-collecting exploit data.  **NOTE:** Currently for CISA data only, which is very small and collection is fast.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1CollectUpdate: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/exploits/api/v1/collect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint for getting simple exploits information mapped to impacted CVEs.  The Insights Vulnerability application needs this format.  Format of results: ``` {   \"page_size\": <Number of CVEs on the page>,   \"cves\": {     \"CVE-2222-0001\": [<List of exploits>],     \"CVE-2222-0002\": [<List of exploits>],     ...   }, } ```
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1CveMapRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/exploits/api/v1/cve_map`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint for getting list of Red Hat relevant CVEs with their EPSS score.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1EpssList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/exploits/api/v1/epss`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Flaw, affect, and tracker data for Exploits
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1FlawDataList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/exploits/api/v1/flaw_data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export only the data required to generate the exploits report
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1ReportDataList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/exploits/api/v1/report_data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint for getting date based report for Incident Response.  Format of results: ``` {   \"cutoff_date\": <Date>,   \"evaluated_cves\": <Number of new CVEs with exploits>,   \"action_required\": [<List of affects requiring action>],   \"no_action\": [<List of CVEs not requiring action with reason>],   \"not_relevant\": [<List of CVEs which are not in the database with reason>], } ```  **NOTE:** No pagination is performed on this endpoint as data is limited by date and is expected           to be fairly small. Also, because data is broken into three categories it is not           exactly obvious how to create pages.
         * @param {string} date Date format: YYYY-MM-DD
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1ReportDateRetrieve: async (date: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'date' is not null or undefined
            assertParamExists('exploitsApiV1ReportDateRetrieve', 'date', date)
            const localVarPath = `/exploits/api/v1/report/date/{date}`
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint for getting a report of all CVEs with exploit and their status for Incident Response.  Format of results: ``` {    \"page_size\": <Number of CVEs on the page>,    \"explanations\": [<List of CVEs with exploit together with current status explanation>], } ```
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1ReportExplanationsRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/exploits/api/v1/report/explanations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint for getting a report of pending actions for Incident Response.  Format of results: ``` {   \"pending_actions\": [<List of affects requiring action>],   \"pending_actions_count\": <Number of affects requiring action>, } ```  **NOTE:** No pagination is performed on this endpoint as it is expected that the size of           the list of pending actions will be mostly stable. Also, the paging cannot be done on           the query level, as additional analysis of every exploit is required before a decision           to include it in this report is done.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1ReportPendingRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/exploits/api/v1/report/pending`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint for getting basic information about exploits in the database.  **NOTE:** Everyone is allowed to see basic information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1StatusRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/exploits/api/v1/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint for getting a list of all supported products.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1SupportedProductsList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/exploits/api/v1/supported-products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExploitsApi - functional programming interface
 * @export
 */
export const ExploitsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExploitsApiAxiosParamCreator(configuration)
    return {
        /**
         * API endpoint for re-collecting exploit data.  **NOTE:** Currently for CISA data only, which is very small and collection is fast.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exploitsApiV1CollectUpdate(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExploitsApiV1CollectUpdate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exploitsApiV1CollectUpdate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API endpoint for getting simple exploits information mapped to impacted CVEs.  The Insights Vulnerability application needs this format.  Format of results: ``` {   \"page_size\": <Number of CVEs on the page>,   \"cves\": {     \"CVE-2222-0001\": [<List of exploits>],     \"CVE-2222-0002\": [<List of exploits>],     ...   }, } ```
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exploitsApiV1CveMapRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExploitsApiV1CveMapRetrieve200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exploitsApiV1CveMapRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API endpoint for getting list of Red Hat relevant CVEs with their EPSS score.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exploitsApiV1EpssList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExploitsApiV1EpssList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exploitsApiV1EpssList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Flaw, affect, and tracker data for Exploits
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exploitsApiV1FlawDataList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExploitsApiV1FlawDataList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exploitsApiV1FlawDataList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Export only the data required to generate the exploits report
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exploitsApiV1ReportDataList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExploitsApiV1ReportDataList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exploitsApiV1ReportDataList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API endpoint for getting date based report for Incident Response.  Format of results: ``` {   \"cutoff_date\": <Date>,   \"evaluated_cves\": <Number of new CVEs with exploits>,   \"action_required\": [<List of affects requiring action>],   \"no_action\": [<List of CVEs not requiring action with reason>],   \"not_relevant\": [<List of CVEs which are not in the database with reason>], } ```  **NOTE:** No pagination is performed on this endpoint as data is limited by date and is expected           to be fairly small. Also, because data is broken into three categories it is not           exactly obvious how to create pages.
         * @param {string} date Date format: YYYY-MM-DD
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exploitsApiV1ReportDateRetrieve(date: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExploitsApiV1ReportDateRetrieve200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exploitsApiV1ReportDateRetrieve(date, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API endpoint for getting a report of all CVEs with exploit and their status for Incident Response.  Format of results: ``` {    \"page_size\": <Number of CVEs on the page>,    \"explanations\": [<List of CVEs with exploit together with current status explanation>], } ```
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exploitsApiV1ReportExplanationsRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExploitsApiV1ReportExplanationsRetrieve200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exploitsApiV1ReportExplanationsRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API endpoint for getting a report of pending actions for Incident Response.  Format of results: ``` {   \"pending_actions\": [<List of affects requiring action>],   \"pending_actions_count\": <Number of affects requiring action>, } ```  **NOTE:** No pagination is performed on this endpoint as it is expected that the size of           the list of pending actions will be mostly stable. Also, the paging cannot be done on           the query level, as additional analysis of every exploit is required before a decision           to include it in this report is done.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exploitsApiV1ReportPendingRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExploitsApiV1ReportPendingRetrieve200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exploitsApiV1ReportPendingRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API endpoint for getting basic information about exploits in the database.  **NOTE:** Everyone is allowed to see basic information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exploitsApiV1StatusRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExploitsApiV1StatusRetrieve200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exploitsApiV1StatusRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API endpoint for getting a list of all supported products.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exploitsApiV1SupportedProductsList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExploitsApiV1SupportedProductsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exploitsApiV1SupportedProductsList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExploitsApi - factory interface
 * @export
 */
export const ExploitsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExploitsApiFp(configuration)
    return {
        /**
         * API endpoint for re-collecting exploit data.  **NOTE:** Currently for CISA data only, which is very small and collection is fast.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1CollectUpdate(options?: any): AxiosPromise<ExploitsApiV1CollectUpdate200Response> {
            return localVarFp.exploitsApiV1CollectUpdate(options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint for getting simple exploits information mapped to impacted CVEs.  The Insights Vulnerability application needs this format.  Format of results: ``` {   \"page_size\": <Number of CVEs on the page>,   \"cves\": {     \"CVE-2222-0001\": [<List of exploits>],     \"CVE-2222-0002\": [<List of exploits>],     ...   }, } ```
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1CveMapRetrieve(options?: any): AxiosPromise<ExploitsApiV1CveMapRetrieve200Response> {
            return localVarFp.exploitsApiV1CveMapRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint for getting list of Red Hat relevant CVEs with their EPSS score.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1EpssList(limit?: number, offset?: number, options?: any): AxiosPromise<ExploitsApiV1EpssList200Response> {
            return localVarFp.exploitsApiV1EpssList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Flaw, affect, and tracker data for Exploits
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1FlawDataList(limit?: number, offset?: number, options?: any): AxiosPromise<ExploitsApiV1FlawDataList200Response> {
            return localVarFp.exploitsApiV1FlawDataList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Export only the data required to generate the exploits report
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1ReportDataList(limit?: number, offset?: number, options?: any): AxiosPromise<ExploitsApiV1ReportDataList200Response> {
            return localVarFp.exploitsApiV1ReportDataList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint for getting date based report for Incident Response.  Format of results: ``` {   \"cutoff_date\": <Date>,   \"evaluated_cves\": <Number of new CVEs with exploits>,   \"action_required\": [<List of affects requiring action>],   \"no_action\": [<List of CVEs not requiring action with reason>],   \"not_relevant\": [<List of CVEs which are not in the database with reason>], } ```  **NOTE:** No pagination is performed on this endpoint as data is limited by date and is expected           to be fairly small. Also, because data is broken into three categories it is not           exactly obvious how to create pages.
         * @param {string} date Date format: YYYY-MM-DD
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1ReportDateRetrieve(date: string, options?: any): AxiosPromise<ExploitsApiV1ReportDateRetrieve200Response> {
            return localVarFp.exploitsApiV1ReportDateRetrieve(date, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint for getting a report of all CVEs with exploit and their status for Incident Response.  Format of results: ``` {    \"page_size\": <Number of CVEs on the page>,    \"explanations\": [<List of CVEs with exploit together with current status explanation>], } ```
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1ReportExplanationsRetrieve(options?: any): AxiosPromise<ExploitsApiV1ReportExplanationsRetrieve200Response> {
            return localVarFp.exploitsApiV1ReportExplanationsRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint for getting a report of pending actions for Incident Response.  Format of results: ``` {   \"pending_actions\": [<List of affects requiring action>],   \"pending_actions_count\": <Number of affects requiring action>, } ```  **NOTE:** No pagination is performed on this endpoint as it is expected that the size of           the list of pending actions will be mostly stable. Also, the paging cannot be done on           the query level, as additional analysis of every exploit is required before a decision           to include it in this report is done.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1ReportPendingRetrieve(options?: any): AxiosPromise<ExploitsApiV1ReportPendingRetrieve200Response> {
            return localVarFp.exploitsApiV1ReportPendingRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint for getting basic information about exploits in the database.  **NOTE:** Everyone is allowed to see basic information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1StatusRetrieve(options?: any): AxiosPromise<ExploitsApiV1StatusRetrieve200Response> {
            return localVarFp.exploitsApiV1StatusRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint for getting a list of all supported products.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1SupportedProductsList(limit?: number, offset?: number, options?: any): AxiosPromise<ExploitsApiV1SupportedProductsList200Response> {
            return localVarFp.exploitsApiV1SupportedProductsList(limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExploitsApi - object-oriented interface
 * @export
 * @class ExploitsApi
 * @extends {BaseAPI}
 */
export class ExploitsApi extends BaseAPI {
    /**
     * API endpoint for re-collecting exploit data.  **NOTE:** Currently for CISA data only, which is very small and collection is fast.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExploitsApi
     */
    public exploitsApiV1CollectUpdate(options?: AxiosRequestConfig) {
        return ExploitsApiFp(this.configuration).exploitsApiV1CollectUpdate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint for getting simple exploits information mapped to impacted CVEs.  The Insights Vulnerability application needs this format.  Format of results: ``` {   \"page_size\": <Number of CVEs on the page>,   \"cves\": {     \"CVE-2222-0001\": [<List of exploits>],     \"CVE-2222-0002\": [<List of exploits>],     ...   }, } ```
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExploitsApi
     */
    public exploitsApiV1CveMapRetrieve(options?: AxiosRequestConfig) {
        return ExploitsApiFp(this.configuration).exploitsApiV1CveMapRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint for getting list of Red Hat relevant CVEs with their EPSS score.
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExploitsApi
     */
    public exploitsApiV1EpssList(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return ExploitsApiFp(this.configuration).exploitsApiV1EpssList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Flaw, affect, and tracker data for Exploits
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExploitsApi
     */
    public exploitsApiV1FlawDataList(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return ExploitsApiFp(this.configuration).exploitsApiV1FlawDataList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export only the data required to generate the exploits report
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExploitsApi
     */
    public exploitsApiV1ReportDataList(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return ExploitsApiFp(this.configuration).exploitsApiV1ReportDataList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint for getting date based report for Incident Response.  Format of results: ``` {   \"cutoff_date\": <Date>,   \"evaluated_cves\": <Number of new CVEs with exploits>,   \"action_required\": [<List of affects requiring action>],   \"no_action\": [<List of CVEs not requiring action with reason>],   \"not_relevant\": [<List of CVEs which are not in the database with reason>], } ```  **NOTE:** No pagination is performed on this endpoint as data is limited by date and is expected           to be fairly small. Also, because data is broken into three categories it is not           exactly obvious how to create pages.
     * @param {string} date Date format: YYYY-MM-DD
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExploitsApi
     */
    public exploitsApiV1ReportDateRetrieve(date: string, options?: AxiosRequestConfig) {
        return ExploitsApiFp(this.configuration).exploitsApiV1ReportDateRetrieve(date, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint for getting a report of all CVEs with exploit and their status for Incident Response.  Format of results: ``` {    \"page_size\": <Number of CVEs on the page>,    \"explanations\": [<List of CVEs with exploit together with current status explanation>], } ```
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExploitsApi
     */
    public exploitsApiV1ReportExplanationsRetrieve(options?: AxiosRequestConfig) {
        return ExploitsApiFp(this.configuration).exploitsApiV1ReportExplanationsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint for getting a report of pending actions for Incident Response.  Format of results: ``` {   \"pending_actions\": [<List of affects requiring action>],   \"pending_actions_count\": <Number of affects requiring action>, } ```  **NOTE:** No pagination is performed on this endpoint as it is expected that the size of           the list of pending actions will be mostly stable. Also, the paging cannot be done on           the query level, as additional analysis of every exploit is required before a decision           to include it in this report is done.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExploitsApi
     */
    public exploitsApiV1ReportPendingRetrieve(options?: AxiosRequestConfig) {
        return ExploitsApiFp(this.configuration).exploitsApiV1ReportPendingRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint for getting basic information about exploits in the database.  **NOTE:** Everyone is allowed to see basic information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExploitsApi
     */
    public exploitsApiV1StatusRetrieve(options?: AxiosRequestConfig) {
        return ExploitsApiFp(this.configuration).exploitsApiV1StatusRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint for getting a list of all supported products.
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExploitsApi
     */
    public exploitsApiV1SupportedProductsList(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return ExploitsApiFp(this.configuration).exploitsApiV1SupportedProductsList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OsidbApi - axios parameter creator
 * @export
 */
export const OsidbApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {AffectPost} affectPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsCreate: async (bugzillaApiKey: string, affectPost: AffectPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bugzillaApiKey' is not null or undefined
            assertParamExists('osidbApiV1AffectsCreate', 'bugzillaApiKey', bugzillaApiKey)
            // verify required parameter 'affectPost' is not null or undefined
            assertParamExists('osidbApiV1AffectsCreate', 'affectPost', affectPost)
            const localVarPath = `/osidb/api/v1/affects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (bugzillaApiKey != null) {
                localVarHeaderParameter['Bugzilla-Api-Key'] = String(bugzillaApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(affectPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affectId 
         * @param {AffectCVSSPost} affectCVSSPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsCvssScoresCreate: async (affectId: string, affectCVSSPost: AffectCVSSPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affectId' is not null or undefined
            assertParamExists('osidbApiV1AffectsCvssScoresCreate', 'affectId', affectId)
            // verify required parameter 'affectCVSSPost' is not null or undefined
            assertParamExists('osidbApiV1AffectsCvssScoresCreate', 'affectCVSSPost', affectCVSSPost)
            const localVarPath = `/osidb/api/v1/affects/{affect_id}/cvss_scores`
                .replace(`{${"affect_id"}}`, encodeURIComponent(String(affectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(affectCVSSPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Destroy the instance and proxy the delete to Bugzilla.
         * @param {string} affectId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsCvssScoresDestroy: async (affectId: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affectId' is not null or undefined
            assertParamExists('osidbApiV1AffectsCvssScoresDestroy', 'affectId', affectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osidbApiV1AffectsCvssScoresDestroy', 'id', id)
            const localVarPath = `/osidb/api/v1/affects/{affect_id}/cvss_scores/{id}`
                .replace(`{${"affect_id"}}`, encodeURIComponent(String(affectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affectId 
         * @param {string} [comment] 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {string} [cvssVersion] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {'NIST' | 'RH'} [issuer] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {number} [score] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {string} [vector] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsCvssScoresList: async (affectId: string, comment?: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, cvssVersion?: string, excludeFields?: Array<string>, includeFields?: Array<string>, issuer?: 'NIST' | 'RH', limit?: number, offset?: number, score?: number, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, vector?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affectId' is not null or undefined
            assertParamExists('osidbApiV1AffectsCvssScoresList', 'affectId', affectId)
            const localVarPath = `/osidb/api/v1/affects/{affect_id}/cvss_scores`
                .replace(`{${"affect_id"}}`, encodeURIComponent(String(affectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (comment !== undefined) {
                localVarQueryParameter['comment'] = comment;
            }

            if (createdDt !== undefined) {
                localVarQueryParameter['created_dt'] = (createdDt as any instanceof Date) ?
                    (createdDt as any).toISOString() :
                    createdDt;
            }

            if (createdDtDate !== undefined) {
                localVarQueryParameter['created_dt__date'] = (createdDtDate as any instanceof Date) ?
                    (createdDtDate as any).toISOString().substr(0,10) :
                    createdDtDate;
            }

            if (createdDtDateGte !== undefined) {
                localVarQueryParameter['created_dt__date__gte'] = (createdDtDateGte as any instanceof Date) ?
                    (createdDtDateGte as any).toISOString().substr(0,10) :
                    createdDtDateGte;
            }

            if (createdDtDateLte !== undefined) {
                localVarQueryParameter['created_dt__date__lte'] = (createdDtDateLte as any instanceof Date) ?
                    (createdDtDateLte as any).toISOString().substr(0,10) :
                    createdDtDateLte;
            }

            if (createdDtGt !== undefined) {
                localVarQueryParameter['created_dt__gt'] = (createdDtGt as any instanceof Date) ?
                    (createdDtGt as any).toISOString() :
                    createdDtGt;
            }

            if (createdDtGte !== undefined) {
                localVarQueryParameter['created_dt__gte'] = (createdDtGte as any instanceof Date) ?
                    (createdDtGte as any).toISOString() :
                    createdDtGte;
            }

            if (createdDtLt !== undefined) {
                localVarQueryParameter['created_dt__lt'] = (createdDtLt as any instanceof Date) ?
                    (createdDtLt as any).toISOString() :
                    createdDtLt;
            }

            if (createdDtLte !== undefined) {
                localVarQueryParameter['created_dt__lte'] = (createdDtLte as any instanceof Date) ?
                    (createdDtLte as any).toISOString() :
                    createdDtLte;
            }

            if (cvssVersion !== undefined) {
                localVarQueryParameter['cvss_version'] = cvssVersion;
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }

            if (issuer !== undefined) {
                localVarQueryParameter['issuer'] = issuer;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (score !== undefined) {
                localVarQueryParameter['score'] = score;
            }

            if (updatedDt !== undefined) {
                localVarQueryParameter['updated_dt'] = (updatedDt as any instanceof Date) ?
                    (updatedDt as any).toISOString() :
                    updatedDt;
            }

            if (updatedDtDate !== undefined) {
                localVarQueryParameter['updated_dt__date'] = (updatedDtDate as any instanceof Date) ?
                    (updatedDtDate as any).toISOString().substr(0,10) :
                    updatedDtDate;
            }

            if (updatedDtDateGte !== undefined) {
                localVarQueryParameter['updated_dt__date__gte'] = (updatedDtDateGte as any instanceof Date) ?
                    (updatedDtDateGte as any).toISOString().substr(0,10) :
                    updatedDtDateGte;
            }

            if (updatedDtDateLte !== undefined) {
                localVarQueryParameter['updated_dt__date__lte'] = (updatedDtDateLte as any instanceof Date) ?
                    (updatedDtDateLte as any).toISOString().substr(0,10) :
                    updatedDtDateLte;
            }

            if (updatedDtGt !== undefined) {
                localVarQueryParameter['updated_dt__gt'] = (updatedDtGt as any instanceof Date) ?
                    (updatedDtGt as any).toISOString() :
                    updatedDtGt;
            }

            if (updatedDtGte !== undefined) {
                localVarQueryParameter['updated_dt__gte'] = (updatedDtGte as any instanceof Date) ?
                    (updatedDtGte as any).toISOString() :
                    updatedDtGte;
            }

            if (updatedDtLt !== undefined) {
                localVarQueryParameter['updated_dt__lt'] = (updatedDtLt as any instanceof Date) ?
                    (updatedDtLt as any).toISOString() :
                    updatedDtLt;
            }

            if (updatedDtLte !== undefined) {
                localVarQueryParameter['updated_dt__lte'] = (updatedDtLte as any instanceof Date) ?
                    (updatedDtLte as any).toISOString() :
                    updatedDtLte;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (vector !== undefined) {
                localVarQueryParameter['vector'] = vector;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affectId 
         * @param {string} id 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsCvssScoresRetrieve: async (affectId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affectId' is not null or undefined
            assertParamExists('osidbApiV1AffectsCvssScoresRetrieve', 'affectId', affectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osidbApiV1AffectsCvssScoresRetrieve', 'id', id)
            const localVarPath = `/osidb/api/v1/affects/{affect_id}/cvss_scores/{id}`
                .replace(`{${"affect_id"}}`, encodeURIComponent(String(affectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affectId 
         * @param {string} id 
         * @param {AffectCVSSPut} affectCVSSPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsCvssScoresUpdate: async (affectId: string, id: string, affectCVSSPut: AffectCVSSPut, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affectId' is not null or undefined
            assertParamExists('osidbApiV1AffectsCvssScoresUpdate', 'affectId', affectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osidbApiV1AffectsCvssScoresUpdate', 'id', id)
            // verify required parameter 'affectCVSSPut' is not null or undefined
            assertParamExists('osidbApiV1AffectsCvssScoresUpdate', 'affectCVSSPut', affectCVSSPut)
            const localVarPath = `/osidb/api/v1/affects/{affect_id}/cvss_scores/{id}`
                .replace(`{${"affect_id"}}`, encodeURIComponent(String(affectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(affectCVSSPut, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Destroy the instance and proxy the delete to Bugzilla
         * @param {string} uuid A UUID string identifying this Affect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsDestroy: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('osidbApiV1AffectsDestroy', 'uuid', uuid)
            const localVarPath = `/osidb/api/v1/affects/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {'' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED'} [affectedness] 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {string} [cvss2] 
         * @param {number} [cvss2Score] 
         * @param {number} [cvss2ScoreGt] 
         * @param {number} [cvss2ScoreGte] 
         * @param {number} [cvss2ScoreLt] 
         * @param {number} [cvss2ScoreLte] 
         * @param {string} [cvss3] 
         * @param {number} [cvss3Score] 
         * @param {number} [cvss3ScoreGt] 
         * @param {number} [cvss3ScoreGte] 
         * @param {number} [cvss3ScoreLt] 
         * @param {number} [cvss3ScoreLte] 
         * @param {string} [cvssScoresComment] 
         * @param {string} [cvssScoresCreatedDt] 
         * @param {string} [cvssScoresCreatedDtDate] 
         * @param {string} [cvssScoresCreatedDtDateGte] 
         * @param {string} [cvssScoresCreatedDtDateLte] 
         * @param {string} [cvssScoresCreatedDtGt] 
         * @param {string} [cvssScoresCreatedDtGte] 
         * @param {string} [cvssScoresCreatedDtLt] 
         * @param {string} [cvssScoresCreatedDtLte] 
         * @param {string} [cvssScoresCvssVersion] 
         * @param {'NIST' | 'RH'} [cvssScoresIssuer] 
         * @param {number} [cvssScoresScore] 
         * @param {string} [cvssScoresUpdatedDt] 
         * @param {string} [cvssScoresUpdatedDtDate] 
         * @param {string} [cvssScoresUpdatedDtDateGte] 
         * @param {string} [cvssScoresUpdatedDtDateLte] 
         * @param {string} [cvssScoresUpdatedDtGt] 
         * @param {string} [cvssScoresUpdatedDtGte] 
         * @param {string} [cvssScoresUpdatedDtLt] 
         * @param {string} [cvssScoresUpdatedDtLte] 
         * @param {string} [cvssScoresUuid] 
         * @param {string} [cvssScoresVector] 
         * @param {boolean} [embargoed] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {string} [flawComponent] 
         * @param {string} [flawCreatedDt] 
         * @param {string} [flawCreatedDtDate] 
         * @param {string} [flawCreatedDtDateGte] 
         * @param {string} [flawCreatedDtDateLte] 
         * @param {string} [flawCreatedDtGt] 
         * @param {string} [flawCreatedDtGte] 
         * @param {string} [flawCreatedDtLt] 
         * @param {string} [flawCreatedDtLte] 
         * @param {string} [flawCveId] 
         * @param {string} [flawCvss2] 
         * @param {number} [flawCvss2Score] 
         * @param {number} [flawCvss2ScoreGt] 
         * @param {number} [flawCvss2ScoreGte] 
         * @param {number} [flawCvss2ScoreLt] 
         * @param {number} [flawCvss2ScoreLte] 
         * @param {string} [flawCvss3] 
         * @param {number} [flawCvss3Score] 
         * @param {number} [flawCvss3ScoreGt] 
         * @param {number} [flawCvss3ScoreGte] 
         * @param {number} [flawCvss3ScoreLt] 
         * @param {number} [flawCvss3ScoreLte] 
         * @param {string} [flawCweId] 
         * @param {boolean} [flawEmbargoed] 
         * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [flawImpact] 
         * @param {boolean} [flawIsMajorIncident] 
         * @param {string} [flawNvdCvss2] 
         * @param {string} [flawNvdCvss3] 
         * @param {string} [flawReportedDt] 
         * @param {string} [flawReportedDtDate] 
         * @param {string} [flawReportedDtDateGte] 
         * @param {string} [flawReportedDtDateLte] 
         * @param {string} [flawReportedDtGt] 
         * @param {string} [flawReportedDtGte] 
         * @param {string} [flawReportedDtLt] 
         * @param {string} [flawReportedDtLte] 
         * @param {'' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF'} [flawSource] 
         * @param {'VULNERABILITY' | 'WEAKNESS'} [flawType] 
         * @param {string} [flawUnembargoDt] 
         * @param {string} [flawUpdatedDt] 
         * @param {string} [flawUpdatedDtDate] 
         * @param {string} [flawUpdatedDtDateGte] 
         * @param {string} [flawUpdatedDtDateLte] 
         * @param {string} [flawUpdatedDtGt] 
         * @param {string} [flawUpdatedDtGte] 
         * @param {string} [flawUpdatedDtLt] 
         * @param {string} [flawUpdatedDtLte] 
         * @param {string} [flawUuid] 
         * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [impact] 
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {Array<'-affectedness' | '-created_dt' | '-cvss2' | '-cvss2_score' | '-cvss3' | '-cvss3_score' | '-cvss_scores__comment' | '-cvss_scores__created_dt' | '-cvss_scores__issuer' | '-cvss_scores__score' | '-cvss_scores__updated_dt' | '-cvss_scores__uuid' | '-cvss_scores__vector' | '-flaw__component' | '-flaw__created_dt' | '-flaw__cve_id' | '-flaw__cvss2' | '-flaw__cvss2_score' | '-flaw__cvss3' | '-flaw__cvss3_score' | '-flaw__cwe_id' | '-flaw__impact' | '-flaw__nvd_cvss2' | '-flaw__nvd_cvss3' | '-flaw__reported_dt' | '-flaw__source' | '-flaw__type' | '-flaw__unembargo_dt' | '-flaw__updated_dt' | '-flaw__uuid' | '-impact' | '-ps_component' | '-ps_module' | '-resolution' | '-trackers__created_dt' | '-trackers__external_system_id' | '-trackers__ps_update_stream' | '-trackers__resolution' | '-trackers__status' | '-trackers__type' | '-trackers__updated_dt' | '-trackers__uuid' | '-type' | '-updated_dt' | '-uuid' | 'affectedness' | 'created_dt' | 'cvss2' | 'cvss2_score' | 'cvss3' | 'cvss3_score' | 'cvss_scores__comment' | 'cvss_scores__created_dt' | 'cvss_scores__issuer' | 'cvss_scores__score' | 'cvss_scores__updated_dt' | 'cvss_scores__uuid' | 'cvss_scores__vector' | 'flaw__component' | 'flaw__created_dt' | 'flaw__cve_id' | 'flaw__cvss2' | 'flaw__cvss2_score' | 'flaw__cvss3' | 'flaw__cvss3_score' | 'flaw__cwe_id' | 'flaw__impact' | 'flaw__nvd_cvss2' | 'flaw__nvd_cvss3' | 'flaw__reported_dt' | 'flaw__source' | 'flaw__type' | 'flaw__unembargo_dt' | 'flaw__updated_dt' | 'flaw__uuid' | 'impact' | 'ps_component' | 'ps_module' | 'resolution' | 'trackers__created_dt' | 'trackers__external_system_id' | 'trackers__ps_update_stream' | 'trackers__resolution' | 'trackers__status' | 'trackers__type' | 'trackers__updated_dt' | 'trackers__uuid' | 'type' | 'updated_dt' | 'uuid'>} [order] Ordering
         * @param {string} [psComponent] 
         * @param {string} [psModule] 
         * @param {'' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT'} [resolution] 
         * @param {string} [trackersCreatedDt] 
         * @param {string} [trackersCreatedDtDate] 
         * @param {string} [trackersCreatedDtDateGte] 
         * @param {string} [trackersCreatedDtDateLte] 
         * @param {string} [trackersCreatedDtGt] 
         * @param {string} [trackersCreatedDtGte] 
         * @param {string} [trackersCreatedDtLt] 
         * @param {string} [trackersCreatedDtLte] 
         * @param {boolean} [trackersEmbargoed] 
         * @param {string} [trackersExternalSystemId] 
         * @param {string} [trackersPsUpdateStream] 
         * @param {string} [trackersResolution] 
         * @param {string} [trackersStatus] 
         * @param {'BUGZILLA' | 'JIRA'} [trackersType] 
         * @param {string} [trackersUpdatedDt] 
         * @param {string} [trackersUpdatedDtDate] 
         * @param {string} [trackersUpdatedDtDateGte] 
         * @param {string} [trackersUpdatedDtDateLte] 
         * @param {string} [trackersUpdatedDtGt] 
         * @param {string} [trackersUpdatedDtGte] 
         * @param {string} [trackersUpdatedDtLt] 
         * @param {string} [trackersUpdatedDtLte] 
         * @param {string} [trackersUuid] 
         * @param {'DEFAULT'} [type] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsList: async (affectedness?: '' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED', createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, cvss2?: string, cvss2Score?: number, cvss2ScoreGt?: number, cvss2ScoreGte?: number, cvss2ScoreLt?: number, cvss2ScoreLte?: number, cvss3?: string, cvss3Score?: number, cvss3ScoreGt?: number, cvss3ScoreGte?: number, cvss3ScoreLt?: number, cvss3ScoreLte?: number, cvssScoresComment?: string, cvssScoresCreatedDt?: string, cvssScoresCreatedDtDate?: string, cvssScoresCreatedDtDateGte?: string, cvssScoresCreatedDtDateLte?: string, cvssScoresCreatedDtGt?: string, cvssScoresCreatedDtGte?: string, cvssScoresCreatedDtLt?: string, cvssScoresCreatedDtLte?: string, cvssScoresCvssVersion?: string, cvssScoresIssuer?: 'NIST' | 'RH', cvssScoresScore?: number, cvssScoresUpdatedDt?: string, cvssScoresUpdatedDtDate?: string, cvssScoresUpdatedDtDateGte?: string, cvssScoresUpdatedDtDateLte?: string, cvssScoresUpdatedDtGt?: string, cvssScoresUpdatedDtGte?: string, cvssScoresUpdatedDtLt?: string, cvssScoresUpdatedDtLte?: string, cvssScoresUuid?: string, cvssScoresVector?: string, embargoed?: boolean, excludeFields?: Array<string>, flawComponent?: string, flawCreatedDt?: string, flawCreatedDtDate?: string, flawCreatedDtDateGte?: string, flawCreatedDtDateLte?: string, flawCreatedDtGt?: string, flawCreatedDtGte?: string, flawCreatedDtLt?: string, flawCreatedDtLte?: string, flawCveId?: string, flawCvss2?: string, flawCvss2Score?: number, flawCvss2ScoreGt?: number, flawCvss2ScoreGte?: number, flawCvss2ScoreLt?: number, flawCvss2ScoreLte?: number, flawCvss3?: string, flawCvss3Score?: number, flawCvss3ScoreGt?: number, flawCvss3ScoreGte?: number, flawCvss3ScoreLt?: number, flawCvss3ScoreLte?: number, flawCweId?: string, flawEmbargoed?: boolean, flawImpact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', flawIsMajorIncident?: boolean, flawNvdCvss2?: string, flawNvdCvss3?: string, flawReportedDt?: string, flawReportedDtDate?: string, flawReportedDtDateGte?: string, flawReportedDtDateLte?: string, flawReportedDtGt?: string, flawReportedDtGte?: string, flawReportedDtLt?: string, flawReportedDtLte?: string, flawSource?: '' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF', flawType?: 'VULNERABILITY' | 'WEAKNESS', flawUnembargoDt?: string, flawUpdatedDt?: string, flawUpdatedDtDate?: string, flawUpdatedDtDateGte?: string, flawUpdatedDtDateLte?: string, flawUpdatedDtGt?: string, flawUpdatedDtGte?: string, flawUpdatedDtLt?: string, flawUpdatedDtLte?: string, flawUuid?: string, impact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', includeFields?: Array<string>, includeMetaAttr?: Array<string>, limit?: number, offset?: number, order?: Array<'-affectedness' | '-created_dt' | '-cvss2' | '-cvss2_score' | '-cvss3' | '-cvss3_score' | '-cvss_scores__comment' | '-cvss_scores__created_dt' | '-cvss_scores__issuer' | '-cvss_scores__score' | '-cvss_scores__updated_dt' | '-cvss_scores__uuid' | '-cvss_scores__vector' | '-flaw__component' | '-flaw__created_dt' | '-flaw__cve_id' | '-flaw__cvss2' | '-flaw__cvss2_score' | '-flaw__cvss3' | '-flaw__cvss3_score' | '-flaw__cwe_id' | '-flaw__impact' | '-flaw__nvd_cvss2' | '-flaw__nvd_cvss3' | '-flaw__reported_dt' | '-flaw__source' | '-flaw__type' | '-flaw__unembargo_dt' | '-flaw__updated_dt' | '-flaw__uuid' | '-impact' | '-ps_component' | '-ps_module' | '-resolution' | '-trackers__created_dt' | '-trackers__external_system_id' | '-trackers__ps_update_stream' | '-trackers__resolution' | '-trackers__status' | '-trackers__type' | '-trackers__updated_dt' | '-trackers__uuid' | '-type' | '-updated_dt' | '-uuid' | 'affectedness' | 'created_dt' | 'cvss2' | 'cvss2_score' | 'cvss3' | 'cvss3_score' | 'cvss_scores__comment' | 'cvss_scores__created_dt' | 'cvss_scores__issuer' | 'cvss_scores__score' | 'cvss_scores__updated_dt' | 'cvss_scores__uuid' | 'cvss_scores__vector' | 'flaw__component' | 'flaw__created_dt' | 'flaw__cve_id' | 'flaw__cvss2' | 'flaw__cvss2_score' | 'flaw__cvss3' | 'flaw__cvss3_score' | 'flaw__cwe_id' | 'flaw__impact' | 'flaw__nvd_cvss2' | 'flaw__nvd_cvss3' | 'flaw__reported_dt' | 'flaw__source' | 'flaw__type' | 'flaw__unembargo_dt' | 'flaw__updated_dt' | 'flaw__uuid' | 'impact' | 'ps_component' | 'ps_module' | 'resolution' | 'trackers__created_dt' | 'trackers__external_system_id' | 'trackers__ps_update_stream' | 'trackers__resolution' | 'trackers__status' | 'trackers__type' | 'trackers__updated_dt' | 'trackers__uuid' | 'type' | 'updated_dt' | 'uuid'>, psComponent?: string, psModule?: string, resolution?: '' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT', trackersCreatedDt?: string, trackersCreatedDtDate?: string, trackersCreatedDtDateGte?: string, trackersCreatedDtDateLte?: string, trackersCreatedDtGt?: string, trackersCreatedDtGte?: string, trackersCreatedDtLt?: string, trackersCreatedDtLte?: string, trackersEmbargoed?: boolean, trackersExternalSystemId?: string, trackersPsUpdateStream?: string, trackersResolution?: string, trackersStatus?: string, trackersType?: 'BUGZILLA' | 'JIRA', trackersUpdatedDt?: string, trackersUpdatedDtDate?: string, trackersUpdatedDtDateGte?: string, trackersUpdatedDtDateLte?: string, trackersUpdatedDtGt?: string, trackersUpdatedDtGte?: string, trackersUpdatedDtLt?: string, trackersUpdatedDtLte?: string, trackersUuid?: string, type?: 'DEFAULT', updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/osidb/api/v1/affects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (affectedness !== undefined) {
                localVarQueryParameter['affectedness'] = affectedness;
            }

            if (createdDt !== undefined) {
                localVarQueryParameter['created_dt'] = (createdDt as any instanceof Date) ?
                    (createdDt as any).toISOString() :
                    createdDt;
            }

            if (createdDtDate !== undefined) {
                localVarQueryParameter['created_dt__date'] = (createdDtDate as any instanceof Date) ?
                    (createdDtDate as any).toISOString().substr(0,10) :
                    createdDtDate;
            }

            if (createdDtDateGte !== undefined) {
                localVarQueryParameter['created_dt__date__gte'] = (createdDtDateGte as any instanceof Date) ?
                    (createdDtDateGte as any).toISOString().substr(0,10) :
                    createdDtDateGte;
            }

            if (createdDtDateLte !== undefined) {
                localVarQueryParameter['created_dt__date__lte'] = (createdDtDateLte as any instanceof Date) ?
                    (createdDtDateLte as any).toISOString().substr(0,10) :
                    createdDtDateLte;
            }

            if (createdDtGt !== undefined) {
                localVarQueryParameter['created_dt__gt'] = (createdDtGt as any instanceof Date) ?
                    (createdDtGt as any).toISOString() :
                    createdDtGt;
            }

            if (createdDtGte !== undefined) {
                localVarQueryParameter['created_dt__gte'] = (createdDtGte as any instanceof Date) ?
                    (createdDtGte as any).toISOString() :
                    createdDtGte;
            }

            if (createdDtLt !== undefined) {
                localVarQueryParameter['created_dt__lt'] = (createdDtLt as any instanceof Date) ?
                    (createdDtLt as any).toISOString() :
                    createdDtLt;
            }

            if (createdDtLte !== undefined) {
                localVarQueryParameter['created_dt__lte'] = (createdDtLte as any instanceof Date) ?
                    (createdDtLte as any).toISOString() :
                    createdDtLte;
            }

            if (cvss2 !== undefined) {
                localVarQueryParameter['cvss2'] = cvss2;
            }

            if (cvss2Score !== undefined) {
                localVarQueryParameter['cvss2_score'] = cvss2Score;
            }

            if (cvss2ScoreGt !== undefined) {
                localVarQueryParameter['cvss2_score__gt'] = cvss2ScoreGt;
            }

            if (cvss2ScoreGte !== undefined) {
                localVarQueryParameter['cvss2_score__gte'] = cvss2ScoreGte;
            }

            if (cvss2ScoreLt !== undefined) {
                localVarQueryParameter['cvss2_score__lt'] = cvss2ScoreLt;
            }

            if (cvss2ScoreLte !== undefined) {
                localVarQueryParameter['cvss2_score__lte'] = cvss2ScoreLte;
            }

            if (cvss3 !== undefined) {
                localVarQueryParameter['cvss3'] = cvss3;
            }

            if (cvss3Score !== undefined) {
                localVarQueryParameter['cvss3_score'] = cvss3Score;
            }

            if (cvss3ScoreGt !== undefined) {
                localVarQueryParameter['cvss3_score__gt'] = cvss3ScoreGt;
            }

            if (cvss3ScoreGte !== undefined) {
                localVarQueryParameter['cvss3_score__gte'] = cvss3ScoreGte;
            }

            if (cvss3ScoreLt !== undefined) {
                localVarQueryParameter['cvss3_score__lt'] = cvss3ScoreLt;
            }

            if (cvss3ScoreLte !== undefined) {
                localVarQueryParameter['cvss3_score__lte'] = cvss3ScoreLte;
            }

            if (cvssScoresComment !== undefined) {
                localVarQueryParameter['cvss_scores__comment'] = cvssScoresComment;
            }

            if (cvssScoresCreatedDt !== undefined) {
                localVarQueryParameter['cvss_scores__created_dt'] = (cvssScoresCreatedDt as any instanceof Date) ?
                    (cvssScoresCreatedDt as any).toISOString() :
                    cvssScoresCreatedDt;
            }

            if (cvssScoresCreatedDtDate !== undefined) {
                localVarQueryParameter['cvss_scores__created_dt__date'] = (cvssScoresCreatedDtDate as any instanceof Date) ?
                    (cvssScoresCreatedDtDate as any).toISOString().substr(0,10) :
                    cvssScoresCreatedDtDate;
            }

            if (cvssScoresCreatedDtDateGte !== undefined) {
                localVarQueryParameter['cvss_scores__created_dt__date__gte'] = (cvssScoresCreatedDtDateGte as any instanceof Date) ?
                    (cvssScoresCreatedDtDateGte as any).toISOString().substr(0,10) :
                    cvssScoresCreatedDtDateGte;
            }

            if (cvssScoresCreatedDtDateLte !== undefined) {
                localVarQueryParameter['cvss_scores__created_dt__date__lte'] = (cvssScoresCreatedDtDateLte as any instanceof Date) ?
                    (cvssScoresCreatedDtDateLte as any).toISOString().substr(0,10) :
                    cvssScoresCreatedDtDateLte;
            }

            if (cvssScoresCreatedDtGt !== undefined) {
                localVarQueryParameter['cvss_scores__created_dt__gt'] = (cvssScoresCreatedDtGt as any instanceof Date) ?
                    (cvssScoresCreatedDtGt as any).toISOString() :
                    cvssScoresCreatedDtGt;
            }

            if (cvssScoresCreatedDtGte !== undefined) {
                localVarQueryParameter['cvss_scores__created_dt__gte'] = (cvssScoresCreatedDtGte as any instanceof Date) ?
                    (cvssScoresCreatedDtGte as any).toISOString() :
                    cvssScoresCreatedDtGte;
            }

            if (cvssScoresCreatedDtLt !== undefined) {
                localVarQueryParameter['cvss_scores__created_dt__lt'] = (cvssScoresCreatedDtLt as any instanceof Date) ?
                    (cvssScoresCreatedDtLt as any).toISOString() :
                    cvssScoresCreatedDtLt;
            }

            if (cvssScoresCreatedDtLte !== undefined) {
                localVarQueryParameter['cvss_scores__created_dt__lte'] = (cvssScoresCreatedDtLte as any instanceof Date) ?
                    (cvssScoresCreatedDtLte as any).toISOString() :
                    cvssScoresCreatedDtLte;
            }

            if (cvssScoresCvssVersion !== undefined) {
                localVarQueryParameter['cvss_scores__cvss_version'] = cvssScoresCvssVersion;
            }

            if (cvssScoresIssuer !== undefined) {
                localVarQueryParameter['cvss_scores__issuer'] = cvssScoresIssuer;
            }

            if (cvssScoresScore !== undefined) {
                localVarQueryParameter['cvss_scores__score'] = cvssScoresScore;
            }

            if (cvssScoresUpdatedDt !== undefined) {
                localVarQueryParameter['cvss_scores__updated_dt'] = (cvssScoresUpdatedDt as any instanceof Date) ?
                    (cvssScoresUpdatedDt as any).toISOString() :
                    cvssScoresUpdatedDt;
            }

            if (cvssScoresUpdatedDtDate !== undefined) {
                localVarQueryParameter['cvss_scores__updated_dt__date'] = (cvssScoresUpdatedDtDate as any instanceof Date) ?
                    (cvssScoresUpdatedDtDate as any).toISOString().substr(0,10) :
                    cvssScoresUpdatedDtDate;
            }

            if (cvssScoresUpdatedDtDateGte !== undefined) {
                localVarQueryParameter['cvss_scores__updated_dt__date__gte'] = (cvssScoresUpdatedDtDateGte as any instanceof Date) ?
                    (cvssScoresUpdatedDtDateGte as any).toISOString().substr(0,10) :
                    cvssScoresUpdatedDtDateGte;
            }

            if (cvssScoresUpdatedDtDateLte !== undefined) {
                localVarQueryParameter['cvss_scores__updated_dt__date__lte'] = (cvssScoresUpdatedDtDateLte as any instanceof Date) ?
                    (cvssScoresUpdatedDtDateLte as any).toISOString().substr(0,10) :
                    cvssScoresUpdatedDtDateLte;
            }

            if (cvssScoresUpdatedDtGt !== undefined) {
                localVarQueryParameter['cvss_scores__updated_dt__gt'] = (cvssScoresUpdatedDtGt as any instanceof Date) ?
                    (cvssScoresUpdatedDtGt as any).toISOString() :
                    cvssScoresUpdatedDtGt;
            }

            if (cvssScoresUpdatedDtGte !== undefined) {
                localVarQueryParameter['cvss_scores__updated_dt__gte'] = (cvssScoresUpdatedDtGte as any instanceof Date) ?
                    (cvssScoresUpdatedDtGte as any).toISOString() :
                    cvssScoresUpdatedDtGte;
            }

            if (cvssScoresUpdatedDtLt !== undefined) {
                localVarQueryParameter['cvss_scores__updated_dt__lt'] = (cvssScoresUpdatedDtLt as any instanceof Date) ?
                    (cvssScoresUpdatedDtLt as any).toISOString() :
                    cvssScoresUpdatedDtLt;
            }

            if (cvssScoresUpdatedDtLte !== undefined) {
                localVarQueryParameter['cvss_scores__updated_dt__lte'] = (cvssScoresUpdatedDtLte as any instanceof Date) ?
                    (cvssScoresUpdatedDtLte as any).toISOString() :
                    cvssScoresUpdatedDtLte;
            }

            if (cvssScoresUuid !== undefined) {
                localVarQueryParameter['cvss_scores__uuid'] = cvssScoresUuid;
            }

            if (cvssScoresVector !== undefined) {
                localVarQueryParameter['cvss_scores__vector'] = cvssScoresVector;
            }

            if (embargoed !== undefined) {
                localVarQueryParameter['embargoed'] = embargoed;
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (flawComponent !== undefined) {
                localVarQueryParameter['flaw__component'] = flawComponent;
            }

            if (flawCreatedDt !== undefined) {
                localVarQueryParameter['flaw__created_dt'] = (flawCreatedDt as any instanceof Date) ?
                    (flawCreatedDt as any).toISOString() :
                    flawCreatedDt;
            }

            if (flawCreatedDtDate !== undefined) {
                localVarQueryParameter['flaw__created_dt__date'] = (flawCreatedDtDate as any instanceof Date) ?
                    (flawCreatedDtDate as any).toISOString().substr(0,10) :
                    flawCreatedDtDate;
            }

            if (flawCreatedDtDateGte !== undefined) {
                localVarQueryParameter['flaw__created_dt__date__gte'] = (flawCreatedDtDateGte as any instanceof Date) ?
                    (flawCreatedDtDateGte as any).toISOString().substr(0,10) :
                    flawCreatedDtDateGte;
            }

            if (flawCreatedDtDateLte !== undefined) {
                localVarQueryParameter['flaw__created_dt__date__lte'] = (flawCreatedDtDateLte as any instanceof Date) ?
                    (flawCreatedDtDateLte as any).toISOString().substr(0,10) :
                    flawCreatedDtDateLte;
            }

            if (flawCreatedDtGt !== undefined) {
                localVarQueryParameter['flaw__created_dt__gt'] = (flawCreatedDtGt as any instanceof Date) ?
                    (flawCreatedDtGt as any).toISOString() :
                    flawCreatedDtGt;
            }

            if (flawCreatedDtGte !== undefined) {
                localVarQueryParameter['flaw__created_dt__gte'] = (flawCreatedDtGte as any instanceof Date) ?
                    (flawCreatedDtGte as any).toISOString() :
                    flawCreatedDtGte;
            }

            if (flawCreatedDtLt !== undefined) {
                localVarQueryParameter['flaw__created_dt__lt'] = (flawCreatedDtLt as any instanceof Date) ?
                    (flawCreatedDtLt as any).toISOString() :
                    flawCreatedDtLt;
            }

            if (flawCreatedDtLte !== undefined) {
                localVarQueryParameter['flaw__created_dt__lte'] = (flawCreatedDtLte as any instanceof Date) ?
                    (flawCreatedDtLte as any).toISOString() :
                    flawCreatedDtLte;
            }

            if (flawCveId !== undefined) {
                localVarQueryParameter['flaw__cve_id'] = flawCveId;
            }

            if (flawCvss2 !== undefined) {
                localVarQueryParameter['flaw__cvss2'] = flawCvss2;
            }

            if (flawCvss2Score !== undefined) {
                localVarQueryParameter['flaw__cvss2_score'] = flawCvss2Score;
            }

            if (flawCvss2ScoreGt !== undefined) {
                localVarQueryParameter['flaw__cvss2_score__gt'] = flawCvss2ScoreGt;
            }

            if (flawCvss2ScoreGte !== undefined) {
                localVarQueryParameter['flaw__cvss2_score__gte'] = flawCvss2ScoreGte;
            }

            if (flawCvss2ScoreLt !== undefined) {
                localVarQueryParameter['flaw__cvss2_score__lt'] = flawCvss2ScoreLt;
            }

            if (flawCvss2ScoreLte !== undefined) {
                localVarQueryParameter['flaw__cvss2_score__lte'] = flawCvss2ScoreLte;
            }

            if (flawCvss3 !== undefined) {
                localVarQueryParameter['flaw__cvss3'] = flawCvss3;
            }

            if (flawCvss3Score !== undefined) {
                localVarQueryParameter['flaw__cvss3_score'] = flawCvss3Score;
            }

            if (flawCvss3ScoreGt !== undefined) {
                localVarQueryParameter['flaw__cvss3_score__gt'] = flawCvss3ScoreGt;
            }

            if (flawCvss3ScoreGte !== undefined) {
                localVarQueryParameter['flaw__cvss3_score__gte'] = flawCvss3ScoreGte;
            }

            if (flawCvss3ScoreLt !== undefined) {
                localVarQueryParameter['flaw__cvss3_score__lt'] = flawCvss3ScoreLt;
            }

            if (flawCvss3ScoreLte !== undefined) {
                localVarQueryParameter['flaw__cvss3_score__lte'] = flawCvss3ScoreLte;
            }

            if (flawCweId !== undefined) {
                localVarQueryParameter['flaw__cwe_id'] = flawCweId;
            }

            if (flawEmbargoed !== undefined) {
                localVarQueryParameter['flaw__embargoed'] = flawEmbargoed;
            }

            if (flawImpact !== undefined) {
                localVarQueryParameter['flaw__impact'] = flawImpact;
            }

            if (flawIsMajorIncident !== undefined) {
                localVarQueryParameter['flaw__is_major_incident'] = flawIsMajorIncident;
            }

            if (flawNvdCvss2 !== undefined) {
                localVarQueryParameter['flaw__nvd_cvss2'] = flawNvdCvss2;
            }

            if (flawNvdCvss3 !== undefined) {
                localVarQueryParameter['flaw__nvd_cvss3'] = flawNvdCvss3;
            }

            if (flawReportedDt !== undefined) {
                localVarQueryParameter['flaw__reported_dt'] = (flawReportedDt as any instanceof Date) ?
                    (flawReportedDt as any).toISOString() :
                    flawReportedDt;
            }

            if (flawReportedDtDate !== undefined) {
                localVarQueryParameter['flaw__reported_dt__date'] = (flawReportedDtDate as any instanceof Date) ?
                    (flawReportedDtDate as any).toISOString().substr(0,10) :
                    flawReportedDtDate;
            }

            if (flawReportedDtDateGte !== undefined) {
                localVarQueryParameter['flaw__reported_dt__date__gte'] = (flawReportedDtDateGte as any instanceof Date) ?
                    (flawReportedDtDateGte as any).toISOString().substr(0,10) :
                    flawReportedDtDateGte;
            }

            if (flawReportedDtDateLte !== undefined) {
                localVarQueryParameter['flaw__reported_dt__date__lte'] = (flawReportedDtDateLte as any instanceof Date) ?
                    (flawReportedDtDateLte as any).toISOString().substr(0,10) :
                    flawReportedDtDateLte;
            }

            if (flawReportedDtGt !== undefined) {
                localVarQueryParameter['flaw__reported_dt__gt'] = (flawReportedDtGt as any instanceof Date) ?
                    (flawReportedDtGt as any).toISOString() :
                    flawReportedDtGt;
            }

            if (flawReportedDtGte !== undefined) {
                localVarQueryParameter['flaw__reported_dt__gte'] = (flawReportedDtGte as any instanceof Date) ?
                    (flawReportedDtGte as any).toISOString() :
                    flawReportedDtGte;
            }

            if (flawReportedDtLt !== undefined) {
                localVarQueryParameter['flaw__reported_dt__lt'] = (flawReportedDtLt as any instanceof Date) ?
                    (flawReportedDtLt as any).toISOString() :
                    flawReportedDtLt;
            }

            if (flawReportedDtLte !== undefined) {
                localVarQueryParameter['flaw__reported_dt__lte'] = (flawReportedDtLte as any instanceof Date) ?
                    (flawReportedDtLte as any).toISOString() :
                    flawReportedDtLte;
            }

            if (flawSource !== undefined) {
                localVarQueryParameter['flaw__source'] = flawSource;
            }

            if (flawType !== undefined) {
                localVarQueryParameter['flaw__type'] = flawType;
            }

            if (flawUnembargoDt !== undefined) {
                localVarQueryParameter['flaw__unembargo_dt'] = (flawUnembargoDt as any instanceof Date) ?
                    (flawUnembargoDt as any).toISOString() :
                    flawUnembargoDt;
            }

            if (flawUpdatedDt !== undefined) {
                localVarQueryParameter['flaw__updated_dt'] = (flawUpdatedDt as any instanceof Date) ?
                    (flawUpdatedDt as any).toISOString() :
                    flawUpdatedDt;
            }

            if (flawUpdatedDtDate !== undefined) {
                localVarQueryParameter['flaw__updated_dt__date'] = (flawUpdatedDtDate as any instanceof Date) ?
                    (flawUpdatedDtDate as any).toISOString().substr(0,10) :
                    flawUpdatedDtDate;
            }

            if (flawUpdatedDtDateGte !== undefined) {
                localVarQueryParameter['flaw__updated_dt__date__gte'] = (flawUpdatedDtDateGte as any instanceof Date) ?
                    (flawUpdatedDtDateGte as any).toISOString().substr(0,10) :
                    flawUpdatedDtDateGte;
            }

            if (flawUpdatedDtDateLte !== undefined) {
                localVarQueryParameter['flaw__updated_dt__date__lte'] = (flawUpdatedDtDateLte as any instanceof Date) ?
                    (flawUpdatedDtDateLte as any).toISOString().substr(0,10) :
                    flawUpdatedDtDateLte;
            }

            if (flawUpdatedDtGt !== undefined) {
                localVarQueryParameter['flaw__updated_dt__gt'] = (flawUpdatedDtGt as any instanceof Date) ?
                    (flawUpdatedDtGt as any).toISOString() :
                    flawUpdatedDtGt;
            }

            if (flawUpdatedDtGte !== undefined) {
                localVarQueryParameter['flaw__updated_dt__gte'] = (flawUpdatedDtGte as any instanceof Date) ?
                    (flawUpdatedDtGte as any).toISOString() :
                    flawUpdatedDtGte;
            }

            if (flawUpdatedDtLt !== undefined) {
                localVarQueryParameter['flaw__updated_dt__lt'] = (flawUpdatedDtLt as any instanceof Date) ?
                    (flawUpdatedDtLt as any).toISOString() :
                    flawUpdatedDtLt;
            }

            if (flawUpdatedDtLte !== undefined) {
                localVarQueryParameter['flaw__updated_dt__lte'] = (flawUpdatedDtLte as any instanceof Date) ?
                    (flawUpdatedDtLte as any).toISOString() :
                    flawUpdatedDtLte;
            }

            if (flawUuid !== undefined) {
                localVarQueryParameter['flaw__uuid'] = flawUuid;
            }

            if (impact !== undefined) {
                localVarQueryParameter['impact'] = impact;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }

            if (includeMetaAttr) {
                localVarQueryParameter['include_meta_attr'] = includeMetaAttr;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (order) {
                localVarQueryParameter['order'] = order.join(COLLECTION_FORMATS.csv);
            }

            if (psComponent !== undefined) {
                localVarQueryParameter['ps_component'] = psComponent;
            }

            if (psModule !== undefined) {
                localVarQueryParameter['ps_module'] = psModule;
            }

            if (resolution !== undefined) {
                localVarQueryParameter['resolution'] = resolution;
            }

            if (trackersCreatedDt !== undefined) {
                localVarQueryParameter['trackers__created_dt'] = (trackersCreatedDt as any instanceof Date) ?
                    (trackersCreatedDt as any).toISOString() :
                    trackersCreatedDt;
            }

            if (trackersCreatedDtDate !== undefined) {
                localVarQueryParameter['trackers__created_dt__date'] = (trackersCreatedDtDate as any instanceof Date) ?
                    (trackersCreatedDtDate as any).toISOString().substr(0,10) :
                    trackersCreatedDtDate;
            }

            if (trackersCreatedDtDateGte !== undefined) {
                localVarQueryParameter['trackers__created_dt__date__gte'] = (trackersCreatedDtDateGte as any instanceof Date) ?
                    (trackersCreatedDtDateGte as any).toISOString().substr(0,10) :
                    trackersCreatedDtDateGte;
            }

            if (trackersCreatedDtDateLte !== undefined) {
                localVarQueryParameter['trackers__created_dt__date__lte'] = (trackersCreatedDtDateLte as any instanceof Date) ?
                    (trackersCreatedDtDateLte as any).toISOString().substr(0,10) :
                    trackersCreatedDtDateLte;
            }

            if (trackersCreatedDtGt !== undefined) {
                localVarQueryParameter['trackers__created_dt__gt'] = (trackersCreatedDtGt as any instanceof Date) ?
                    (trackersCreatedDtGt as any).toISOString() :
                    trackersCreatedDtGt;
            }

            if (trackersCreatedDtGte !== undefined) {
                localVarQueryParameter['trackers__created_dt__gte'] = (trackersCreatedDtGte as any instanceof Date) ?
                    (trackersCreatedDtGte as any).toISOString() :
                    trackersCreatedDtGte;
            }

            if (trackersCreatedDtLt !== undefined) {
                localVarQueryParameter['trackers__created_dt__lt'] = (trackersCreatedDtLt as any instanceof Date) ?
                    (trackersCreatedDtLt as any).toISOString() :
                    trackersCreatedDtLt;
            }

            if (trackersCreatedDtLte !== undefined) {
                localVarQueryParameter['trackers__created_dt__lte'] = (trackersCreatedDtLte as any instanceof Date) ?
                    (trackersCreatedDtLte as any).toISOString() :
                    trackersCreatedDtLte;
            }

            if (trackersEmbargoed !== undefined) {
                localVarQueryParameter['trackers__embargoed'] = trackersEmbargoed;
            }

            if (trackersExternalSystemId !== undefined) {
                localVarQueryParameter['trackers__external_system_id'] = trackersExternalSystemId;
            }

            if (trackersPsUpdateStream !== undefined) {
                localVarQueryParameter['trackers__ps_update_stream'] = trackersPsUpdateStream;
            }

            if (trackersResolution !== undefined) {
                localVarQueryParameter['trackers__resolution'] = trackersResolution;
            }

            if (trackersStatus !== undefined) {
                localVarQueryParameter['trackers__status'] = trackersStatus;
            }

            if (trackersType !== undefined) {
                localVarQueryParameter['trackers__type'] = trackersType;
            }

            if (trackersUpdatedDt !== undefined) {
                localVarQueryParameter['trackers__updated_dt'] = (trackersUpdatedDt as any instanceof Date) ?
                    (trackersUpdatedDt as any).toISOString() :
                    trackersUpdatedDt;
            }

            if (trackersUpdatedDtDate !== undefined) {
                localVarQueryParameter['trackers__updated_dt__date'] = (trackersUpdatedDtDate as any instanceof Date) ?
                    (trackersUpdatedDtDate as any).toISOString().substr(0,10) :
                    trackersUpdatedDtDate;
            }

            if (trackersUpdatedDtDateGte !== undefined) {
                localVarQueryParameter['trackers__updated_dt__date__gte'] = (trackersUpdatedDtDateGte as any instanceof Date) ?
                    (trackersUpdatedDtDateGte as any).toISOString().substr(0,10) :
                    trackersUpdatedDtDateGte;
            }

            if (trackersUpdatedDtDateLte !== undefined) {
                localVarQueryParameter['trackers__updated_dt__date__lte'] = (trackersUpdatedDtDateLte as any instanceof Date) ?
                    (trackersUpdatedDtDateLte as any).toISOString().substr(0,10) :
                    trackersUpdatedDtDateLte;
            }

            if (trackersUpdatedDtGt !== undefined) {
                localVarQueryParameter['trackers__updated_dt__gt'] = (trackersUpdatedDtGt as any instanceof Date) ?
                    (trackersUpdatedDtGt as any).toISOString() :
                    trackersUpdatedDtGt;
            }

            if (trackersUpdatedDtGte !== undefined) {
                localVarQueryParameter['trackers__updated_dt__gte'] = (trackersUpdatedDtGte as any instanceof Date) ?
                    (trackersUpdatedDtGte as any).toISOString() :
                    trackersUpdatedDtGte;
            }

            if (trackersUpdatedDtLt !== undefined) {
                localVarQueryParameter['trackers__updated_dt__lt'] = (trackersUpdatedDtLt as any instanceof Date) ?
                    (trackersUpdatedDtLt as any).toISOString() :
                    trackersUpdatedDtLt;
            }

            if (trackersUpdatedDtLte !== undefined) {
                localVarQueryParameter['trackers__updated_dt__lte'] = (trackersUpdatedDtLte as any instanceof Date) ?
                    (trackersUpdatedDtLte as any).toISOString() :
                    trackersUpdatedDtLte;
            }

            if (trackersUuid !== undefined) {
                localVarQueryParameter['trackers__uuid'] = trackersUuid;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (updatedDt !== undefined) {
                localVarQueryParameter['updated_dt'] = (updatedDt as any instanceof Date) ?
                    (updatedDt as any).toISOString() :
                    updatedDt;
            }

            if (updatedDtDate !== undefined) {
                localVarQueryParameter['updated_dt__date'] = (updatedDtDate as any instanceof Date) ?
                    (updatedDtDate as any).toISOString().substr(0,10) :
                    updatedDtDate;
            }

            if (updatedDtDateGte !== undefined) {
                localVarQueryParameter['updated_dt__date__gte'] = (updatedDtDateGte as any instanceof Date) ?
                    (updatedDtDateGte as any).toISOString().substr(0,10) :
                    updatedDtDateGte;
            }

            if (updatedDtDateLte !== undefined) {
                localVarQueryParameter['updated_dt__date__lte'] = (updatedDtDateLte as any instanceof Date) ?
                    (updatedDtDateLte as any).toISOString().substr(0,10) :
                    updatedDtDateLte;
            }

            if (updatedDtGt !== undefined) {
                localVarQueryParameter['updated_dt__gt'] = (updatedDtGt as any instanceof Date) ?
                    (updatedDtGt as any).toISOString() :
                    updatedDtGt;
            }

            if (updatedDtGte !== undefined) {
                localVarQueryParameter['updated_dt__gte'] = (updatedDtGte as any instanceof Date) ?
                    (updatedDtGte as any).toISOString() :
                    updatedDtGte;
            }

            if (updatedDtLt !== undefined) {
                localVarQueryParameter['updated_dt__lt'] = (updatedDtLt as any instanceof Date) ?
                    (updatedDtLt as any).toISOString() :
                    updatedDtLt;
            }

            if (updatedDtLte !== undefined) {
                localVarQueryParameter['updated_dt__lte'] = (updatedDtLte as any instanceof Date) ?
                    (updatedDtLte as any).toISOString() :
                    updatedDtLte;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid A UUID string identifying this Affect.
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsRetrieve: async (uuid: string, excludeFields?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('osidbApiV1AffectsRetrieve', 'uuid', uuid)
            const localVarPath = `/osidb/api/v1/affects/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }

            if (includeMetaAttr) {
                localVarQueryParameter['include_meta_attr'] = includeMetaAttr;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} uuid A UUID string identifying this Affect.
         * @param {Affect} affect 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsUpdate: async (bugzillaApiKey: string, uuid: string, affect: Affect, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bugzillaApiKey' is not null or undefined
            assertParamExists('osidbApiV1AffectsUpdate', 'bugzillaApiKey', bugzillaApiKey)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('osidbApiV1AffectsUpdate', 'uuid', uuid)
            // verify required parameter 'affect' is not null or undefined
            assertParamExists('osidbApiV1AffectsUpdate', 'affect', affect)
            const localVarPath = `/osidb/api/v1/affects/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (bugzillaApiKey != null) {
                localVarHeaderParameter['Bugzilla-Api-Key'] = String(bugzillaApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(affect, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} flawId 
         * @param {FlawAcknowledgmentPost} flawAcknowledgmentPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsAcknowledgmentsCreate: async (flawId: string, flawAcknowledgmentPost: FlawAcknowledgmentPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsAcknowledgmentsCreate', 'flawId', flawId)
            // verify required parameter 'flawAcknowledgmentPost' is not null or undefined
            assertParamExists('osidbApiV1FlawsAcknowledgmentsCreate', 'flawAcknowledgmentPost', flawAcknowledgmentPost)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/acknowledgments`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flawAcknowledgmentPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Destroy the instance and proxy the delete to Bugzilla
         * @param {string} flawId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsAcknowledgmentsDestroy: async (flawId: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsAcknowledgmentsDestroy', 'flawId', flawId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osidbApiV1FlawsAcknowledgmentsDestroy', 'id', id)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/acknowledgments/{id}`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} [affiliation] 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {boolean} [fromUpstream] 
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsAcknowledgmentsList: async (flawId: string, affiliation?: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, excludeFields?: Array<string>, fromUpstream?: boolean, includeFields?: Array<string>, includeMetaAttr?: Array<string>, limit?: number, name?: string, offset?: number, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsAcknowledgmentsList', 'flawId', flawId)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/acknowledgments`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (affiliation !== undefined) {
                localVarQueryParameter['affiliation'] = affiliation;
            }

            if (createdDt !== undefined) {
                localVarQueryParameter['created_dt'] = (createdDt as any instanceof Date) ?
                    (createdDt as any).toISOString() :
                    createdDt;
            }

            if (createdDtDate !== undefined) {
                localVarQueryParameter['created_dt__date'] = (createdDtDate as any instanceof Date) ?
                    (createdDtDate as any).toISOString().substr(0,10) :
                    createdDtDate;
            }

            if (createdDtDateGte !== undefined) {
                localVarQueryParameter['created_dt__date__gte'] = (createdDtDateGte as any instanceof Date) ?
                    (createdDtDateGte as any).toISOString().substr(0,10) :
                    createdDtDateGte;
            }

            if (createdDtDateLte !== undefined) {
                localVarQueryParameter['created_dt__date__lte'] = (createdDtDateLte as any instanceof Date) ?
                    (createdDtDateLte as any).toISOString().substr(0,10) :
                    createdDtDateLte;
            }

            if (createdDtGt !== undefined) {
                localVarQueryParameter['created_dt__gt'] = (createdDtGt as any instanceof Date) ?
                    (createdDtGt as any).toISOString() :
                    createdDtGt;
            }

            if (createdDtGte !== undefined) {
                localVarQueryParameter['created_dt__gte'] = (createdDtGte as any instanceof Date) ?
                    (createdDtGte as any).toISOString() :
                    createdDtGte;
            }

            if (createdDtLt !== undefined) {
                localVarQueryParameter['created_dt__lt'] = (createdDtLt as any instanceof Date) ?
                    (createdDtLt as any).toISOString() :
                    createdDtLt;
            }

            if (createdDtLte !== undefined) {
                localVarQueryParameter['created_dt__lte'] = (createdDtLte as any instanceof Date) ?
                    (createdDtLte as any).toISOString() :
                    createdDtLte;
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (fromUpstream !== undefined) {
                localVarQueryParameter['from_upstream'] = fromUpstream;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }

            if (includeMetaAttr) {
                localVarQueryParameter['include_meta_attr'] = includeMetaAttr;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (updatedDt !== undefined) {
                localVarQueryParameter['updated_dt'] = (updatedDt as any instanceof Date) ?
                    (updatedDt as any).toISOString() :
                    updatedDt;
            }

            if (updatedDtDate !== undefined) {
                localVarQueryParameter['updated_dt__date'] = (updatedDtDate as any instanceof Date) ?
                    (updatedDtDate as any).toISOString().substr(0,10) :
                    updatedDtDate;
            }

            if (updatedDtDateGte !== undefined) {
                localVarQueryParameter['updated_dt__date__gte'] = (updatedDtDateGte as any instanceof Date) ?
                    (updatedDtDateGte as any).toISOString().substr(0,10) :
                    updatedDtDateGte;
            }

            if (updatedDtDateLte !== undefined) {
                localVarQueryParameter['updated_dt__date__lte'] = (updatedDtDateLte as any instanceof Date) ?
                    (updatedDtDateLte as any).toISOString().substr(0,10) :
                    updatedDtDateLte;
            }

            if (updatedDtGt !== undefined) {
                localVarQueryParameter['updated_dt__gt'] = (updatedDtGt as any instanceof Date) ?
                    (updatedDtGt as any).toISOString() :
                    updatedDtGt;
            }

            if (updatedDtGte !== undefined) {
                localVarQueryParameter['updated_dt__gte'] = (updatedDtGte as any instanceof Date) ?
                    (updatedDtGte as any).toISOString() :
                    updatedDtGte;
            }

            if (updatedDtLt !== undefined) {
                localVarQueryParameter['updated_dt__lt'] = (updatedDtLt as any instanceof Date) ?
                    (updatedDtLt as any).toISOString() :
                    updatedDtLt;
            }

            if (updatedDtLte !== undefined) {
                localVarQueryParameter['updated_dt__lte'] = (updatedDtLte as any instanceof Date) ?
                    (updatedDtLte as any).toISOString() :
                    updatedDtLte;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} id 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsAcknowledgmentsRetrieve: async (flawId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsAcknowledgmentsRetrieve', 'flawId', flawId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osidbApiV1FlawsAcknowledgmentsRetrieve', 'id', id)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/acknowledgments/{id}`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }

            if (includeMetaAttr) {
                localVarQueryParameter['include_meta_attr'] = includeMetaAttr;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} id 
         * @param {FlawAcknowledgmentPut} flawAcknowledgmentPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsAcknowledgmentsUpdate: async (flawId: string, id: string, flawAcknowledgmentPut: FlawAcknowledgmentPut, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsAcknowledgmentsUpdate', 'flawId', flawId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osidbApiV1FlawsAcknowledgmentsUpdate', 'id', id)
            // verify required parameter 'flawAcknowledgmentPut' is not null or undefined
            assertParamExists('osidbApiV1FlawsAcknowledgmentsUpdate', 'flawAcknowledgmentPut', flawAcknowledgmentPut)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/acknowledgments/{id}`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flawAcknowledgmentPut, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new comment for a given flaw. Beware that freshly created comments are not guaranteed to keep their original UUIDs, especially if multiple comments are created simultaneously.
         * @param {string} flawId A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
         * @param {FlawCommentPost} flawCommentPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsCommentsCreate: async (flawId: string, flawCommentPost: FlawCommentPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsCommentsCreate', 'flawId', flawId)
            // verify required parameter 'flawCommentPost' is not null or undefined
            assertParamExists('osidbApiV1FlawsCommentsCreate', 'flawCommentPost', flawCommentPost)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/comments`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flawCommentPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List existing comments for a given flaw. Beware that freshly created comments are not guaranteed to keep their original UUIDs, especially if multiple comments are created simultaneously.
         * @param {string} flawId A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {string} [externalSystemId] 
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {number} [order] Retrieve only FlawComment resource with the specified order number. Regular flaw comments are numbered from 1 up.
         * @param {string} [uuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsCommentsList: async (flawId: string, excludeFields?: Array<string>, externalSystemId?: string, includeFields?: Array<string>, includeMetaAttr?: Array<string>, limit?: number, offset?: number, order?: number, uuid?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsCommentsList', 'flawId', flawId)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/comments`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (externalSystemId !== undefined) {
                localVarQueryParameter['external_system_id'] = externalSystemId;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }

            if (includeMetaAttr) {
                localVarQueryParameter['include_meta_attr'] = includeMetaAttr;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single existing comments for a given flaw. Beware that freshly created comments are not guaranteed to keep their original UUIDs, especially if multiple comments are created simultaneously.
         * @param {string} commentId A string representing the internal OSIDB UUID of the FlawComment resource.
         * @param {string} flawId A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsCommentsRetrieve: async (commentId: string, flawId: string, excludeFields?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('osidbApiV1FlawsCommentsRetrieve', 'commentId', commentId)
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsCommentsRetrieve', 'flawId', flawId)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/comments/{comment_id}`
                .replace(`{${"comment_id"}}`, encodeURIComponent(String(commentId)))
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }

            if (includeMetaAttr) {
                localVarQueryParameter['include_meta_attr'] = includeMetaAttr;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {FlawPost} flawPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsCreate: async (bugzillaApiKey: string, jiraApiKey: string, flawPost: FlawPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bugzillaApiKey' is not null or undefined
            assertParamExists('osidbApiV1FlawsCreate', 'bugzillaApiKey', bugzillaApiKey)
            // verify required parameter 'jiraApiKey' is not null or undefined
            assertParamExists('osidbApiV1FlawsCreate', 'jiraApiKey', jiraApiKey)
            // verify required parameter 'flawPost' is not null or undefined
            assertParamExists('osidbApiV1FlawsCreate', 'flawPost', flawPost)
            const localVarPath = `/osidb/api/v1/flaws`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (bugzillaApiKey != null) {
                localVarHeaderParameter['Bugzilla-Api-Key'] = String(bugzillaApiKey);
            }

            if (jiraApiKey != null) {
                localVarHeaderParameter['Jira-Api-Key'] = String(jiraApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flawPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} flawId 
         * @param {FlawCVSSPost} flawCVSSPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsCvssScoresCreate: async (flawId: string, flawCVSSPost: FlawCVSSPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsCvssScoresCreate', 'flawId', flawId)
            // verify required parameter 'flawCVSSPost' is not null or undefined
            assertParamExists('osidbApiV1FlawsCvssScoresCreate', 'flawCVSSPost', flawCVSSPost)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/cvss_scores`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flawCVSSPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Destroy the instance and proxy the delete to Bugzilla
         * @param {string} flawId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsCvssScoresDestroy: async (flawId: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsCvssScoresDestroy', 'flawId', flawId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osidbApiV1FlawsCvssScoresDestroy', 'id', id)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/cvss_scores/{id}`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} [comment] 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {string} [cvssVersion] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {'NIST' | 'RH'} [issuer] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {number} [score] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {string} [vector] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsCvssScoresList: async (flawId: string, comment?: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, cvssVersion?: string, excludeFields?: Array<string>, includeFields?: Array<string>, issuer?: 'NIST' | 'RH', limit?: number, offset?: number, score?: number, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, vector?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsCvssScoresList', 'flawId', flawId)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/cvss_scores`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (comment !== undefined) {
                localVarQueryParameter['comment'] = comment;
            }

            if (createdDt !== undefined) {
                localVarQueryParameter['created_dt'] = (createdDt as any instanceof Date) ?
                    (createdDt as any).toISOString() :
                    createdDt;
            }

            if (createdDtDate !== undefined) {
                localVarQueryParameter['created_dt__date'] = (createdDtDate as any instanceof Date) ?
                    (createdDtDate as any).toISOString().substr(0,10) :
                    createdDtDate;
            }

            if (createdDtDateGte !== undefined) {
                localVarQueryParameter['created_dt__date__gte'] = (createdDtDateGte as any instanceof Date) ?
                    (createdDtDateGte as any).toISOString().substr(0,10) :
                    createdDtDateGte;
            }

            if (createdDtDateLte !== undefined) {
                localVarQueryParameter['created_dt__date__lte'] = (createdDtDateLte as any instanceof Date) ?
                    (createdDtDateLte as any).toISOString().substr(0,10) :
                    createdDtDateLte;
            }

            if (createdDtGt !== undefined) {
                localVarQueryParameter['created_dt__gt'] = (createdDtGt as any instanceof Date) ?
                    (createdDtGt as any).toISOString() :
                    createdDtGt;
            }

            if (createdDtGte !== undefined) {
                localVarQueryParameter['created_dt__gte'] = (createdDtGte as any instanceof Date) ?
                    (createdDtGte as any).toISOString() :
                    createdDtGte;
            }

            if (createdDtLt !== undefined) {
                localVarQueryParameter['created_dt__lt'] = (createdDtLt as any instanceof Date) ?
                    (createdDtLt as any).toISOString() :
                    createdDtLt;
            }

            if (createdDtLte !== undefined) {
                localVarQueryParameter['created_dt__lte'] = (createdDtLte as any instanceof Date) ?
                    (createdDtLte as any).toISOString() :
                    createdDtLte;
            }

            if (cvssVersion !== undefined) {
                localVarQueryParameter['cvss_version'] = cvssVersion;
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }

            if (issuer !== undefined) {
                localVarQueryParameter['issuer'] = issuer;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (score !== undefined) {
                localVarQueryParameter['score'] = score;
            }

            if (updatedDt !== undefined) {
                localVarQueryParameter['updated_dt'] = (updatedDt as any instanceof Date) ?
                    (updatedDt as any).toISOString() :
                    updatedDt;
            }

            if (updatedDtDate !== undefined) {
                localVarQueryParameter['updated_dt__date'] = (updatedDtDate as any instanceof Date) ?
                    (updatedDtDate as any).toISOString().substr(0,10) :
                    updatedDtDate;
            }

            if (updatedDtDateGte !== undefined) {
                localVarQueryParameter['updated_dt__date__gte'] = (updatedDtDateGte as any instanceof Date) ?
                    (updatedDtDateGte as any).toISOString().substr(0,10) :
                    updatedDtDateGte;
            }

            if (updatedDtDateLte !== undefined) {
                localVarQueryParameter['updated_dt__date__lte'] = (updatedDtDateLte as any instanceof Date) ?
                    (updatedDtDateLte as any).toISOString().substr(0,10) :
                    updatedDtDateLte;
            }

            if (updatedDtGt !== undefined) {
                localVarQueryParameter['updated_dt__gt'] = (updatedDtGt as any instanceof Date) ?
                    (updatedDtGt as any).toISOString() :
                    updatedDtGt;
            }

            if (updatedDtGte !== undefined) {
                localVarQueryParameter['updated_dt__gte'] = (updatedDtGte as any instanceof Date) ?
                    (updatedDtGte as any).toISOString() :
                    updatedDtGte;
            }

            if (updatedDtLt !== undefined) {
                localVarQueryParameter['updated_dt__lt'] = (updatedDtLt as any instanceof Date) ?
                    (updatedDtLt as any).toISOString() :
                    updatedDtLt;
            }

            if (updatedDtLte !== undefined) {
                localVarQueryParameter['updated_dt__lte'] = (updatedDtLte as any instanceof Date) ?
                    (updatedDtLte as any).toISOString() :
                    updatedDtLte;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (vector !== undefined) {
                localVarQueryParameter['vector'] = vector;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} id 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsCvssScoresRetrieve: async (flawId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsCvssScoresRetrieve', 'flawId', flawId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osidbApiV1FlawsCvssScoresRetrieve', 'id', id)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/cvss_scores/{id}`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} id 
         * @param {FlawCVSSPut} flawCVSSPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsCvssScoresUpdate: async (flawId: string, id: string, flawCVSSPut: FlawCVSSPut, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsCvssScoresUpdate', 'flawId', flawId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osidbApiV1FlawsCvssScoresUpdate', 'id', id)
            // verify required parameter 'flawCVSSPut' is not null or undefined
            assertParamExists('osidbApiV1FlawsCvssScoresUpdate', 'flawCVSSPut', flawCVSSPut)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/cvss_scores/{id}`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flawCVSSPut, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [acknowledgmentsAffiliation] 
         * @param {string} [acknowledgmentsCreatedDt] 
         * @param {string} [acknowledgmentsCreatedDtDate] 
         * @param {string} [acknowledgmentsCreatedDtDateGte] 
         * @param {string} [acknowledgmentsCreatedDtDateLte] 
         * @param {string} [acknowledgmentsCreatedDtGt] 
         * @param {string} [acknowledgmentsCreatedDtGte] 
         * @param {string} [acknowledgmentsCreatedDtLt] 
         * @param {string} [acknowledgmentsCreatedDtLte] 
         * @param {boolean} [acknowledgmentsFromUpstream] 
         * @param {string} [acknowledgmentsName] 
         * @param {string} [acknowledgmentsUpdatedDt] 
         * @param {string} [acknowledgmentsUpdatedDtDate] 
         * @param {string} [acknowledgmentsUpdatedDtDateGte] 
         * @param {string} [acknowledgmentsUpdatedDtDateLte] 
         * @param {string} [acknowledgmentsUpdatedDtGt] 
         * @param {string} [acknowledgmentsUpdatedDtGte] 
         * @param {string} [acknowledgmentsUpdatedDtLt] 
         * @param {string} [acknowledgmentsUpdatedDtLte] 
         * @param {string} [acknowledgmentsUuid] 
         * @param {'' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED'} [affectsAffectedness] 
         * @param {string} [affectsCreatedDt] 
         * @param {string} [affectsCreatedDtDate] 
         * @param {string} [affectsCreatedDtDateGte] 
         * @param {string} [affectsCreatedDtDateLte] 
         * @param {string} [affectsCreatedDtGt] 
         * @param {string} [affectsCreatedDtGte] 
         * @param {string} [affectsCreatedDtLt] 
         * @param {string} [affectsCreatedDtLte] 
         * @param {string} [affectsCvss2] 
         * @param {number} [affectsCvss2Score] 
         * @param {number} [affectsCvss2ScoreGt] 
         * @param {number} [affectsCvss2ScoreGte] 
         * @param {number} [affectsCvss2ScoreLt] 
         * @param {number} [affectsCvss2ScoreLte] 
         * @param {string} [affectsCvss3] 
         * @param {number} [affectsCvss3Score] 
         * @param {number} [affectsCvss3ScoreGt] 
         * @param {number} [affectsCvss3ScoreGte] 
         * @param {number} [affectsCvss3ScoreLt] 
         * @param {number} [affectsCvss3ScoreLte] 
         * @param {boolean} [affectsEmbargoed] 
         * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [affectsImpact] 
         * @param {string} [affectsPsComponent] 
         * @param {string} [affectsPsModule] 
         * @param {'' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT'} [affectsResolution] 
         * @param {string} [affectsTrackersCreatedDt] 
         * @param {string} [affectsTrackersCreatedDtDate] 
         * @param {string} [affectsTrackersCreatedDtDateGte] 
         * @param {string} [affectsTrackersCreatedDtDateLte] 
         * @param {string} [affectsTrackersCreatedDtGt] 
         * @param {string} [affectsTrackersCreatedDtGte] 
         * @param {string} [affectsTrackersCreatedDtLt] 
         * @param {string} [affectsTrackersCreatedDtLte] 
         * @param {boolean} [affectsTrackersEmbargoed] 
         * @param {string} [affectsTrackersErrataAdvisoryName] 
         * @param {number} [affectsTrackersErrataEtId] 
         * @param {string} [affectsTrackersErrataShippedDt] 
         * @param {string} [affectsTrackersErrataShippedDtDate] 
         * @param {string} [affectsTrackersErrataShippedDtDateGte] 
         * @param {string} [affectsTrackersErrataShippedDtDateLte] 
         * @param {string} [affectsTrackersErrataShippedDtGt] 
         * @param {string} [affectsTrackersErrataShippedDtGte] 
         * @param {string} [affectsTrackersErrataShippedDtLt] 
         * @param {string} [affectsTrackersErrataShippedDtLte] 
         * @param {string} [affectsTrackersExternalSystemId] 
         * @param {string} [affectsTrackersPsUpdateStream] 
         * @param {string} [affectsTrackersResolution] 
         * @param {string} [affectsTrackersStatus] 
         * @param {'BUGZILLA' | 'JIRA'} [affectsTrackersType] 
         * @param {string} [affectsTrackersUpdatedDt] 
         * @param {string} [affectsTrackersUpdatedDtDate] 
         * @param {string} [affectsTrackersUpdatedDtDateGte] 
         * @param {string} [affectsTrackersUpdatedDtDateLte] 
         * @param {string} [affectsTrackersUpdatedDtGt] 
         * @param {string} [affectsTrackersUpdatedDtGte] 
         * @param {string} [affectsTrackersUpdatedDtLt] 
         * @param {string} [affectsTrackersUpdatedDtLte] 
         * @param {string} [affectsTrackersUuid] 
         * @param {'DEFAULT'} [affectsType] 
         * @param {string} [affectsUpdatedDt] 
         * @param {string} [affectsUpdatedDtDate] 
         * @param {string} [affectsUpdatedDtDateGte] 
         * @param {string} [affectsUpdatedDtDateLte] 
         * @param {string} [affectsUpdatedDtGt] 
         * @param {string} [affectsUpdatedDtGte] 
         * @param {string} [affectsUpdatedDtLt] 
         * @param {string} [affectsUpdatedDtLte] 
         * @param {string} [affectsUuid] 
         * @param {number} [bzId] 
         * @param {string} [changedAfter] 
         * @param {string} [changedBefore] 
         * @param {string} [component] 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {Array<string>} [cveId] Multiple values may be separated by commas.
         * @param {string} [cvss2] 
         * @param {number} [cvss2Score] 
         * @param {number} [cvss2ScoreGt] 
         * @param {number} [cvss2ScoreGte] 
         * @param {number} [cvss2ScoreLt] 
         * @param {number} [cvss2ScoreLte] 
         * @param {string} [cvss3] 
         * @param {number} [cvss3Score] 
         * @param {number} [cvss3ScoreGt] 
         * @param {number} [cvss3ScoreGte] 
         * @param {number} [cvss3ScoreLt] 
         * @param {number} [cvss3ScoreLte] 
         * @param {string} [cvssScoresComment] 
         * @param {string} [cvssScoresCreatedDt] 
         * @param {string} [cvssScoresCreatedDtDate] 
         * @param {string} [cvssScoresCreatedDtDateGte] 
         * @param {string} [cvssScoresCreatedDtDateLte] 
         * @param {string} [cvssScoresCreatedDtGt] 
         * @param {string} [cvssScoresCreatedDtGte] 
         * @param {string} [cvssScoresCreatedDtLt] 
         * @param {string} [cvssScoresCreatedDtLte] 
         * @param {string} [cvssScoresCvssVersion] 
         * @param {'NIST' | 'RH'} [cvssScoresIssuer] 
         * @param {number} [cvssScoresScore] 
         * @param {string} [cvssScoresUpdatedDt] 
         * @param {string} [cvssScoresUpdatedDtDate] 
         * @param {string} [cvssScoresUpdatedDtDateGte] 
         * @param {string} [cvssScoresUpdatedDtDateLte] 
         * @param {string} [cvssScoresUpdatedDtGt] 
         * @param {string} [cvssScoresUpdatedDtGte] 
         * @param {string} [cvssScoresUpdatedDtLt] 
         * @param {string} [cvssScoresUpdatedDtLte] 
         * @param {string} [cvssScoresUuid] 
         * @param {string} [cvssScoresVector] 
         * @param {string} [cweId] 
         * @param {string} [description] 
         * @param {boolean} [embargoed] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [flawMetaType] Include flaw metas with specified type only, multiple values may be separated by commas. 
         * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [impact] 
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {boolean} [isMajorIncident] 
         * @param {number} [limit] Number of results to return per page.
         * @param {'' | 'APPROVED' | 'CISA_APPROVED' | 'INVALID' | 'REJECTED' | 'REQUESTED'} [majorIncidentState] 
         * @param {'' | 'APPROVED' | 'REJECTED' | 'REQUESTED'} [nistCvssValidation] 
         * @param {string} [nvdCvss2] 
         * @param {string} [nvdCvss3] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {Array<'-acknowledgments__affiliation' | '-acknowledgments__created_dt' | '-acknowledgments__from_upstream' | '-acknowledgments__name' | '-acknowledgments__updated_dt' | '-acknowledgments__uuid' | '-affects__affectedness' | '-affects__created_dt' | '-affects__cvss2' | '-affects__cvss2_score' | '-affects__cvss3' | '-affects__cvss3_score' | '-affects__impact' | '-affects__ps_component' | '-affects__ps_module' | '-affects__resolution' | '-affects__trackers__created_dt' | '-affects__trackers__errata__advisory_name' | '-affects__trackers__errata__et_id' | '-affects__trackers__errata__shipped_dt' | '-affects__trackers__external_system_id' | '-affects__trackers__ps_update_stream' | '-affects__trackers__resolution' | '-affects__trackers__status' | '-affects__trackers__type' | '-affects__trackers__updated_dt' | '-affects__trackers__uuid' | '-affects__type' | '-affects__updated_dt' | '-affects__uuid' | '-component' | '-created_dt' | '-cve_id' | '-cvss2' | '-cvss2_score' | '-cvss3' | '-cvss3_score' | '-cvss_scores__comment' | '-cvss_scores__created_dt' | '-cvss_scores__issuer' | '-cvss_scores__score' | '-cvss_scores__updated_dt' | '-cvss_scores__uuid' | '-cvss_scores__vector' | '-cwe_id' | '-impact' | '-major_incident_state' | '-nist_cvss_validation' | '-nvd_cvss2' | '-nvd_cvss3' | '-references__created_dt' | '-references__description' | '-references__type' | '-references__updated_dt' | '-references__url' | '-references__uuid' | '-reported_dt' | '-requires_summary' | '-source' | '-type' | '-unembargo_dt' | '-updated_dt' | '-uuid' | 'acknowledgments__affiliation' | 'acknowledgments__created_dt' | 'acknowledgments__from_upstream' | 'acknowledgments__name' | 'acknowledgments__updated_dt' | 'acknowledgments__uuid' | 'affects__affectedness' | 'affects__created_dt' | 'affects__cvss2' | 'affects__cvss2_score' | 'affects__cvss3' | 'affects__cvss3_score' | 'affects__impact' | 'affects__ps_component' | 'affects__ps_module' | 'affects__resolution' | 'affects__trackers__created_dt' | 'affects__trackers__errata__advisory_name' | 'affects__trackers__errata__et_id' | 'affects__trackers__errata__shipped_dt' | 'affects__trackers__external_system_id' | 'affects__trackers__ps_update_stream' | 'affects__trackers__resolution' | 'affects__trackers__status' | 'affects__trackers__type' | 'affects__trackers__updated_dt' | 'affects__trackers__uuid' | 'affects__type' | 'affects__updated_dt' | 'affects__uuid' | 'component' | 'created_dt' | 'cve_id' | 'cvss2' | 'cvss2_score' | 'cvss3' | 'cvss3_score' | 'cvss_scores__comment' | 'cvss_scores__created_dt' | 'cvss_scores__issuer' | 'cvss_scores__score' | 'cvss_scores__updated_dt' | 'cvss_scores__uuid' | 'cvss_scores__vector' | 'cwe_id' | 'impact' | 'major_incident_state' | 'nist_cvss_validation' | 'nvd_cvss2' | 'nvd_cvss3' | 'references__created_dt' | 'references__description' | 'references__type' | 'references__updated_dt' | 'references__url' | 'references__uuid' | 'reported_dt' | 'requires_summary' | 'source' | 'type' | 'unembargo_dt' | 'updated_dt' | 'uuid'>} [order] Ordering
         * @param {string} [referencesCreatedDt] 
         * @param {string} [referencesCreatedDtDate] 
         * @param {string} [referencesCreatedDtDateGte] 
         * @param {string} [referencesCreatedDtDateLte] 
         * @param {string} [referencesCreatedDtGt] 
         * @param {string} [referencesCreatedDtGte] 
         * @param {string} [referencesCreatedDtLt] 
         * @param {string} [referencesCreatedDtLte] 
         * @param {string} [referencesDescription] 
         * @param {'ARTICLE' | 'EXTERNAL' | 'SOURCE'} [referencesType] 
         * @param {string} [referencesUpdatedDt] 
         * @param {string} [referencesUpdatedDtDate] 
         * @param {string} [referencesUpdatedDtDateGte] 
         * @param {string} [referencesUpdatedDtDateLte] 
         * @param {string} [referencesUpdatedDtGt] 
         * @param {string} [referencesUpdatedDtGte] 
         * @param {string} [referencesUpdatedDtLt] 
         * @param {string} [referencesUpdatedDtLte] 
         * @param {string} [referencesUrl] 
         * @param {string} [referencesUuid] 
         * @param {string} [reportedDt] 
         * @param {string} [reportedDtDate] 
         * @param {string} [reportedDtDateGte] 
         * @param {string} [reportedDtDateLte] 
         * @param {string} [reportedDtGt] 
         * @param {string} [reportedDtGte] 
         * @param {string} [reportedDtLt] 
         * @param {string} [reportedDtLte] 
         * @param {'' | 'APPROVED' | 'REJECTED' | 'REQUESTED'} [requiresSummary] 
         * @param {string} [search] 
         * @param {'' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF'} [source] 
         * @param {string} [statement] 
         * @param {string} [summary] 
         * @param {string} [title] 
         * @param {Array<string>} [trackerIds] Filter only Flaws which are related to specified Trackers (through Affects). Multiple tracker IDs may be separated by commas. Also only Affects that have the specified Trackers related will be shown.
         * @param {'VULNERABILITY' | 'WEAKNESS'} [type] 
         * @param {string} [unembargoDt] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsList: async (acknowledgmentsAffiliation?: string, acknowledgmentsCreatedDt?: string, acknowledgmentsCreatedDtDate?: string, acknowledgmentsCreatedDtDateGte?: string, acknowledgmentsCreatedDtDateLte?: string, acknowledgmentsCreatedDtGt?: string, acknowledgmentsCreatedDtGte?: string, acknowledgmentsCreatedDtLt?: string, acknowledgmentsCreatedDtLte?: string, acknowledgmentsFromUpstream?: boolean, acknowledgmentsName?: string, acknowledgmentsUpdatedDt?: string, acknowledgmentsUpdatedDtDate?: string, acknowledgmentsUpdatedDtDateGte?: string, acknowledgmentsUpdatedDtDateLte?: string, acknowledgmentsUpdatedDtGt?: string, acknowledgmentsUpdatedDtGte?: string, acknowledgmentsUpdatedDtLt?: string, acknowledgmentsUpdatedDtLte?: string, acknowledgmentsUuid?: string, affectsAffectedness?: '' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED', affectsCreatedDt?: string, affectsCreatedDtDate?: string, affectsCreatedDtDateGte?: string, affectsCreatedDtDateLte?: string, affectsCreatedDtGt?: string, affectsCreatedDtGte?: string, affectsCreatedDtLt?: string, affectsCreatedDtLte?: string, affectsCvss2?: string, affectsCvss2Score?: number, affectsCvss2ScoreGt?: number, affectsCvss2ScoreGte?: number, affectsCvss2ScoreLt?: number, affectsCvss2ScoreLte?: number, affectsCvss3?: string, affectsCvss3Score?: number, affectsCvss3ScoreGt?: number, affectsCvss3ScoreGte?: number, affectsCvss3ScoreLt?: number, affectsCvss3ScoreLte?: number, affectsEmbargoed?: boolean, affectsImpact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', affectsPsComponent?: string, affectsPsModule?: string, affectsResolution?: '' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT', affectsTrackersCreatedDt?: string, affectsTrackersCreatedDtDate?: string, affectsTrackersCreatedDtDateGte?: string, affectsTrackersCreatedDtDateLte?: string, affectsTrackersCreatedDtGt?: string, affectsTrackersCreatedDtGte?: string, affectsTrackersCreatedDtLt?: string, affectsTrackersCreatedDtLte?: string, affectsTrackersEmbargoed?: boolean, affectsTrackersErrataAdvisoryName?: string, affectsTrackersErrataEtId?: number, affectsTrackersErrataShippedDt?: string, affectsTrackersErrataShippedDtDate?: string, affectsTrackersErrataShippedDtDateGte?: string, affectsTrackersErrataShippedDtDateLte?: string, affectsTrackersErrataShippedDtGt?: string, affectsTrackersErrataShippedDtGte?: string, affectsTrackersErrataShippedDtLt?: string, affectsTrackersErrataShippedDtLte?: string, affectsTrackersExternalSystemId?: string, affectsTrackersPsUpdateStream?: string, affectsTrackersResolution?: string, affectsTrackersStatus?: string, affectsTrackersType?: 'BUGZILLA' | 'JIRA', affectsTrackersUpdatedDt?: string, affectsTrackersUpdatedDtDate?: string, affectsTrackersUpdatedDtDateGte?: string, affectsTrackersUpdatedDtDateLte?: string, affectsTrackersUpdatedDtGt?: string, affectsTrackersUpdatedDtGte?: string, affectsTrackersUpdatedDtLt?: string, affectsTrackersUpdatedDtLte?: string, affectsTrackersUuid?: string, affectsType?: 'DEFAULT', affectsUpdatedDt?: string, affectsUpdatedDtDate?: string, affectsUpdatedDtDateGte?: string, affectsUpdatedDtDateLte?: string, affectsUpdatedDtGt?: string, affectsUpdatedDtGte?: string, affectsUpdatedDtLt?: string, affectsUpdatedDtLte?: string, affectsUuid?: string, bzId?: number, changedAfter?: string, changedBefore?: string, component?: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, cveId?: Array<string>, cvss2?: string, cvss2Score?: number, cvss2ScoreGt?: number, cvss2ScoreGte?: number, cvss2ScoreLt?: number, cvss2ScoreLte?: number, cvss3?: string, cvss3Score?: number, cvss3ScoreGt?: number, cvss3ScoreGte?: number, cvss3ScoreLt?: number, cvss3ScoreLte?: number, cvssScoresComment?: string, cvssScoresCreatedDt?: string, cvssScoresCreatedDtDate?: string, cvssScoresCreatedDtDateGte?: string, cvssScoresCreatedDtDateLte?: string, cvssScoresCreatedDtGt?: string, cvssScoresCreatedDtGte?: string, cvssScoresCreatedDtLt?: string, cvssScoresCreatedDtLte?: string, cvssScoresCvssVersion?: string, cvssScoresIssuer?: 'NIST' | 'RH', cvssScoresScore?: number, cvssScoresUpdatedDt?: string, cvssScoresUpdatedDtDate?: string, cvssScoresUpdatedDtDateGte?: string, cvssScoresUpdatedDtDateLte?: string, cvssScoresUpdatedDtGt?: string, cvssScoresUpdatedDtGte?: string, cvssScoresUpdatedDtLt?: string, cvssScoresUpdatedDtLte?: string, cvssScoresUuid?: string, cvssScoresVector?: string, cweId?: string, description?: string, embargoed?: boolean, excludeFields?: Array<string>, flawMetaType?: Array<string>, impact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', includeFields?: Array<string>, includeMetaAttr?: Array<string>, isMajorIncident?: boolean, limit?: number, majorIncidentState?: '' | 'APPROVED' | 'CISA_APPROVED' | 'INVALID' | 'REJECTED' | 'REQUESTED', nistCvssValidation?: '' | 'APPROVED' | 'REJECTED' | 'REQUESTED', nvdCvss2?: string, nvdCvss3?: string, offset?: number, order?: Array<'-acknowledgments__affiliation' | '-acknowledgments__created_dt' | '-acknowledgments__from_upstream' | '-acknowledgments__name' | '-acknowledgments__updated_dt' | '-acknowledgments__uuid' | '-affects__affectedness' | '-affects__created_dt' | '-affects__cvss2' | '-affects__cvss2_score' | '-affects__cvss3' | '-affects__cvss3_score' | '-affects__impact' | '-affects__ps_component' | '-affects__ps_module' | '-affects__resolution' | '-affects__trackers__created_dt' | '-affects__trackers__errata__advisory_name' | '-affects__trackers__errata__et_id' | '-affects__trackers__errata__shipped_dt' | '-affects__trackers__external_system_id' | '-affects__trackers__ps_update_stream' | '-affects__trackers__resolution' | '-affects__trackers__status' | '-affects__trackers__type' | '-affects__trackers__updated_dt' | '-affects__trackers__uuid' | '-affects__type' | '-affects__updated_dt' | '-affects__uuid' | '-component' | '-created_dt' | '-cve_id' | '-cvss2' | '-cvss2_score' | '-cvss3' | '-cvss3_score' | '-cvss_scores__comment' | '-cvss_scores__created_dt' | '-cvss_scores__issuer' | '-cvss_scores__score' | '-cvss_scores__updated_dt' | '-cvss_scores__uuid' | '-cvss_scores__vector' | '-cwe_id' | '-impact' | '-major_incident_state' | '-nist_cvss_validation' | '-nvd_cvss2' | '-nvd_cvss3' | '-references__created_dt' | '-references__description' | '-references__type' | '-references__updated_dt' | '-references__url' | '-references__uuid' | '-reported_dt' | '-requires_summary' | '-source' | '-type' | '-unembargo_dt' | '-updated_dt' | '-uuid' | 'acknowledgments__affiliation' | 'acknowledgments__created_dt' | 'acknowledgments__from_upstream' | 'acknowledgments__name' | 'acknowledgments__updated_dt' | 'acknowledgments__uuid' | 'affects__affectedness' | 'affects__created_dt' | 'affects__cvss2' | 'affects__cvss2_score' | 'affects__cvss3' | 'affects__cvss3_score' | 'affects__impact' | 'affects__ps_component' | 'affects__ps_module' | 'affects__resolution' | 'affects__trackers__created_dt' | 'affects__trackers__errata__advisory_name' | 'affects__trackers__errata__et_id' | 'affects__trackers__errata__shipped_dt' | 'affects__trackers__external_system_id' | 'affects__trackers__ps_update_stream' | 'affects__trackers__resolution' | 'affects__trackers__status' | 'affects__trackers__type' | 'affects__trackers__updated_dt' | 'affects__trackers__uuid' | 'affects__type' | 'affects__updated_dt' | 'affects__uuid' | 'component' | 'created_dt' | 'cve_id' | 'cvss2' | 'cvss2_score' | 'cvss3' | 'cvss3_score' | 'cvss_scores__comment' | 'cvss_scores__created_dt' | 'cvss_scores__issuer' | 'cvss_scores__score' | 'cvss_scores__updated_dt' | 'cvss_scores__uuid' | 'cvss_scores__vector' | 'cwe_id' | 'impact' | 'major_incident_state' | 'nist_cvss_validation' | 'nvd_cvss2' | 'nvd_cvss3' | 'references__created_dt' | 'references__description' | 'references__type' | 'references__updated_dt' | 'references__url' | 'references__uuid' | 'reported_dt' | 'requires_summary' | 'source' | 'type' | 'unembargo_dt' | 'updated_dt' | 'uuid'>, referencesCreatedDt?: string, referencesCreatedDtDate?: string, referencesCreatedDtDateGte?: string, referencesCreatedDtDateLte?: string, referencesCreatedDtGt?: string, referencesCreatedDtGte?: string, referencesCreatedDtLt?: string, referencesCreatedDtLte?: string, referencesDescription?: string, referencesType?: 'ARTICLE' | 'EXTERNAL' | 'SOURCE', referencesUpdatedDt?: string, referencesUpdatedDtDate?: string, referencesUpdatedDtDateGte?: string, referencesUpdatedDtDateLte?: string, referencesUpdatedDtGt?: string, referencesUpdatedDtGte?: string, referencesUpdatedDtLt?: string, referencesUpdatedDtLte?: string, referencesUrl?: string, referencesUuid?: string, reportedDt?: string, reportedDtDate?: string, reportedDtDateGte?: string, reportedDtDateLte?: string, reportedDtGt?: string, reportedDtGte?: string, reportedDtLt?: string, reportedDtLte?: string, requiresSummary?: '' | 'APPROVED' | 'REJECTED' | 'REQUESTED', search?: string, source?: '' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF', statement?: string, summary?: string, title?: string, trackerIds?: Array<string>, type?: 'VULNERABILITY' | 'WEAKNESS', unembargoDt?: string, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/osidb/api/v1/flaws`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acknowledgmentsAffiliation !== undefined) {
                localVarQueryParameter['acknowledgments__affiliation'] = acknowledgmentsAffiliation;
            }

            if (acknowledgmentsCreatedDt !== undefined) {
                localVarQueryParameter['acknowledgments__created_dt'] = (acknowledgmentsCreatedDt as any instanceof Date) ?
                    (acknowledgmentsCreatedDt as any).toISOString() :
                    acknowledgmentsCreatedDt;
            }

            if (acknowledgmentsCreatedDtDate !== undefined) {
                localVarQueryParameter['acknowledgments__created_dt__date'] = (acknowledgmentsCreatedDtDate as any instanceof Date) ?
                    (acknowledgmentsCreatedDtDate as any).toISOString().substr(0,10) :
                    acknowledgmentsCreatedDtDate;
            }

            if (acknowledgmentsCreatedDtDateGte !== undefined) {
                localVarQueryParameter['acknowledgments__created_dt__date__gte'] = (acknowledgmentsCreatedDtDateGte as any instanceof Date) ?
                    (acknowledgmentsCreatedDtDateGte as any).toISOString().substr(0,10) :
                    acknowledgmentsCreatedDtDateGte;
            }

            if (acknowledgmentsCreatedDtDateLte !== undefined) {
                localVarQueryParameter['acknowledgments__created_dt__date__lte'] = (acknowledgmentsCreatedDtDateLte as any instanceof Date) ?
                    (acknowledgmentsCreatedDtDateLte as any).toISOString().substr(0,10) :
                    acknowledgmentsCreatedDtDateLte;
            }

            if (acknowledgmentsCreatedDtGt !== undefined) {
                localVarQueryParameter['acknowledgments__created_dt__gt'] = (acknowledgmentsCreatedDtGt as any instanceof Date) ?
                    (acknowledgmentsCreatedDtGt as any).toISOString() :
                    acknowledgmentsCreatedDtGt;
            }

            if (acknowledgmentsCreatedDtGte !== undefined) {
                localVarQueryParameter['acknowledgments__created_dt__gte'] = (acknowledgmentsCreatedDtGte as any instanceof Date) ?
                    (acknowledgmentsCreatedDtGte as any).toISOString() :
                    acknowledgmentsCreatedDtGte;
            }

            if (acknowledgmentsCreatedDtLt !== undefined) {
                localVarQueryParameter['acknowledgments__created_dt__lt'] = (acknowledgmentsCreatedDtLt as any instanceof Date) ?
                    (acknowledgmentsCreatedDtLt as any).toISOString() :
                    acknowledgmentsCreatedDtLt;
            }

            if (acknowledgmentsCreatedDtLte !== undefined) {
                localVarQueryParameter['acknowledgments__created_dt__lte'] = (acknowledgmentsCreatedDtLte as any instanceof Date) ?
                    (acknowledgmentsCreatedDtLte as any).toISOString() :
                    acknowledgmentsCreatedDtLte;
            }

            if (acknowledgmentsFromUpstream !== undefined) {
                localVarQueryParameter['acknowledgments__from_upstream'] = acknowledgmentsFromUpstream;
            }

            if (acknowledgmentsName !== undefined) {
                localVarQueryParameter['acknowledgments__name'] = acknowledgmentsName;
            }

            if (acknowledgmentsUpdatedDt !== undefined) {
                localVarQueryParameter['acknowledgments__updated_dt'] = (acknowledgmentsUpdatedDt as any instanceof Date) ?
                    (acknowledgmentsUpdatedDt as any).toISOString() :
                    acknowledgmentsUpdatedDt;
            }

            if (acknowledgmentsUpdatedDtDate !== undefined) {
                localVarQueryParameter['acknowledgments__updated_dt__date'] = (acknowledgmentsUpdatedDtDate as any instanceof Date) ?
                    (acknowledgmentsUpdatedDtDate as any).toISOString().substr(0,10) :
                    acknowledgmentsUpdatedDtDate;
            }

            if (acknowledgmentsUpdatedDtDateGte !== undefined) {
                localVarQueryParameter['acknowledgments__updated_dt__date__gte'] = (acknowledgmentsUpdatedDtDateGte as any instanceof Date) ?
                    (acknowledgmentsUpdatedDtDateGte as any).toISOString().substr(0,10) :
                    acknowledgmentsUpdatedDtDateGte;
            }

            if (acknowledgmentsUpdatedDtDateLte !== undefined) {
                localVarQueryParameter['acknowledgments__updated_dt__date__lte'] = (acknowledgmentsUpdatedDtDateLte as any instanceof Date) ?
                    (acknowledgmentsUpdatedDtDateLte as any).toISOString().substr(0,10) :
                    acknowledgmentsUpdatedDtDateLte;
            }

            if (acknowledgmentsUpdatedDtGt !== undefined) {
                localVarQueryParameter['acknowledgments__updated_dt__gt'] = (acknowledgmentsUpdatedDtGt as any instanceof Date) ?
                    (acknowledgmentsUpdatedDtGt as any).toISOString() :
                    acknowledgmentsUpdatedDtGt;
            }

            if (acknowledgmentsUpdatedDtGte !== undefined) {
                localVarQueryParameter['acknowledgments__updated_dt__gte'] = (acknowledgmentsUpdatedDtGte as any instanceof Date) ?
                    (acknowledgmentsUpdatedDtGte as any).toISOString() :
                    acknowledgmentsUpdatedDtGte;
            }

            if (acknowledgmentsUpdatedDtLt !== undefined) {
                localVarQueryParameter['acknowledgments__updated_dt__lt'] = (acknowledgmentsUpdatedDtLt as any instanceof Date) ?
                    (acknowledgmentsUpdatedDtLt as any).toISOString() :
                    acknowledgmentsUpdatedDtLt;
            }

            if (acknowledgmentsUpdatedDtLte !== undefined) {
                localVarQueryParameter['acknowledgments__updated_dt__lte'] = (acknowledgmentsUpdatedDtLte as any instanceof Date) ?
                    (acknowledgmentsUpdatedDtLte as any).toISOString() :
                    acknowledgmentsUpdatedDtLte;
            }

            if (acknowledgmentsUuid !== undefined) {
                localVarQueryParameter['acknowledgments__uuid'] = acknowledgmentsUuid;
            }

            if (affectsAffectedness !== undefined) {
                localVarQueryParameter['affects__affectedness'] = affectsAffectedness;
            }

            if (affectsCreatedDt !== undefined) {
                localVarQueryParameter['affects__created_dt'] = (affectsCreatedDt as any instanceof Date) ?
                    (affectsCreatedDt as any).toISOString() :
                    affectsCreatedDt;
            }

            if (affectsCreatedDtDate !== undefined) {
                localVarQueryParameter['affects__created_dt__date'] = (affectsCreatedDtDate as any instanceof Date) ?
                    (affectsCreatedDtDate as any).toISOString().substr(0,10) :
                    affectsCreatedDtDate;
            }

            if (affectsCreatedDtDateGte !== undefined) {
                localVarQueryParameter['affects__created_dt__date__gte'] = (affectsCreatedDtDateGte as any instanceof Date) ?
                    (affectsCreatedDtDateGte as any).toISOString().substr(0,10) :
                    affectsCreatedDtDateGte;
            }

            if (affectsCreatedDtDateLte !== undefined) {
                localVarQueryParameter['affects__created_dt__date__lte'] = (affectsCreatedDtDateLte as any instanceof Date) ?
                    (affectsCreatedDtDateLte as any).toISOString().substr(0,10) :
                    affectsCreatedDtDateLte;
            }

            if (affectsCreatedDtGt !== undefined) {
                localVarQueryParameter['affects__created_dt__gt'] = (affectsCreatedDtGt as any instanceof Date) ?
                    (affectsCreatedDtGt as any).toISOString() :
                    affectsCreatedDtGt;
            }

            if (affectsCreatedDtGte !== undefined) {
                localVarQueryParameter['affects__created_dt__gte'] = (affectsCreatedDtGte as any instanceof Date) ?
                    (affectsCreatedDtGte as any).toISOString() :
                    affectsCreatedDtGte;
            }

            if (affectsCreatedDtLt !== undefined) {
                localVarQueryParameter['affects__created_dt__lt'] = (affectsCreatedDtLt as any instanceof Date) ?
                    (affectsCreatedDtLt as any).toISOString() :
                    affectsCreatedDtLt;
            }

            if (affectsCreatedDtLte !== undefined) {
                localVarQueryParameter['affects__created_dt__lte'] = (affectsCreatedDtLte as any instanceof Date) ?
                    (affectsCreatedDtLte as any).toISOString() :
                    affectsCreatedDtLte;
            }

            if (affectsCvss2 !== undefined) {
                localVarQueryParameter['affects__cvss2'] = affectsCvss2;
            }

            if (affectsCvss2Score !== undefined) {
                localVarQueryParameter['affects__cvss2_score'] = affectsCvss2Score;
            }

            if (affectsCvss2ScoreGt !== undefined) {
                localVarQueryParameter['affects__cvss2_score__gt'] = affectsCvss2ScoreGt;
            }

            if (affectsCvss2ScoreGte !== undefined) {
                localVarQueryParameter['affects__cvss2_score__gte'] = affectsCvss2ScoreGte;
            }

            if (affectsCvss2ScoreLt !== undefined) {
                localVarQueryParameter['affects__cvss2_score__lt'] = affectsCvss2ScoreLt;
            }

            if (affectsCvss2ScoreLte !== undefined) {
                localVarQueryParameter['affects__cvss2_score__lte'] = affectsCvss2ScoreLte;
            }

            if (affectsCvss3 !== undefined) {
                localVarQueryParameter['affects__cvss3'] = affectsCvss3;
            }

            if (affectsCvss3Score !== undefined) {
                localVarQueryParameter['affects__cvss3_score'] = affectsCvss3Score;
            }

            if (affectsCvss3ScoreGt !== undefined) {
                localVarQueryParameter['affects__cvss3_score__gt'] = affectsCvss3ScoreGt;
            }

            if (affectsCvss3ScoreGte !== undefined) {
                localVarQueryParameter['affects__cvss3_score__gte'] = affectsCvss3ScoreGte;
            }

            if (affectsCvss3ScoreLt !== undefined) {
                localVarQueryParameter['affects__cvss3_score__lt'] = affectsCvss3ScoreLt;
            }

            if (affectsCvss3ScoreLte !== undefined) {
                localVarQueryParameter['affects__cvss3_score__lte'] = affectsCvss3ScoreLte;
            }

            if (affectsEmbargoed !== undefined) {
                localVarQueryParameter['affects__embargoed'] = affectsEmbargoed;
            }

            if (affectsImpact !== undefined) {
                localVarQueryParameter['affects__impact'] = affectsImpact;
            }

            if (affectsPsComponent !== undefined) {
                localVarQueryParameter['affects__ps_component'] = affectsPsComponent;
            }

            if (affectsPsModule !== undefined) {
                localVarQueryParameter['affects__ps_module'] = affectsPsModule;
            }

            if (affectsResolution !== undefined) {
                localVarQueryParameter['affects__resolution'] = affectsResolution;
            }

            if (affectsTrackersCreatedDt !== undefined) {
                localVarQueryParameter['affects__trackers__created_dt'] = (affectsTrackersCreatedDt as any instanceof Date) ?
                    (affectsTrackersCreatedDt as any).toISOString() :
                    affectsTrackersCreatedDt;
            }

            if (affectsTrackersCreatedDtDate !== undefined) {
                localVarQueryParameter['affects__trackers__created_dt__date'] = (affectsTrackersCreatedDtDate as any instanceof Date) ?
                    (affectsTrackersCreatedDtDate as any).toISOString().substr(0,10) :
                    affectsTrackersCreatedDtDate;
            }

            if (affectsTrackersCreatedDtDateGte !== undefined) {
                localVarQueryParameter['affects__trackers__created_dt__date__gte'] = (affectsTrackersCreatedDtDateGte as any instanceof Date) ?
                    (affectsTrackersCreatedDtDateGte as any).toISOString().substr(0,10) :
                    affectsTrackersCreatedDtDateGte;
            }

            if (affectsTrackersCreatedDtDateLte !== undefined) {
                localVarQueryParameter['affects__trackers__created_dt__date__lte'] = (affectsTrackersCreatedDtDateLte as any instanceof Date) ?
                    (affectsTrackersCreatedDtDateLte as any).toISOString().substr(0,10) :
                    affectsTrackersCreatedDtDateLte;
            }

            if (affectsTrackersCreatedDtGt !== undefined) {
                localVarQueryParameter['affects__trackers__created_dt__gt'] = (affectsTrackersCreatedDtGt as any instanceof Date) ?
                    (affectsTrackersCreatedDtGt as any).toISOString() :
                    affectsTrackersCreatedDtGt;
            }

            if (affectsTrackersCreatedDtGte !== undefined) {
                localVarQueryParameter['affects__trackers__created_dt__gte'] = (affectsTrackersCreatedDtGte as any instanceof Date) ?
                    (affectsTrackersCreatedDtGte as any).toISOString() :
                    affectsTrackersCreatedDtGte;
            }

            if (affectsTrackersCreatedDtLt !== undefined) {
                localVarQueryParameter['affects__trackers__created_dt__lt'] = (affectsTrackersCreatedDtLt as any instanceof Date) ?
                    (affectsTrackersCreatedDtLt as any).toISOString() :
                    affectsTrackersCreatedDtLt;
            }

            if (affectsTrackersCreatedDtLte !== undefined) {
                localVarQueryParameter['affects__trackers__created_dt__lte'] = (affectsTrackersCreatedDtLte as any instanceof Date) ?
                    (affectsTrackersCreatedDtLte as any).toISOString() :
                    affectsTrackersCreatedDtLte;
            }

            if (affectsTrackersEmbargoed !== undefined) {
                localVarQueryParameter['affects__trackers__embargoed'] = affectsTrackersEmbargoed;
            }

            if (affectsTrackersErrataAdvisoryName !== undefined) {
                localVarQueryParameter['affects__trackers__errata__advisory_name'] = affectsTrackersErrataAdvisoryName;
            }

            if (affectsTrackersErrataEtId !== undefined) {
                localVarQueryParameter['affects__trackers__errata__et_id'] = affectsTrackersErrataEtId;
            }

            if (affectsTrackersErrataShippedDt !== undefined) {
                localVarQueryParameter['affects__trackers__errata__shipped_dt'] = (affectsTrackersErrataShippedDt as any instanceof Date) ?
                    (affectsTrackersErrataShippedDt as any).toISOString() :
                    affectsTrackersErrataShippedDt;
            }

            if (affectsTrackersErrataShippedDtDate !== undefined) {
                localVarQueryParameter['affects__trackers__errata__shipped_dt__date'] = (affectsTrackersErrataShippedDtDate as any instanceof Date) ?
                    (affectsTrackersErrataShippedDtDate as any).toISOString().substr(0,10) :
                    affectsTrackersErrataShippedDtDate;
            }

            if (affectsTrackersErrataShippedDtDateGte !== undefined) {
                localVarQueryParameter['affects__trackers__errata__shipped_dt__date__gte'] = (affectsTrackersErrataShippedDtDateGte as any instanceof Date) ?
                    (affectsTrackersErrataShippedDtDateGte as any).toISOString().substr(0,10) :
                    affectsTrackersErrataShippedDtDateGte;
            }

            if (affectsTrackersErrataShippedDtDateLte !== undefined) {
                localVarQueryParameter['affects__trackers__errata__shipped_dt__date__lte'] = (affectsTrackersErrataShippedDtDateLte as any instanceof Date) ?
                    (affectsTrackersErrataShippedDtDateLte as any).toISOString().substr(0,10) :
                    affectsTrackersErrataShippedDtDateLte;
            }

            if (affectsTrackersErrataShippedDtGt !== undefined) {
                localVarQueryParameter['affects__trackers__errata__shipped_dt__gt'] = (affectsTrackersErrataShippedDtGt as any instanceof Date) ?
                    (affectsTrackersErrataShippedDtGt as any).toISOString() :
                    affectsTrackersErrataShippedDtGt;
            }

            if (affectsTrackersErrataShippedDtGte !== undefined) {
                localVarQueryParameter['affects__trackers__errata__shipped_dt__gte'] = (affectsTrackersErrataShippedDtGte as any instanceof Date) ?
                    (affectsTrackersErrataShippedDtGte as any).toISOString() :
                    affectsTrackersErrataShippedDtGte;
            }

            if (affectsTrackersErrataShippedDtLt !== undefined) {
                localVarQueryParameter['affects__trackers__errata__shipped_dt__lt'] = (affectsTrackersErrataShippedDtLt as any instanceof Date) ?
                    (affectsTrackersErrataShippedDtLt as any).toISOString() :
                    affectsTrackersErrataShippedDtLt;
            }

            if (affectsTrackersErrataShippedDtLte !== undefined) {
                localVarQueryParameter['affects__trackers__errata__shipped_dt__lte'] = (affectsTrackersErrataShippedDtLte as any instanceof Date) ?
                    (affectsTrackersErrataShippedDtLte as any).toISOString() :
                    affectsTrackersErrataShippedDtLte;
            }

            if (affectsTrackersExternalSystemId !== undefined) {
                localVarQueryParameter['affects__trackers__external_system_id'] = affectsTrackersExternalSystemId;
            }

            if (affectsTrackersPsUpdateStream !== undefined) {
                localVarQueryParameter['affects__trackers__ps_update_stream'] = affectsTrackersPsUpdateStream;
            }

            if (affectsTrackersResolution !== undefined) {
                localVarQueryParameter['affects__trackers__resolution'] = affectsTrackersResolution;
            }

            if (affectsTrackersStatus !== undefined) {
                localVarQueryParameter['affects__trackers__status'] = affectsTrackersStatus;
            }

            if (affectsTrackersType !== undefined) {
                localVarQueryParameter['affects__trackers__type'] = affectsTrackersType;
            }

            if (affectsTrackersUpdatedDt !== undefined) {
                localVarQueryParameter['affects__trackers__updated_dt'] = (affectsTrackersUpdatedDt as any instanceof Date) ?
                    (affectsTrackersUpdatedDt as any).toISOString() :
                    affectsTrackersUpdatedDt;
            }

            if (affectsTrackersUpdatedDtDate !== undefined) {
                localVarQueryParameter['affects__trackers__updated_dt__date'] = (affectsTrackersUpdatedDtDate as any instanceof Date) ?
                    (affectsTrackersUpdatedDtDate as any).toISOString().substr(0,10) :
                    affectsTrackersUpdatedDtDate;
            }

            if (affectsTrackersUpdatedDtDateGte !== undefined) {
                localVarQueryParameter['affects__trackers__updated_dt__date__gte'] = (affectsTrackersUpdatedDtDateGte as any instanceof Date) ?
                    (affectsTrackersUpdatedDtDateGte as any).toISOString().substr(0,10) :
                    affectsTrackersUpdatedDtDateGte;
            }

            if (affectsTrackersUpdatedDtDateLte !== undefined) {
                localVarQueryParameter['affects__trackers__updated_dt__date__lte'] = (affectsTrackersUpdatedDtDateLte as any instanceof Date) ?
                    (affectsTrackersUpdatedDtDateLte as any).toISOString().substr(0,10) :
                    affectsTrackersUpdatedDtDateLte;
            }

            if (affectsTrackersUpdatedDtGt !== undefined) {
                localVarQueryParameter['affects__trackers__updated_dt__gt'] = (affectsTrackersUpdatedDtGt as any instanceof Date) ?
                    (affectsTrackersUpdatedDtGt as any).toISOString() :
                    affectsTrackersUpdatedDtGt;
            }

            if (affectsTrackersUpdatedDtGte !== undefined) {
                localVarQueryParameter['affects__trackers__updated_dt__gte'] = (affectsTrackersUpdatedDtGte as any instanceof Date) ?
                    (affectsTrackersUpdatedDtGte as any).toISOString() :
                    affectsTrackersUpdatedDtGte;
            }

            if (affectsTrackersUpdatedDtLt !== undefined) {
                localVarQueryParameter['affects__trackers__updated_dt__lt'] = (affectsTrackersUpdatedDtLt as any instanceof Date) ?
                    (affectsTrackersUpdatedDtLt as any).toISOString() :
                    affectsTrackersUpdatedDtLt;
            }

            if (affectsTrackersUpdatedDtLte !== undefined) {
                localVarQueryParameter['affects__trackers__updated_dt__lte'] = (affectsTrackersUpdatedDtLte as any instanceof Date) ?
                    (affectsTrackersUpdatedDtLte as any).toISOString() :
                    affectsTrackersUpdatedDtLte;
            }

            if (affectsTrackersUuid !== undefined) {
                localVarQueryParameter['affects__trackers__uuid'] = affectsTrackersUuid;
            }

            if (affectsType !== undefined) {
                localVarQueryParameter['affects__type'] = affectsType;
            }

            if (affectsUpdatedDt !== undefined) {
                localVarQueryParameter['affects__updated_dt'] = (affectsUpdatedDt as any instanceof Date) ?
                    (affectsUpdatedDt as any).toISOString() :
                    affectsUpdatedDt;
            }

            if (affectsUpdatedDtDate !== undefined) {
                localVarQueryParameter['affects__updated_dt__date'] = (affectsUpdatedDtDate as any instanceof Date) ?
                    (affectsUpdatedDtDate as any).toISOString().substr(0,10) :
                    affectsUpdatedDtDate;
            }

            if (affectsUpdatedDtDateGte !== undefined) {
                localVarQueryParameter['affects__updated_dt__date__gte'] = (affectsUpdatedDtDateGte as any instanceof Date) ?
                    (affectsUpdatedDtDateGte as any).toISOString().substr(0,10) :
                    affectsUpdatedDtDateGte;
            }

            if (affectsUpdatedDtDateLte !== undefined) {
                localVarQueryParameter['affects__updated_dt__date__lte'] = (affectsUpdatedDtDateLte as any instanceof Date) ?
                    (affectsUpdatedDtDateLte as any).toISOString().substr(0,10) :
                    affectsUpdatedDtDateLte;
            }

            if (affectsUpdatedDtGt !== undefined) {
                localVarQueryParameter['affects__updated_dt__gt'] = (affectsUpdatedDtGt as any instanceof Date) ?
                    (affectsUpdatedDtGt as any).toISOString() :
                    affectsUpdatedDtGt;
            }

            if (affectsUpdatedDtGte !== undefined) {
                localVarQueryParameter['affects__updated_dt__gte'] = (affectsUpdatedDtGte as any instanceof Date) ?
                    (affectsUpdatedDtGte as any).toISOString() :
                    affectsUpdatedDtGte;
            }

            if (affectsUpdatedDtLt !== undefined) {
                localVarQueryParameter['affects__updated_dt__lt'] = (affectsUpdatedDtLt as any instanceof Date) ?
                    (affectsUpdatedDtLt as any).toISOString() :
                    affectsUpdatedDtLt;
            }

            if (affectsUpdatedDtLte !== undefined) {
                localVarQueryParameter['affects__updated_dt__lte'] = (affectsUpdatedDtLte as any instanceof Date) ?
                    (affectsUpdatedDtLte as any).toISOString() :
                    affectsUpdatedDtLte;
            }

            if (affectsUuid !== undefined) {
                localVarQueryParameter['affects__uuid'] = affectsUuid;
            }

            if (bzId !== undefined) {
                localVarQueryParameter['bz_id'] = bzId;
            }

            if (changedAfter !== undefined) {
                localVarQueryParameter['changed_after'] = (changedAfter as any instanceof Date) ?
                    (changedAfter as any).toISOString() :
                    changedAfter;
            }

            if (changedBefore !== undefined) {
                localVarQueryParameter['changed_before'] = (changedBefore as any instanceof Date) ?
                    (changedBefore as any).toISOString() :
                    changedBefore;
            }

            if (component !== undefined) {
                localVarQueryParameter['component'] = component;
            }

            if (createdDt !== undefined) {
                localVarQueryParameter['created_dt'] = (createdDt as any instanceof Date) ?
                    (createdDt as any).toISOString() :
                    createdDt;
            }

            if (createdDtDate !== undefined) {
                localVarQueryParameter['created_dt__date'] = (createdDtDate as any instanceof Date) ?
                    (createdDtDate as any).toISOString().substr(0,10) :
                    createdDtDate;
            }

            if (createdDtDateGte !== undefined) {
                localVarQueryParameter['created_dt__date__gte'] = (createdDtDateGte as any instanceof Date) ?
                    (createdDtDateGte as any).toISOString().substr(0,10) :
                    createdDtDateGte;
            }

            if (createdDtDateLte !== undefined) {
                localVarQueryParameter['created_dt__date__lte'] = (createdDtDateLte as any instanceof Date) ?
                    (createdDtDateLte as any).toISOString().substr(0,10) :
                    createdDtDateLte;
            }

            if (createdDtGt !== undefined) {
                localVarQueryParameter['created_dt__gt'] = (createdDtGt as any instanceof Date) ?
                    (createdDtGt as any).toISOString() :
                    createdDtGt;
            }

            if (createdDtGte !== undefined) {
                localVarQueryParameter['created_dt__gte'] = (createdDtGte as any instanceof Date) ?
                    (createdDtGte as any).toISOString() :
                    createdDtGte;
            }

            if (createdDtLt !== undefined) {
                localVarQueryParameter['created_dt__lt'] = (createdDtLt as any instanceof Date) ?
                    (createdDtLt as any).toISOString() :
                    createdDtLt;
            }

            if (createdDtLte !== undefined) {
                localVarQueryParameter['created_dt__lte'] = (createdDtLte as any instanceof Date) ?
                    (createdDtLte as any).toISOString() :
                    createdDtLte;
            }

            if (cveId) {
                localVarQueryParameter['cve_id'] = cveId.join(COLLECTION_FORMATS.csv);
            }

            if (cvss2 !== undefined) {
                localVarQueryParameter['cvss2'] = cvss2;
            }

            if (cvss2Score !== undefined) {
                localVarQueryParameter['cvss2_score'] = cvss2Score;
            }

            if (cvss2ScoreGt !== undefined) {
                localVarQueryParameter['cvss2_score__gt'] = cvss2ScoreGt;
            }

            if (cvss2ScoreGte !== undefined) {
                localVarQueryParameter['cvss2_score__gte'] = cvss2ScoreGte;
            }

            if (cvss2ScoreLt !== undefined) {
                localVarQueryParameter['cvss2_score__lt'] = cvss2ScoreLt;
            }

            if (cvss2ScoreLte !== undefined) {
                localVarQueryParameter['cvss2_score__lte'] = cvss2ScoreLte;
            }

            if (cvss3 !== undefined) {
                localVarQueryParameter['cvss3'] = cvss3;
            }

            if (cvss3Score !== undefined) {
                localVarQueryParameter['cvss3_score'] = cvss3Score;
            }

            if (cvss3ScoreGt !== undefined) {
                localVarQueryParameter['cvss3_score__gt'] = cvss3ScoreGt;
            }

            if (cvss3ScoreGte !== undefined) {
                localVarQueryParameter['cvss3_score__gte'] = cvss3ScoreGte;
            }

            if (cvss3ScoreLt !== undefined) {
                localVarQueryParameter['cvss3_score__lt'] = cvss3ScoreLt;
            }

            if (cvss3ScoreLte !== undefined) {
                localVarQueryParameter['cvss3_score__lte'] = cvss3ScoreLte;
            }

            if (cvssScoresComment !== undefined) {
                localVarQueryParameter['cvss_scores__comment'] = cvssScoresComment;
            }

            if (cvssScoresCreatedDt !== undefined) {
                localVarQueryParameter['cvss_scores__created_dt'] = (cvssScoresCreatedDt as any instanceof Date) ?
                    (cvssScoresCreatedDt as any).toISOString() :
                    cvssScoresCreatedDt;
            }

            if (cvssScoresCreatedDtDate !== undefined) {
                localVarQueryParameter['cvss_scores__created_dt__date'] = (cvssScoresCreatedDtDate as any instanceof Date) ?
                    (cvssScoresCreatedDtDate as any).toISOString().substr(0,10) :
                    cvssScoresCreatedDtDate;
            }

            if (cvssScoresCreatedDtDateGte !== undefined) {
                localVarQueryParameter['cvss_scores__created_dt__date__gte'] = (cvssScoresCreatedDtDateGte as any instanceof Date) ?
                    (cvssScoresCreatedDtDateGte as any).toISOString().substr(0,10) :
                    cvssScoresCreatedDtDateGte;
            }

            if (cvssScoresCreatedDtDateLte !== undefined) {
                localVarQueryParameter['cvss_scores__created_dt__date__lte'] = (cvssScoresCreatedDtDateLte as any instanceof Date) ?
                    (cvssScoresCreatedDtDateLte as any).toISOString().substr(0,10) :
                    cvssScoresCreatedDtDateLte;
            }

            if (cvssScoresCreatedDtGt !== undefined) {
                localVarQueryParameter['cvss_scores__created_dt__gt'] = (cvssScoresCreatedDtGt as any instanceof Date) ?
                    (cvssScoresCreatedDtGt as any).toISOString() :
                    cvssScoresCreatedDtGt;
            }

            if (cvssScoresCreatedDtGte !== undefined) {
                localVarQueryParameter['cvss_scores__created_dt__gte'] = (cvssScoresCreatedDtGte as any instanceof Date) ?
                    (cvssScoresCreatedDtGte as any).toISOString() :
                    cvssScoresCreatedDtGte;
            }

            if (cvssScoresCreatedDtLt !== undefined) {
                localVarQueryParameter['cvss_scores__created_dt__lt'] = (cvssScoresCreatedDtLt as any instanceof Date) ?
                    (cvssScoresCreatedDtLt as any).toISOString() :
                    cvssScoresCreatedDtLt;
            }

            if (cvssScoresCreatedDtLte !== undefined) {
                localVarQueryParameter['cvss_scores__created_dt__lte'] = (cvssScoresCreatedDtLte as any instanceof Date) ?
                    (cvssScoresCreatedDtLte as any).toISOString() :
                    cvssScoresCreatedDtLte;
            }

            if (cvssScoresCvssVersion !== undefined) {
                localVarQueryParameter['cvss_scores__cvss_version'] = cvssScoresCvssVersion;
            }

            if (cvssScoresIssuer !== undefined) {
                localVarQueryParameter['cvss_scores__issuer'] = cvssScoresIssuer;
            }

            if (cvssScoresScore !== undefined) {
                localVarQueryParameter['cvss_scores__score'] = cvssScoresScore;
            }

            if (cvssScoresUpdatedDt !== undefined) {
                localVarQueryParameter['cvss_scores__updated_dt'] = (cvssScoresUpdatedDt as any instanceof Date) ?
                    (cvssScoresUpdatedDt as any).toISOString() :
                    cvssScoresUpdatedDt;
            }

            if (cvssScoresUpdatedDtDate !== undefined) {
                localVarQueryParameter['cvss_scores__updated_dt__date'] = (cvssScoresUpdatedDtDate as any instanceof Date) ?
                    (cvssScoresUpdatedDtDate as any).toISOString().substr(0,10) :
                    cvssScoresUpdatedDtDate;
            }

            if (cvssScoresUpdatedDtDateGte !== undefined) {
                localVarQueryParameter['cvss_scores__updated_dt__date__gte'] = (cvssScoresUpdatedDtDateGte as any instanceof Date) ?
                    (cvssScoresUpdatedDtDateGte as any).toISOString().substr(0,10) :
                    cvssScoresUpdatedDtDateGte;
            }

            if (cvssScoresUpdatedDtDateLte !== undefined) {
                localVarQueryParameter['cvss_scores__updated_dt__date__lte'] = (cvssScoresUpdatedDtDateLte as any instanceof Date) ?
                    (cvssScoresUpdatedDtDateLte as any).toISOString().substr(0,10) :
                    cvssScoresUpdatedDtDateLte;
            }

            if (cvssScoresUpdatedDtGt !== undefined) {
                localVarQueryParameter['cvss_scores__updated_dt__gt'] = (cvssScoresUpdatedDtGt as any instanceof Date) ?
                    (cvssScoresUpdatedDtGt as any).toISOString() :
                    cvssScoresUpdatedDtGt;
            }

            if (cvssScoresUpdatedDtGte !== undefined) {
                localVarQueryParameter['cvss_scores__updated_dt__gte'] = (cvssScoresUpdatedDtGte as any instanceof Date) ?
                    (cvssScoresUpdatedDtGte as any).toISOString() :
                    cvssScoresUpdatedDtGte;
            }

            if (cvssScoresUpdatedDtLt !== undefined) {
                localVarQueryParameter['cvss_scores__updated_dt__lt'] = (cvssScoresUpdatedDtLt as any instanceof Date) ?
                    (cvssScoresUpdatedDtLt as any).toISOString() :
                    cvssScoresUpdatedDtLt;
            }

            if (cvssScoresUpdatedDtLte !== undefined) {
                localVarQueryParameter['cvss_scores__updated_dt__lte'] = (cvssScoresUpdatedDtLte as any instanceof Date) ?
                    (cvssScoresUpdatedDtLte as any).toISOString() :
                    cvssScoresUpdatedDtLte;
            }

            if (cvssScoresUuid !== undefined) {
                localVarQueryParameter['cvss_scores__uuid'] = cvssScoresUuid;
            }

            if (cvssScoresVector !== undefined) {
                localVarQueryParameter['cvss_scores__vector'] = cvssScoresVector;
            }

            if (cweId !== undefined) {
                localVarQueryParameter['cwe_id'] = cweId;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (embargoed !== undefined) {
                localVarQueryParameter['embargoed'] = embargoed;
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (flawMetaType) {
                localVarQueryParameter['flaw_meta_type'] = flawMetaType;
            }

            if (impact !== undefined) {
                localVarQueryParameter['impact'] = impact;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }

            if (includeMetaAttr) {
                localVarQueryParameter['include_meta_attr'] = includeMetaAttr;
            }

            if (isMajorIncident !== undefined) {
                localVarQueryParameter['is_major_incident'] = isMajorIncident;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (majorIncidentState !== undefined) {
                localVarQueryParameter['major_incident_state'] = majorIncidentState;
            }

            if (nistCvssValidation !== undefined) {
                localVarQueryParameter['nist_cvss_validation'] = nistCvssValidation;
            }

            if (nvdCvss2 !== undefined) {
                localVarQueryParameter['nvd_cvss2'] = nvdCvss2;
            }

            if (nvdCvss3 !== undefined) {
                localVarQueryParameter['nvd_cvss3'] = nvdCvss3;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (order) {
                localVarQueryParameter['order'] = order.join(COLLECTION_FORMATS.csv);
            }

            if (referencesCreatedDt !== undefined) {
                localVarQueryParameter['references__created_dt'] = (referencesCreatedDt as any instanceof Date) ?
                    (referencesCreatedDt as any).toISOString() :
                    referencesCreatedDt;
            }

            if (referencesCreatedDtDate !== undefined) {
                localVarQueryParameter['references__created_dt__date'] = (referencesCreatedDtDate as any instanceof Date) ?
                    (referencesCreatedDtDate as any).toISOString().substr(0,10) :
                    referencesCreatedDtDate;
            }

            if (referencesCreatedDtDateGte !== undefined) {
                localVarQueryParameter['references__created_dt__date__gte'] = (referencesCreatedDtDateGte as any instanceof Date) ?
                    (referencesCreatedDtDateGte as any).toISOString().substr(0,10) :
                    referencesCreatedDtDateGte;
            }

            if (referencesCreatedDtDateLte !== undefined) {
                localVarQueryParameter['references__created_dt__date__lte'] = (referencesCreatedDtDateLte as any instanceof Date) ?
                    (referencesCreatedDtDateLte as any).toISOString().substr(0,10) :
                    referencesCreatedDtDateLte;
            }

            if (referencesCreatedDtGt !== undefined) {
                localVarQueryParameter['references__created_dt__gt'] = (referencesCreatedDtGt as any instanceof Date) ?
                    (referencesCreatedDtGt as any).toISOString() :
                    referencesCreatedDtGt;
            }

            if (referencesCreatedDtGte !== undefined) {
                localVarQueryParameter['references__created_dt__gte'] = (referencesCreatedDtGte as any instanceof Date) ?
                    (referencesCreatedDtGte as any).toISOString() :
                    referencesCreatedDtGte;
            }

            if (referencesCreatedDtLt !== undefined) {
                localVarQueryParameter['references__created_dt__lt'] = (referencesCreatedDtLt as any instanceof Date) ?
                    (referencesCreatedDtLt as any).toISOString() :
                    referencesCreatedDtLt;
            }

            if (referencesCreatedDtLte !== undefined) {
                localVarQueryParameter['references__created_dt__lte'] = (referencesCreatedDtLte as any instanceof Date) ?
                    (referencesCreatedDtLte as any).toISOString() :
                    referencesCreatedDtLte;
            }

            if (referencesDescription !== undefined) {
                localVarQueryParameter['references__description'] = referencesDescription;
            }

            if (referencesType !== undefined) {
                localVarQueryParameter['references__type'] = referencesType;
            }

            if (referencesUpdatedDt !== undefined) {
                localVarQueryParameter['references__updated_dt'] = (referencesUpdatedDt as any instanceof Date) ?
                    (referencesUpdatedDt as any).toISOString() :
                    referencesUpdatedDt;
            }

            if (referencesUpdatedDtDate !== undefined) {
                localVarQueryParameter['references__updated_dt__date'] = (referencesUpdatedDtDate as any instanceof Date) ?
                    (referencesUpdatedDtDate as any).toISOString().substr(0,10) :
                    referencesUpdatedDtDate;
            }

            if (referencesUpdatedDtDateGte !== undefined) {
                localVarQueryParameter['references__updated_dt__date__gte'] = (referencesUpdatedDtDateGte as any instanceof Date) ?
                    (referencesUpdatedDtDateGte as any).toISOString().substr(0,10) :
                    referencesUpdatedDtDateGte;
            }

            if (referencesUpdatedDtDateLte !== undefined) {
                localVarQueryParameter['references__updated_dt__date__lte'] = (referencesUpdatedDtDateLte as any instanceof Date) ?
                    (referencesUpdatedDtDateLte as any).toISOString().substr(0,10) :
                    referencesUpdatedDtDateLte;
            }

            if (referencesUpdatedDtGt !== undefined) {
                localVarQueryParameter['references__updated_dt__gt'] = (referencesUpdatedDtGt as any instanceof Date) ?
                    (referencesUpdatedDtGt as any).toISOString() :
                    referencesUpdatedDtGt;
            }

            if (referencesUpdatedDtGte !== undefined) {
                localVarQueryParameter['references__updated_dt__gte'] = (referencesUpdatedDtGte as any instanceof Date) ?
                    (referencesUpdatedDtGte as any).toISOString() :
                    referencesUpdatedDtGte;
            }

            if (referencesUpdatedDtLt !== undefined) {
                localVarQueryParameter['references__updated_dt__lt'] = (referencesUpdatedDtLt as any instanceof Date) ?
                    (referencesUpdatedDtLt as any).toISOString() :
                    referencesUpdatedDtLt;
            }

            if (referencesUpdatedDtLte !== undefined) {
                localVarQueryParameter['references__updated_dt__lte'] = (referencesUpdatedDtLte as any instanceof Date) ?
                    (referencesUpdatedDtLte as any).toISOString() :
                    referencesUpdatedDtLte;
            }

            if (referencesUrl !== undefined) {
                localVarQueryParameter['references__url'] = referencesUrl;
            }

            if (referencesUuid !== undefined) {
                localVarQueryParameter['references__uuid'] = referencesUuid;
            }

            if (reportedDt !== undefined) {
                localVarQueryParameter['reported_dt'] = (reportedDt as any instanceof Date) ?
                    (reportedDt as any).toISOString() :
                    reportedDt;
            }

            if (reportedDtDate !== undefined) {
                localVarQueryParameter['reported_dt__date'] = (reportedDtDate as any instanceof Date) ?
                    (reportedDtDate as any).toISOString().substr(0,10) :
                    reportedDtDate;
            }

            if (reportedDtDateGte !== undefined) {
                localVarQueryParameter['reported_dt__date__gte'] = (reportedDtDateGte as any instanceof Date) ?
                    (reportedDtDateGte as any).toISOString().substr(0,10) :
                    reportedDtDateGte;
            }

            if (reportedDtDateLte !== undefined) {
                localVarQueryParameter['reported_dt__date__lte'] = (reportedDtDateLte as any instanceof Date) ?
                    (reportedDtDateLte as any).toISOString().substr(0,10) :
                    reportedDtDateLte;
            }

            if (reportedDtGt !== undefined) {
                localVarQueryParameter['reported_dt__gt'] = (reportedDtGt as any instanceof Date) ?
                    (reportedDtGt as any).toISOString() :
                    reportedDtGt;
            }

            if (reportedDtGte !== undefined) {
                localVarQueryParameter['reported_dt__gte'] = (reportedDtGte as any instanceof Date) ?
                    (reportedDtGte as any).toISOString() :
                    reportedDtGte;
            }

            if (reportedDtLt !== undefined) {
                localVarQueryParameter['reported_dt__lt'] = (reportedDtLt as any instanceof Date) ?
                    (reportedDtLt as any).toISOString() :
                    reportedDtLt;
            }

            if (reportedDtLte !== undefined) {
                localVarQueryParameter['reported_dt__lte'] = (reportedDtLte as any instanceof Date) ?
                    (reportedDtLte as any).toISOString() :
                    reportedDtLte;
            }

            if (requiresSummary !== undefined) {
                localVarQueryParameter['requires_summary'] = requiresSummary;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (statement !== undefined) {
                localVarQueryParameter['statement'] = statement;
            }

            if (summary !== undefined) {
                localVarQueryParameter['summary'] = summary;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (trackerIds) {
                localVarQueryParameter['tracker_ids'] = trackerIds;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (unembargoDt !== undefined) {
                localVarQueryParameter['unembargo_dt'] = (unembargoDt as any instanceof Date) ?
                    (unembargoDt as any).toISOString() :
                    unembargoDt;
            }

            if (updatedDt !== undefined) {
                localVarQueryParameter['updated_dt'] = (updatedDt as any instanceof Date) ?
                    (updatedDt as any).toISOString() :
                    updatedDt;
            }

            if (updatedDtDate !== undefined) {
                localVarQueryParameter['updated_dt__date'] = (updatedDtDate as any instanceof Date) ?
                    (updatedDtDate as any).toISOString().substr(0,10) :
                    updatedDtDate;
            }

            if (updatedDtDateGte !== undefined) {
                localVarQueryParameter['updated_dt__date__gte'] = (updatedDtDateGte as any instanceof Date) ?
                    (updatedDtDateGte as any).toISOString().substr(0,10) :
                    updatedDtDateGte;
            }

            if (updatedDtDateLte !== undefined) {
                localVarQueryParameter['updated_dt__date__lte'] = (updatedDtDateLte as any instanceof Date) ?
                    (updatedDtDateLte as any).toISOString().substr(0,10) :
                    updatedDtDateLte;
            }

            if (updatedDtGt !== undefined) {
                localVarQueryParameter['updated_dt__gt'] = (updatedDtGt as any instanceof Date) ?
                    (updatedDtGt as any).toISOString() :
                    updatedDtGt;
            }

            if (updatedDtGte !== undefined) {
                localVarQueryParameter['updated_dt__gte'] = (updatedDtGte as any instanceof Date) ?
                    (updatedDtGte as any).toISOString() :
                    updatedDtGte;
            }

            if (updatedDtLt !== undefined) {
                localVarQueryParameter['updated_dt__lt'] = (updatedDtLt as any instanceof Date) ?
                    (updatedDtLt as any).toISOString() :
                    updatedDtLt;
            }

            if (updatedDtLte !== undefined) {
                localVarQueryParameter['updated_dt__lte'] = (updatedDtLte as any instanceof Date) ?
                    (updatedDtLte as any).toISOString() :
                    updatedDtLte;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} flawId 
         * @param {FlawPackageVersionPost} flawPackageVersionPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsPackageVersionsCreate: async (flawId: string, flawPackageVersionPost: FlawPackageVersionPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsPackageVersionsCreate', 'flawId', flawId)
            // verify required parameter 'flawPackageVersionPost' is not null or undefined
            assertParamExists('osidbApiV1FlawsPackageVersionsCreate', 'flawPackageVersionPost', flawPackageVersionPost)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/package_versions`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flawPackageVersionPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Destroy the instance and proxy the delete to Bugzilla
         * @param {string} flawId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsPackageVersionsDestroy: async (flawId: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsPackageVersionsDestroy', 'flawId', flawId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osidbApiV1FlawsPackageVersionsDestroy', 'id', id)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/package_versions/{id}`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [_package] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {string} [versionsVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsPackageVersionsList: async (flawId: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, excludeFields?: Array<string>, includeFields?: Array<string>, limit?: number, offset?: number, _package?: string, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, versionsVersion?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsPackageVersionsList', 'flawId', flawId)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/package_versions`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (createdDt !== undefined) {
                localVarQueryParameter['created_dt'] = (createdDt as any instanceof Date) ?
                    (createdDt as any).toISOString() :
                    createdDt;
            }

            if (createdDtDate !== undefined) {
                localVarQueryParameter['created_dt__date'] = (createdDtDate as any instanceof Date) ?
                    (createdDtDate as any).toISOString().substr(0,10) :
                    createdDtDate;
            }

            if (createdDtDateGte !== undefined) {
                localVarQueryParameter['created_dt__date__gte'] = (createdDtDateGte as any instanceof Date) ?
                    (createdDtDateGte as any).toISOString().substr(0,10) :
                    createdDtDateGte;
            }

            if (createdDtDateLte !== undefined) {
                localVarQueryParameter['created_dt__date__lte'] = (createdDtDateLte as any instanceof Date) ?
                    (createdDtDateLte as any).toISOString().substr(0,10) :
                    createdDtDateLte;
            }

            if (createdDtGt !== undefined) {
                localVarQueryParameter['created_dt__gt'] = (createdDtGt as any instanceof Date) ?
                    (createdDtGt as any).toISOString() :
                    createdDtGt;
            }

            if (createdDtGte !== undefined) {
                localVarQueryParameter['created_dt__gte'] = (createdDtGte as any instanceof Date) ?
                    (createdDtGte as any).toISOString() :
                    createdDtGte;
            }

            if (createdDtLt !== undefined) {
                localVarQueryParameter['created_dt__lt'] = (createdDtLt as any instanceof Date) ?
                    (createdDtLt as any).toISOString() :
                    createdDtLt;
            }

            if (createdDtLte !== undefined) {
                localVarQueryParameter['created_dt__lte'] = (createdDtLte as any instanceof Date) ?
                    (createdDtLte as any).toISOString() :
                    createdDtLte;
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (_package !== undefined) {
                localVarQueryParameter['package'] = _package;
            }

            if (updatedDt !== undefined) {
                localVarQueryParameter['updated_dt'] = (updatedDt as any instanceof Date) ?
                    (updatedDt as any).toISOString() :
                    updatedDt;
            }

            if (updatedDtDate !== undefined) {
                localVarQueryParameter['updated_dt__date'] = (updatedDtDate as any instanceof Date) ?
                    (updatedDtDate as any).toISOString().substr(0,10) :
                    updatedDtDate;
            }

            if (updatedDtDateGte !== undefined) {
                localVarQueryParameter['updated_dt__date__gte'] = (updatedDtDateGte as any instanceof Date) ?
                    (updatedDtDateGte as any).toISOString().substr(0,10) :
                    updatedDtDateGte;
            }

            if (updatedDtDateLte !== undefined) {
                localVarQueryParameter['updated_dt__date__lte'] = (updatedDtDateLte as any instanceof Date) ?
                    (updatedDtDateLte as any).toISOString().substr(0,10) :
                    updatedDtDateLte;
            }

            if (updatedDtGt !== undefined) {
                localVarQueryParameter['updated_dt__gt'] = (updatedDtGt as any instanceof Date) ?
                    (updatedDtGt as any).toISOString() :
                    updatedDtGt;
            }

            if (updatedDtGte !== undefined) {
                localVarQueryParameter['updated_dt__gte'] = (updatedDtGte as any instanceof Date) ?
                    (updatedDtGte as any).toISOString() :
                    updatedDtGte;
            }

            if (updatedDtLt !== undefined) {
                localVarQueryParameter['updated_dt__lt'] = (updatedDtLt as any instanceof Date) ?
                    (updatedDtLt as any).toISOString() :
                    updatedDtLt;
            }

            if (updatedDtLte !== undefined) {
                localVarQueryParameter['updated_dt__lte'] = (updatedDtLte as any instanceof Date) ?
                    (updatedDtLte as any).toISOString() :
                    updatedDtLte;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (versionsVersion !== undefined) {
                localVarQueryParameter['versions__version'] = versionsVersion;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} id 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsPackageVersionsRetrieve: async (flawId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsPackageVersionsRetrieve', 'flawId', flawId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osidbApiV1FlawsPackageVersionsRetrieve', 'id', id)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/package_versions/{id}`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} id 
         * @param {FlawPackageVersionPut} flawPackageVersionPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsPackageVersionsUpdate: async (flawId: string, id: string, flawPackageVersionPut: FlawPackageVersionPut, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsPackageVersionsUpdate', 'flawId', flawId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osidbApiV1FlawsPackageVersionsUpdate', 'id', id)
            // verify required parameter 'flawPackageVersionPut' is not null or undefined
            assertParamExists('osidbApiV1FlawsPackageVersionsUpdate', 'flawPackageVersionPut', flawPackageVersionPut)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/package_versions/{id}`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flawPackageVersionPut, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} flawId 
         * @param {FlawReferencePost} flawReferencePost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsReferencesCreate: async (flawId: string, flawReferencePost: FlawReferencePost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsReferencesCreate', 'flawId', flawId)
            // verify required parameter 'flawReferencePost' is not null or undefined
            assertParamExists('osidbApiV1FlawsReferencesCreate', 'flawReferencePost', flawReferencePost)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/references`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flawReferencePost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Destroy the instance and proxy the delete to Bugzilla
         * @param {string} flawId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsReferencesDestroy: async (flawId: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsReferencesDestroy', 'flawId', flawId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osidbApiV1FlawsReferencesDestroy', 'id', id)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/references/{id}`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {string} [description] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {'ARTICLE' | 'EXTERNAL' | 'SOURCE'} [type] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [url] 
         * @param {string} [uuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsReferencesList: async (flawId: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, description?: string, excludeFields?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, limit?: number, offset?: number, type?: 'ARTICLE' | 'EXTERNAL' | 'SOURCE', updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, url?: string, uuid?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsReferencesList', 'flawId', flawId)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/references`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (createdDt !== undefined) {
                localVarQueryParameter['created_dt'] = (createdDt as any instanceof Date) ?
                    (createdDt as any).toISOString() :
                    createdDt;
            }

            if (createdDtDate !== undefined) {
                localVarQueryParameter['created_dt__date'] = (createdDtDate as any instanceof Date) ?
                    (createdDtDate as any).toISOString().substr(0,10) :
                    createdDtDate;
            }

            if (createdDtDateGte !== undefined) {
                localVarQueryParameter['created_dt__date__gte'] = (createdDtDateGte as any instanceof Date) ?
                    (createdDtDateGte as any).toISOString().substr(0,10) :
                    createdDtDateGte;
            }

            if (createdDtDateLte !== undefined) {
                localVarQueryParameter['created_dt__date__lte'] = (createdDtDateLte as any instanceof Date) ?
                    (createdDtDateLte as any).toISOString().substr(0,10) :
                    createdDtDateLte;
            }

            if (createdDtGt !== undefined) {
                localVarQueryParameter['created_dt__gt'] = (createdDtGt as any instanceof Date) ?
                    (createdDtGt as any).toISOString() :
                    createdDtGt;
            }

            if (createdDtGte !== undefined) {
                localVarQueryParameter['created_dt__gte'] = (createdDtGte as any instanceof Date) ?
                    (createdDtGte as any).toISOString() :
                    createdDtGte;
            }

            if (createdDtLt !== undefined) {
                localVarQueryParameter['created_dt__lt'] = (createdDtLt as any instanceof Date) ?
                    (createdDtLt as any).toISOString() :
                    createdDtLt;
            }

            if (createdDtLte !== undefined) {
                localVarQueryParameter['created_dt__lte'] = (createdDtLte as any instanceof Date) ?
                    (createdDtLte as any).toISOString() :
                    createdDtLte;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }

            if (includeMetaAttr) {
                localVarQueryParameter['include_meta_attr'] = includeMetaAttr;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (updatedDt !== undefined) {
                localVarQueryParameter['updated_dt'] = (updatedDt as any instanceof Date) ?
                    (updatedDt as any).toISOString() :
                    updatedDt;
            }

            if (updatedDtDate !== undefined) {
                localVarQueryParameter['updated_dt__date'] = (updatedDtDate as any instanceof Date) ?
                    (updatedDtDate as any).toISOString().substr(0,10) :
                    updatedDtDate;
            }

            if (updatedDtDateGte !== undefined) {
                localVarQueryParameter['updated_dt__date__gte'] = (updatedDtDateGte as any instanceof Date) ?
                    (updatedDtDateGte as any).toISOString().substr(0,10) :
                    updatedDtDateGte;
            }

            if (updatedDtDateLte !== undefined) {
                localVarQueryParameter['updated_dt__date__lte'] = (updatedDtDateLte as any instanceof Date) ?
                    (updatedDtDateLte as any).toISOString().substr(0,10) :
                    updatedDtDateLte;
            }

            if (updatedDtGt !== undefined) {
                localVarQueryParameter['updated_dt__gt'] = (updatedDtGt as any instanceof Date) ?
                    (updatedDtGt as any).toISOString() :
                    updatedDtGt;
            }

            if (updatedDtGte !== undefined) {
                localVarQueryParameter['updated_dt__gte'] = (updatedDtGte as any instanceof Date) ?
                    (updatedDtGte as any).toISOString() :
                    updatedDtGte;
            }

            if (updatedDtLt !== undefined) {
                localVarQueryParameter['updated_dt__lt'] = (updatedDtLt as any instanceof Date) ?
                    (updatedDtLt as any).toISOString() :
                    updatedDtLt;
            }

            if (updatedDtLte !== undefined) {
                localVarQueryParameter['updated_dt__lte'] = (updatedDtLte as any instanceof Date) ?
                    (updatedDtLte as any).toISOString() :
                    updatedDtLte;
            }

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} id 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsReferencesRetrieve: async (flawId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsReferencesRetrieve', 'flawId', flawId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osidbApiV1FlawsReferencesRetrieve', 'id', id)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/references/{id}`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }

            if (includeMetaAttr) {
                localVarQueryParameter['include_meta_attr'] = includeMetaAttr;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} id 
         * @param {FlawReferencePut} flawReferencePut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsReferencesUpdate: async (flawId: string, id: string, flawReferencePut: FlawReferencePut, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsReferencesUpdate', 'flawId', flawId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osidbApiV1FlawsReferencesUpdate', 'id', id)
            // verify required parameter 'flawReferencePut' is not null or undefined
            assertParamExists('osidbApiV1FlawsReferencesUpdate', 'flawReferencePut', flawReferencePut)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/references/{id}`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flawReferencePut, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [flawMetaType] Include flaw metas with specified type only, multiple values may be separated by commas. 
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {Array<string>} [trackerIds] Filter only Flaws which are related to specified Trackers (through Affects). Multiple tracker IDs may be separated by commas. Also only Affects that have the specified Trackers related will be shown.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsRetrieve: async (id: string, excludeFields?: Array<string>, flawMetaType?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, trackerIds?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osidbApiV1FlawsRetrieve', 'id', id)
            const localVarPath = `/osidb/api/v1/flaws/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (flawMetaType) {
                localVarQueryParameter['flaw_meta_type'] = flawMetaType;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }

            if (includeMetaAttr) {
                localVarQueryParameter['include_meta_attr'] = includeMetaAttr;
            }

            if (trackerIds) {
                localVarQueryParameter['tracker_ids'] = trackerIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {string} id A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
         * @param {Flaw} flaw 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsUpdate: async (bugzillaApiKey: string, jiraApiKey: string, id: string, flaw: Flaw, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bugzillaApiKey' is not null or undefined
            assertParamExists('osidbApiV1FlawsUpdate', 'bugzillaApiKey', bugzillaApiKey)
            // verify required parameter 'jiraApiKey' is not null or undefined
            assertParamExists('osidbApiV1FlawsUpdate', 'jiraApiKey', jiraApiKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osidbApiV1FlawsUpdate', 'id', id)
            // verify required parameter 'flaw' is not null or undefined
            assertParamExists('osidbApiV1FlawsUpdate', 'flaw', flaw)
            const localVarPath = `/osidb/api/v1/flaws/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (bugzillaApiKey != null) {
                localVarHeaderParameter['Bugzilla-Api-Key'] = String(bugzillaApiKey);
            }

            if (jiraApiKey != null) {
                localVarHeaderParameter['Jira-Api-Key'] = String(jiraApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flaw, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HTTP get /manifest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1ManifestRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/osidb/api/v1/manifest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {'json' | 'yaml'} [format] 
         * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1SchemaRetrieve: async (format?: 'json' | 'yaml', lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/osidb/api/v1/schema/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication KerberosAuthentication required

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HTTP get /status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1StatusRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/osidb/api/v1/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {TrackerPost} trackerPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1TrackersCreate: async (bugzillaApiKey: string, jiraApiKey: string, trackerPost: TrackerPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bugzillaApiKey' is not null or undefined
            assertParamExists('osidbApiV1TrackersCreate', 'bugzillaApiKey', bugzillaApiKey)
            // verify required parameter 'jiraApiKey' is not null or undefined
            assertParamExists('osidbApiV1TrackersCreate', 'jiraApiKey', jiraApiKey)
            // verify required parameter 'trackerPost' is not null or undefined
            assertParamExists('osidbApiV1TrackersCreate', 'trackerPost', trackerPost)
            const localVarPath = `/osidb/api/v1/trackers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (bugzillaApiKey != null) {
                localVarHeaderParameter['Bugzilla-Api-Key'] = String(bugzillaApiKey);
            }

            if (jiraApiKey != null) {
                localVarHeaderParameter['Jira-Api-Key'] = String(jiraApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trackerPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {'' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED'} [affectsAffectedness] 
         * @param {string} [affectsCreatedDt] 
         * @param {string} [affectsCreatedDtDate] 
         * @param {string} [affectsCreatedDtDateGte] 
         * @param {string} [affectsCreatedDtDateLte] 
         * @param {string} [affectsCreatedDtGt] 
         * @param {string} [affectsCreatedDtGte] 
         * @param {string} [affectsCreatedDtLt] 
         * @param {string} [affectsCreatedDtLte] 
         * @param {string} [affectsCvss2] 
         * @param {number} [affectsCvss2Score] 
         * @param {number} [affectsCvss2ScoreGt] 
         * @param {number} [affectsCvss2ScoreGte] 
         * @param {number} [affectsCvss2ScoreLt] 
         * @param {number} [affectsCvss2ScoreLte] 
         * @param {string} [affectsCvss3] 
         * @param {number} [affectsCvss3Score] 
         * @param {number} [affectsCvss3ScoreGt] 
         * @param {number} [affectsCvss3ScoreGte] 
         * @param {number} [affectsCvss3ScoreLt] 
         * @param {number} [affectsCvss3ScoreLte] 
         * @param {boolean} [affectsEmbargoed] 
         * @param {string} [affectsFlawComponent] 
         * @param {string} [affectsFlawCreatedDt] 
         * @param {string} [affectsFlawCreatedDtDate] 
         * @param {string} [affectsFlawCreatedDtDateGte] 
         * @param {string} [affectsFlawCreatedDtDateLte] 
         * @param {string} [affectsFlawCreatedDtGt] 
         * @param {string} [affectsFlawCreatedDtGte] 
         * @param {string} [affectsFlawCreatedDtLt] 
         * @param {string} [affectsFlawCreatedDtLte] 
         * @param {string} [affectsFlawCveId] 
         * @param {string} [affectsFlawCvss2] 
         * @param {number} [affectsFlawCvss2Score] 
         * @param {number} [affectsFlawCvss2ScoreGt] 
         * @param {number} [affectsFlawCvss2ScoreGte] 
         * @param {number} [affectsFlawCvss2ScoreLt] 
         * @param {number} [affectsFlawCvss2ScoreLte] 
         * @param {string} [affectsFlawCvss3] 
         * @param {number} [affectsFlawCvss3Score] 
         * @param {number} [affectsFlawCvss3ScoreGt] 
         * @param {number} [affectsFlawCvss3ScoreGte] 
         * @param {number} [affectsFlawCvss3ScoreLt] 
         * @param {number} [affectsFlawCvss3ScoreLte] 
         * @param {string} [affectsFlawCweId] 
         * @param {boolean} [affectsFlawEmbargoed] 
         * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [affectsFlawImpact] 
         * @param {boolean} [affectsFlawIsMajorIncident] 
         * @param {string} [affectsFlawNvdCvss2] 
         * @param {string} [affectsFlawNvdCvss3] 
         * @param {string} [affectsFlawReportedDt] 
         * @param {string} [affectsFlawReportedDtDate] 
         * @param {string} [affectsFlawReportedDtDateGte] 
         * @param {string} [affectsFlawReportedDtDateLte] 
         * @param {string} [affectsFlawReportedDtGt] 
         * @param {string} [affectsFlawReportedDtGte] 
         * @param {string} [affectsFlawReportedDtLt] 
         * @param {string} [affectsFlawReportedDtLte] 
         * @param {'' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF'} [affectsFlawSource] 
         * @param {'VULNERABILITY' | 'WEAKNESS'} [affectsFlawType] 
         * @param {string} [affectsFlawUnembargoDt] 
         * @param {string} [affectsFlawUpdatedDt] 
         * @param {string} [affectsFlawUpdatedDtDate] 
         * @param {string} [affectsFlawUpdatedDtDateGte] 
         * @param {string} [affectsFlawUpdatedDtDateLte] 
         * @param {string} [affectsFlawUpdatedDtGt] 
         * @param {string} [affectsFlawUpdatedDtGte] 
         * @param {string} [affectsFlawUpdatedDtLt] 
         * @param {string} [affectsFlawUpdatedDtLte] 
         * @param {string} [affectsFlawUuid] 
         * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [affectsImpact] 
         * @param {string} [affectsPsComponent] 
         * @param {string} [affectsPsModule] 
         * @param {'' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT'} [affectsResolution] 
         * @param {'DEFAULT'} [affectsType] 
         * @param {string} [affectsUpdatedDt] 
         * @param {string} [affectsUpdatedDtDate] 
         * @param {string} [affectsUpdatedDtDateGte] 
         * @param {string} [affectsUpdatedDtDateLte] 
         * @param {string} [affectsUpdatedDtGt] 
         * @param {string} [affectsUpdatedDtGte] 
         * @param {string} [affectsUpdatedDtLt] 
         * @param {string} [affectsUpdatedDtLte] 
         * @param {string} [affectsUuid] 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {boolean} [embargoed] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {string} [externalSystemId] 
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {Array<'-affects__affectedness' | '-affects__created_dt' | '-affects__cvss2' | '-affects__cvss2_score' | '-affects__cvss3' | '-affects__cvss3_score' | '-affects__flaw__component' | '-affects__flaw__created_dt' | '-affects__flaw__cve_id' | '-affects__flaw__cvss2' | '-affects__flaw__cvss2_score' | '-affects__flaw__cvss3' | '-affects__flaw__cvss3_score' | '-affects__flaw__cwe_id' | '-affects__flaw__impact' | '-affects__flaw__nvd_cvss2' | '-affects__flaw__nvd_cvss3' | '-affects__flaw__reported_dt' | '-affects__flaw__source' | '-affects__flaw__type' | '-affects__flaw__unembargo_dt' | '-affects__flaw__updated_dt' | '-affects__flaw__uuid' | '-affects__impact' | '-affects__ps_component' | '-affects__ps_module' | '-affects__resolution' | '-affects__type' | '-affects__updated_dt' | '-affects__uuid' | '-created_dt' | '-external_system_id' | '-ps_update_stream' | '-resolution' | '-status' | '-type' | '-updated_dt' | '-uuid' | 'affects__affectedness' | 'affects__created_dt' | 'affects__cvss2' | 'affects__cvss2_score' | 'affects__cvss3' | 'affects__cvss3_score' | 'affects__flaw__component' | 'affects__flaw__created_dt' | 'affects__flaw__cve_id' | 'affects__flaw__cvss2' | 'affects__flaw__cvss2_score' | 'affects__flaw__cvss3' | 'affects__flaw__cvss3_score' | 'affects__flaw__cwe_id' | 'affects__flaw__impact' | 'affects__flaw__nvd_cvss2' | 'affects__flaw__nvd_cvss3' | 'affects__flaw__reported_dt' | 'affects__flaw__source' | 'affects__flaw__type' | 'affects__flaw__unembargo_dt' | 'affects__flaw__updated_dt' | 'affects__flaw__uuid' | 'affects__impact' | 'affects__ps_component' | 'affects__ps_module' | 'affects__resolution' | 'affects__type' | 'affects__updated_dt' | 'affects__uuid' | 'created_dt' | 'external_system_id' | 'ps_update_stream' | 'resolution' | 'status' | 'type' | 'updated_dt' | 'uuid'>} [order] Ordering
         * @param {string} [psUpdateStream] 
         * @param {string} [resolution] 
         * @param {string} [status] 
         * @param {'BUGZILLA' | 'JIRA'} [type] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1TrackersList: async (affectsAffectedness?: '' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED', affectsCreatedDt?: string, affectsCreatedDtDate?: string, affectsCreatedDtDateGte?: string, affectsCreatedDtDateLte?: string, affectsCreatedDtGt?: string, affectsCreatedDtGte?: string, affectsCreatedDtLt?: string, affectsCreatedDtLte?: string, affectsCvss2?: string, affectsCvss2Score?: number, affectsCvss2ScoreGt?: number, affectsCvss2ScoreGte?: number, affectsCvss2ScoreLt?: number, affectsCvss2ScoreLte?: number, affectsCvss3?: string, affectsCvss3Score?: number, affectsCvss3ScoreGt?: number, affectsCvss3ScoreGte?: number, affectsCvss3ScoreLt?: number, affectsCvss3ScoreLte?: number, affectsEmbargoed?: boolean, affectsFlawComponent?: string, affectsFlawCreatedDt?: string, affectsFlawCreatedDtDate?: string, affectsFlawCreatedDtDateGte?: string, affectsFlawCreatedDtDateLte?: string, affectsFlawCreatedDtGt?: string, affectsFlawCreatedDtGte?: string, affectsFlawCreatedDtLt?: string, affectsFlawCreatedDtLte?: string, affectsFlawCveId?: string, affectsFlawCvss2?: string, affectsFlawCvss2Score?: number, affectsFlawCvss2ScoreGt?: number, affectsFlawCvss2ScoreGte?: number, affectsFlawCvss2ScoreLt?: number, affectsFlawCvss2ScoreLte?: number, affectsFlawCvss3?: string, affectsFlawCvss3Score?: number, affectsFlawCvss3ScoreGt?: number, affectsFlawCvss3ScoreGte?: number, affectsFlawCvss3ScoreLt?: number, affectsFlawCvss3ScoreLte?: number, affectsFlawCweId?: string, affectsFlawEmbargoed?: boolean, affectsFlawImpact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', affectsFlawIsMajorIncident?: boolean, affectsFlawNvdCvss2?: string, affectsFlawNvdCvss3?: string, affectsFlawReportedDt?: string, affectsFlawReportedDtDate?: string, affectsFlawReportedDtDateGte?: string, affectsFlawReportedDtDateLte?: string, affectsFlawReportedDtGt?: string, affectsFlawReportedDtGte?: string, affectsFlawReportedDtLt?: string, affectsFlawReportedDtLte?: string, affectsFlawSource?: '' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF', affectsFlawType?: 'VULNERABILITY' | 'WEAKNESS', affectsFlawUnembargoDt?: string, affectsFlawUpdatedDt?: string, affectsFlawUpdatedDtDate?: string, affectsFlawUpdatedDtDateGte?: string, affectsFlawUpdatedDtDateLte?: string, affectsFlawUpdatedDtGt?: string, affectsFlawUpdatedDtGte?: string, affectsFlawUpdatedDtLt?: string, affectsFlawUpdatedDtLte?: string, affectsFlawUuid?: string, affectsImpact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', affectsPsComponent?: string, affectsPsModule?: string, affectsResolution?: '' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT', affectsType?: 'DEFAULT', affectsUpdatedDt?: string, affectsUpdatedDtDate?: string, affectsUpdatedDtDateGte?: string, affectsUpdatedDtDateLte?: string, affectsUpdatedDtGt?: string, affectsUpdatedDtGte?: string, affectsUpdatedDtLt?: string, affectsUpdatedDtLte?: string, affectsUuid?: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, embargoed?: boolean, excludeFields?: Array<string>, externalSystemId?: string, includeFields?: Array<string>, includeMetaAttr?: Array<string>, limit?: number, offset?: number, order?: Array<'-affects__affectedness' | '-affects__created_dt' | '-affects__cvss2' | '-affects__cvss2_score' | '-affects__cvss3' | '-affects__cvss3_score' | '-affects__flaw__component' | '-affects__flaw__created_dt' | '-affects__flaw__cve_id' | '-affects__flaw__cvss2' | '-affects__flaw__cvss2_score' | '-affects__flaw__cvss3' | '-affects__flaw__cvss3_score' | '-affects__flaw__cwe_id' | '-affects__flaw__impact' | '-affects__flaw__nvd_cvss2' | '-affects__flaw__nvd_cvss3' | '-affects__flaw__reported_dt' | '-affects__flaw__source' | '-affects__flaw__type' | '-affects__flaw__unembargo_dt' | '-affects__flaw__updated_dt' | '-affects__flaw__uuid' | '-affects__impact' | '-affects__ps_component' | '-affects__ps_module' | '-affects__resolution' | '-affects__type' | '-affects__updated_dt' | '-affects__uuid' | '-created_dt' | '-external_system_id' | '-ps_update_stream' | '-resolution' | '-status' | '-type' | '-updated_dt' | '-uuid' | 'affects__affectedness' | 'affects__created_dt' | 'affects__cvss2' | 'affects__cvss2_score' | 'affects__cvss3' | 'affects__cvss3_score' | 'affects__flaw__component' | 'affects__flaw__created_dt' | 'affects__flaw__cve_id' | 'affects__flaw__cvss2' | 'affects__flaw__cvss2_score' | 'affects__flaw__cvss3' | 'affects__flaw__cvss3_score' | 'affects__flaw__cwe_id' | 'affects__flaw__impact' | 'affects__flaw__nvd_cvss2' | 'affects__flaw__nvd_cvss3' | 'affects__flaw__reported_dt' | 'affects__flaw__source' | 'affects__flaw__type' | 'affects__flaw__unembargo_dt' | 'affects__flaw__updated_dt' | 'affects__flaw__uuid' | 'affects__impact' | 'affects__ps_component' | 'affects__ps_module' | 'affects__resolution' | 'affects__type' | 'affects__updated_dt' | 'affects__uuid' | 'created_dt' | 'external_system_id' | 'ps_update_stream' | 'resolution' | 'status' | 'type' | 'updated_dt' | 'uuid'>, psUpdateStream?: string, resolution?: string, status?: string, type?: 'BUGZILLA' | 'JIRA', updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/osidb/api/v1/trackers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (affectsAffectedness !== undefined) {
                localVarQueryParameter['affects__affectedness'] = affectsAffectedness;
            }

            if (affectsCreatedDt !== undefined) {
                localVarQueryParameter['affects__created_dt'] = (affectsCreatedDt as any instanceof Date) ?
                    (affectsCreatedDt as any).toISOString() :
                    affectsCreatedDt;
            }

            if (affectsCreatedDtDate !== undefined) {
                localVarQueryParameter['affects__created_dt__date'] = (affectsCreatedDtDate as any instanceof Date) ?
                    (affectsCreatedDtDate as any).toISOString().substr(0,10) :
                    affectsCreatedDtDate;
            }

            if (affectsCreatedDtDateGte !== undefined) {
                localVarQueryParameter['affects__created_dt__date__gte'] = (affectsCreatedDtDateGte as any instanceof Date) ?
                    (affectsCreatedDtDateGte as any).toISOString().substr(0,10) :
                    affectsCreatedDtDateGte;
            }

            if (affectsCreatedDtDateLte !== undefined) {
                localVarQueryParameter['affects__created_dt__date__lte'] = (affectsCreatedDtDateLte as any instanceof Date) ?
                    (affectsCreatedDtDateLte as any).toISOString().substr(0,10) :
                    affectsCreatedDtDateLte;
            }

            if (affectsCreatedDtGt !== undefined) {
                localVarQueryParameter['affects__created_dt__gt'] = (affectsCreatedDtGt as any instanceof Date) ?
                    (affectsCreatedDtGt as any).toISOString() :
                    affectsCreatedDtGt;
            }

            if (affectsCreatedDtGte !== undefined) {
                localVarQueryParameter['affects__created_dt__gte'] = (affectsCreatedDtGte as any instanceof Date) ?
                    (affectsCreatedDtGte as any).toISOString() :
                    affectsCreatedDtGte;
            }

            if (affectsCreatedDtLt !== undefined) {
                localVarQueryParameter['affects__created_dt__lt'] = (affectsCreatedDtLt as any instanceof Date) ?
                    (affectsCreatedDtLt as any).toISOString() :
                    affectsCreatedDtLt;
            }

            if (affectsCreatedDtLte !== undefined) {
                localVarQueryParameter['affects__created_dt__lte'] = (affectsCreatedDtLte as any instanceof Date) ?
                    (affectsCreatedDtLte as any).toISOString() :
                    affectsCreatedDtLte;
            }

            if (affectsCvss2 !== undefined) {
                localVarQueryParameter['affects__cvss2'] = affectsCvss2;
            }

            if (affectsCvss2Score !== undefined) {
                localVarQueryParameter['affects__cvss2_score'] = affectsCvss2Score;
            }

            if (affectsCvss2ScoreGt !== undefined) {
                localVarQueryParameter['affects__cvss2_score__gt'] = affectsCvss2ScoreGt;
            }

            if (affectsCvss2ScoreGte !== undefined) {
                localVarQueryParameter['affects__cvss2_score__gte'] = affectsCvss2ScoreGte;
            }

            if (affectsCvss2ScoreLt !== undefined) {
                localVarQueryParameter['affects__cvss2_score__lt'] = affectsCvss2ScoreLt;
            }

            if (affectsCvss2ScoreLte !== undefined) {
                localVarQueryParameter['affects__cvss2_score__lte'] = affectsCvss2ScoreLte;
            }

            if (affectsCvss3 !== undefined) {
                localVarQueryParameter['affects__cvss3'] = affectsCvss3;
            }

            if (affectsCvss3Score !== undefined) {
                localVarQueryParameter['affects__cvss3_score'] = affectsCvss3Score;
            }

            if (affectsCvss3ScoreGt !== undefined) {
                localVarQueryParameter['affects__cvss3_score__gt'] = affectsCvss3ScoreGt;
            }

            if (affectsCvss3ScoreGte !== undefined) {
                localVarQueryParameter['affects__cvss3_score__gte'] = affectsCvss3ScoreGte;
            }

            if (affectsCvss3ScoreLt !== undefined) {
                localVarQueryParameter['affects__cvss3_score__lt'] = affectsCvss3ScoreLt;
            }

            if (affectsCvss3ScoreLte !== undefined) {
                localVarQueryParameter['affects__cvss3_score__lte'] = affectsCvss3ScoreLte;
            }

            if (affectsEmbargoed !== undefined) {
                localVarQueryParameter['affects__embargoed'] = affectsEmbargoed;
            }

            if (affectsFlawComponent !== undefined) {
                localVarQueryParameter['affects__flaw__component'] = affectsFlawComponent;
            }

            if (affectsFlawCreatedDt !== undefined) {
                localVarQueryParameter['affects__flaw__created_dt'] = (affectsFlawCreatedDt as any instanceof Date) ?
                    (affectsFlawCreatedDt as any).toISOString() :
                    affectsFlawCreatedDt;
            }

            if (affectsFlawCreatedDtDate !== undefined) {
                localVarQueryParameter['affects__flaw__created_dt__date'] = (affectsFlawCreatedDtDate as any instanceof Date) ?
                    (affectsFlawCreatedDtDate as any).toISOString().substr(0,10) :
                    affectsFlawCreatedDtDate;
            }

            if (affectsFlawCreatedDtDateGte !== undefined) {
                localVarQueryParameter['affects__flaw__created_dt__date__gte'] = (affectsFlawCreatedDtDateGte as any instanceof Date) ?
                    (affectsFlawCreatedDtDateGte as any).toISOString().substr(0,10) :
                    affectsFlawCreatedDtDateGte;
            }

            if (affectsFlawCreatedDtDateLte !== undefined) {
                localVarQueryParameter['affects__flaw__created_dt__date__lte'] = (affectsFlawCreatedDtDateLte as any instanceof Date) ?
                    (affectsFlawCreatedDtDateLte as any).toISOString().substr(0,10) :
                    affectsFlawCreatedDtDateLte;
            }

            if (affectsFlawCreatedDtGt !== undefined) {
                localVarQueryParameter['affects__flaw__created_dt__gt'] = (affectsFlawCreatedDtGt as any instanceof Date) ?
                    (affectsFlawCreatedDtGt as any).toISOString() :
                    affectsFlawCreatedDtGt;
            }

            if (affectsFlawCreatedDtGte !== undefined) {
                localVarQueryParameter['affects__flaw__created_dt__gte'] = (affectsFlawCreatedDtGte as any instanceof Date) ?
                    (affectsFlawCreatedDtGte as any).toISOString() :
                    affectsFlawCreatedDtGte;
            }

            if (affectsFlawCreatedDtLt !== undefined) {
                localVarQueryParameter['affects__flaw__created_dt__lt'] = (affectsFlawCreatedDtLt as any instanceof Date) ?
                    (affectsFlawCreatedDtLt as any).toISOString() :
                    affectsFlawCreatedDtLt;
            }

            if (affectsFlawCreatedDtLte !== undefined) {
                localVarQueryParameter['affects__flaw__created_dt__lte'] = (affectsFlawCreatedDtLte as any instanceof Date) ?
                    (affectsFlawCreatedDtLte as any).toISOString() :
                    affectsFlawCreatedDtLte;
            }

            if (affectsFlawCveId !== undefined) {
                localVarQueryParameter['affects__flaw__cve_id'] = affectsFlawCveId;
            }

            if (affectsFlawCvss2 !== undefined) {
                localVarQueryParameter['affects__flaw__cvss2'] = affectsFlawCvss2;
            }

            if (affectsFlawCvss2Score !== undefined) {
                localVarQueryParameter['affects__flaw__cvss2_score'] = affectsFlawCvss2Score;
            }

            if (affectsFlawCvss2ScoreGt !== undefined) {
                localVarQueryParameter['affects__flaw__cvss2_score__gt'] = affectsFlawCvss2ScoreGt;
            }

            if (affectsFlawCvss2ScoreGte !== undefined) {
                localVarQueryParameter['affects__flaw__cvss2_score__gte'] = affectsFlawCvss2ScoreGte;
            }

            if (affectsFlawCvss2ScoreLt !== undefined) {
                localVarQueryParameter['affects__flaw__cvss2_score__lt'] = affectsFlawCvss2ScoreLt;
            }

            if (affectsFlawCvss2ScoreLte !== undefined) {
                localVarQueryParameter['affects__flaw__cvss2_score__lte'] = affectsFlawCvss2ScoreLte;
            }

            if (affectsFlawCvss3 !== undefined) {
                localVarQueryParameter['affects__flaw__cvss3'] = affectsFlawCvss3;
            }

            if (affectsFlawCvss3Score !== undefined) {
                localVarQueryParameter['affects__flaw__cvss3_score'] = affectsFlawCvss3Score;
            }

            if (affectsFlawCvss3ScoreGt !== undefined) {
                localVarQueryParameter['affects__flaw__cvss3_score__gt'] = affectsFlawCvss3ScoreGt;
            }

            if (affectsFlawCvss3ScoreGte !== undefined) {
                localVarQueryParameter['affects__flaw__cvss3_score__gte'] = affectsFlawCvss3ScoreGte;
            }

            if (affectsFlawCvss3ScoreLt !== undefined) {
                localVarQueryParameter['affects__flaw__cvss3_score__lt'] = affectsFlawCvss3ScoreLt;
            }

            if (affectsFlawCvss3ScoreLte !== undefined) {
                localVarQueryParameter['affects__flaw__cvss3_score__lte'] = affectsFlawCvss3ScoreLte;
            }

            if (affectsFlawCweId !== undefined) {
                localVarQueryParameter['affects__flaw__cwe_id'] = affectsFlawCweId;
            }

            if (affectsFlawEmbargoed !== undefined) {
                localVarQueryParameter['affects__flaw__embargoed'] = affectsFlawEmbargoed;
            }

            if (affectsFlawImpact !== undefined) {
                localVarQueryParameter['affects__flaw__impact'] = affectsFlawImpact;
            }

            if (affectsFlawIsMajorIncident !== undefined) {
                localVarQueryParameter['affects__flaw__is_major_incident'] = affectsFlawIsMajorIncident;
            }

            if (affectsFlawNvdCvss2 !== undefined) {
                localVarQueryParameter['affects__flaw__nvd_cvss2'] = affectsFlawNvdCvss2;
            }

            if (affectsFlawNvdCvss3 !== undefined) {
                localVarQueryParameter['affects__flaw__nvd_cvss3'] = affectsFlawNvdCvss3;
            }

            if (affectsFlawReportedDt !== undefined) {
                localVarQueryParameter['affects__flaw__reported_dt'] = (affectsFlawReportedDt as any instanceof Date) ?
                    (affectsFlawReportedDt as any).toISOString() :
                    affectsFlawReportedDt;
            }

            if (affectsFlawReportedDtDate !== undefined) {
                localVarQueryParameter['affects__flaw__reported_dt__date'] = (affectsFlawReportedDtDate as any instanceof Date) ?
                    (affectsFlawReportedDtDate as any).toISOString().substr(0,10) :
                    affectsFlawReportedDtDate;
            }

            if (affectsFlawReportedDtDateGte !== undefined) {
                localVarQueryParameter['affects__flaw__reported_dt__date__gte'] = (affectsFlawReportedDtDateGte as any instanceof Date) ?
                    (affectsFlawReportedDtDateGte as any).toISOString().substr(0,10) :
                    affectsFlawReportedDtDateGte;
            }

            if (affectsFlawReportedDtDateLte !== undefined) {
                localVarQueryParameter['affects__flaw__reported_dt__date__lte'] = (affectsFlawReportedDtDateLte as any instanceof Date) ?
                    (affectsFlawReportedDtDateLte as any).toISOString().substr(0,10) :
                    affectsFlawReportedDtDateLte;
            }

            if (affectsFlawReportedDtGt !== undefined) {
                localVarQueryParameter['affects__flaw__reported_dt__gt'] = (affectsFlawReportedDtGt as any instanceof Date) ?
                    (affectsFlawReportedDtGt as any).toISOString() :
                    affectsFlawReportedDtGt;
            }

            if (affectsFlawReportedDtGte !== undefined) {
                localVarQueryParameter['affects__flaw__reported_dt__gte'] = (affectsFlawReportedDtGte as any instanceof Date) ?
                    (affectsFlawReportedDtGte as any).toISOString() :
                    affectsFlawReportedDtGte;
            }

            if (affectsFlawReportedDtLt !== undefined) {
                localVarQueryParameter['affects__flaw__reported_dt__lt'] = (affectsFlawReportedDtLt as any instanceof Date) ?
                    (affectsFlawReportedDtLt as any).toISOString() :
                    affectsFlawReportedDtLt;
            }

            if (affectsFlawReportedDtLte !== undefined) {
                localVarQueryParameter['affects__flaw__reported_dt__lte'] = (affectsFlawReportedDtLte as any instanceof Date) ?
                    (affectsFlawReportedDtLte as any).toISOString() :
                    affectsFlawReportedDtLte;
            }

            if (affectsFlawSource !== undefined) {
                localVarQueryParameter['affects__flaw__source'] = affectsFlawSource;
            }

            if (affectsFlawType !== undefined) {
                localVarQueryParameter['affects__flaw__type'] = affectsFlawType;
            }

            if (affectsFlawUnembargoDt !== undefined) {
                localVarQueryParameter['affects__flaw__unembargo_dt'] = (affectsFlawUnembargoDt as any instanceof Date) ?
                    (affectsFlawUnembargoDt as any).toISOString() :
                    affectsFlawUnembargoDt;
            }

            if (affectsFlawUpdatedDt !== undefined) {
                localVarQueryParameter['affects__flaw__updated_dt'] = (affectsFlawUpdatedDt as any instanceof Date) ?
                    (affectsFlawUpdatedDt as any).toISOString() :
                    affectsFlawUpdatedDt;
            }

            if (affectsFlawUpdatedDtDate !== undefined) {
                localVarQueryParameter['affects__flaw__updated_dt__date'] = (affectsFlawUpdatedDtDate as any instanceof Date) ?
                    (affectsFlawUpdatedDtDate as any).toISOString().substr(0,10) :
                    affectsFlawUpdatedDtDate;
            }

            if (affectsFlawUpdatedDtDateGte !== undefined) {
                localVarQueryParameter['affects__flaw__updated_dt__date__gte'] = (affectsFlawUpdatedDtDateGte as any instanceof Date) ?
                    (affectsFlawUpdatedDtDateGte as any).toISOString().substr(0,10) :
                    affectsFlawUpdatedDtDateGte;
            }

            if (affectsFlawUpdatedDtDateLte !== undefined) {
                localVarQueryParameter['affects__flaw__updated_dt__date__lte'] = (affectsFlawUpdatedDtDateLte as any instanceof Date) ?
                    (affectsFlawUpdatedDtDateLte as any).toISOString().substr(0,10) :
                    affectsFlawUpdatedDtDateLte;
            }

            if (affectsFlawUpdatedDtGt !== undefined) {
                localVarQueryParameter['affects__flaw__updated_dt__gt'] = (affectsFlawUpdatedDtGt as any instanceof Date) ?
                    (affectsFlawUpdatedDtGt as any).toISOString() :
                    affectsFlawUpdatedDtGt;
            }

            if (affectsFlawUpdatedDtGte !== undefined) {
                localVarQueryParameter['affects__flaw__updated_dt__gte'] = (affectsFlawUpdatedDtGte as any instanceof Date) ?
                    (affectsFlawUpdatedDtGte as any).toISOString() :
                    affectsFlawUpdatedDtGte;
            }

            if (affectsFlawUpdatedDtLt !== undefined) {
                localVarQueryParameter['affects__flaw__updated_dt__lt'] = (affectsFlawUpdatedDtLt as any instanceof Date) ?
                    (affectsFlawUpdatedDtLt as any).toISOString() :
                    affectsFlawUpdatedDtLt;
            }

            if (affectsFlawUpdatedDtLte !== undefined) {
                localVarQueryParameter['affects__flaw__updated_dt__lte'] = (affectsFlawUpdatedDtLte as any instanceof Date) ?
                    (affectsFlawUpdatedDtLte as any).toISOString() :
                    affectsFlawUpdatedDtLte;
            }

            if (affectsFlawUuid !== undefined) {
                localVarQueryParameter['affects__flaw__uuid'] = affectsFlawUuid;
            }

            if (affectsImpact !== undefined) {
                localVarQueryParameter['affects__impact'] = affectsImpact;
            }

            if (affectsPsComponent !== undefined) {
                localVarQueryParameter['affects__ps_component'] = affectsPsComponent;
            }

            if (affectsPsModule !== undefined) {
                localVarQueryParameter['affects__ps_module'] = affectsPsModule;
            }

            if (affectsResolution !== undefined) {
                localVarQueryParameter['affects__resolution'] = affectsResolution;
            }

            if (affectsType !== undefined) {
                localVarQueryParameter['affects__type'] = affectsType;
            }

            if (affectsUpdatedDt !== undefined) {
                localVarQueryParameter['affects__updated_dt'] = (affectsUpdatedDt as any instanceof Date) ?
                    (affectsUpdatedDt as any).toISOString() :
                    affectsUpdatedDt;
            }

            if (affectsUpdatedDtDate !== undefined) {
                localVarQueryParameter['affects__updated_dt__date'] = (affectsUpdatedDtDate as any instanceof Date) ?
                    (affectsUpdatedDtDate as any).toISOString().substr(0,10) :
                    affectsUpdatedDtDate;
            }

            if (affectsUpdatedDtDateGte !== undefined) {
                localVarQueryParameter['affects__updated_dt__date__gte'] = (affectsUpdatedDtDateGte as any instanceof Date) ?
                    (affectsUpdatedDtDateGte as any).toISOString().substr(0,10) :
                    affectsUpdatedDtDateGte;
            }

            if (affectsUpdatedDtDateLte !== undefined) {
                localVarQueryParameter['affects__updated_dt__date__lte'] = (affectsUpdatedDtDateLte as any instanceof Date) ?
                    (affectsUpdatedDtDateLte as any).toISOString().substr(0,10) :
                    affectsUpdatedDtDateLte;
            }

            if (affectsUpdatedDtGt !== undefined) {
                localVarQueryParameter['affects__updated_dt__gt'] = (affectsUpdatedDtGt as any instanceof Date) ?
                    (affectsUpdatedDtGt as any).toISOString() :
                    affectsUpdatedDtGt;
            }

            if (affectsUpdatedDtGte !== undefined) {
                localVarQueryParameter['affects__updated_dt__gte'] = (affectsUpdatedDtGte as any instanceof Date) ?
                    (affectsUpdatedDtGte as any).toISOString() :
                    affectsUpdatedDtGte;
            }

            if (affectsUpdatedDtLt !== undefined) {
                localVarQueryParameter['affects__updated_dt__lt'] = (affectsUpdatedDtLt as any instanceof Date) ?
                    (affectsUpdatedDtLt as any).toISOString() :
                    affectsUpdatedDtLt;
            }

            if (affectsUpdatedDtLte !== undefined) {
                localVarQueryParameter['affects__updated_dt__lte'] = (affectsUpdatedDtLte as any instanceof Date) ?
                    (affectsUpdatedDtLte as any).toISOString() :
                    affectsUpdatedDtLte;
            }

            if (affectsUuid !== undefined) {
                localVarQueryParameter['affects__uuid'] = affectsUuid;
            }

            if (createdDt !== undefined) {
                localVarQueryParameter['created_dt'] = (createdDt as any instanceof Date) ?
                    (createdDt as any).toISOString() :
                    createdDt;
            }

            if (createdDtDate !== undefined) {
                localVarQueryParameter['created_dt__date'] = (createdDtDate as any instanceof Date) ?
                    (createdDtDate as any).toISOString().substr(0,10) :
                    createdDtDate;
            }

            if (createdDtDateGte !== undefined) {
                localVarQueryParameter['created_dt__date__gte'] = (createdDtDateGte as any instanceof Date) ?
                    (createdDtDateGte as any).toISOString().substr(0,10) :
                    createdDtDateGte;
            }

            if (createdDtDateLte !== undefined) {
                localVarQueryParameter['created_dt__date__lte'] = (createdDtDateLte as any instanceof Date) ?
                    (createdDtDateLte as any).toISOString().substr(0,10) :
                    createdDtDateLte;
            }

            if (createdDtGt !== undefined) {
                localVarQueryParameter['created_dt__gt'] = (createdDtGt as any instanceof Date) ?
                    (createdDtGt as any).toISOString() :
                    createdDtGt;
            }

            if (createdDtGte !== undefined) {
                localVarQueryParameter['created_dt__gte'] = (createdDtGte as any instanceof Date) ?
                    (createdDtGte as any).toISOString() :
                    createdDtGte;
            }

            if (createdDtLt !== undefined) {
                localVarQueryParameter['created_dt__lt'] = (createdDtLt as any instanceof Date) ?
                    (createdDtLt as any).toISOString() :
                    createdDtLt;
            }

            if (createdDtLte !== undefined) {
                localVarQueryParameter['created_dt__lte'] = (createdDtLte as any instanceof Date) ?
                    (createdDtLte as any).toISOString() :
                    createdDtLte;
            }

            if (embargoed !== undefined) {
                localVarQueryParameter['embargoed'] = embargoed;
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (externalSystemId !== undefined) {
                localVarQueryParameter['external_system_id'] = externalSystemId;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }

            if (includeMetaAttr) {
                localVarQueryParameter['include_meta_attr'] = includeMetaAttr;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (order) {
                localVarQueryParameter['order'] = order.join(COLLECTION_FORMATS.csv);
            }

            if (psUpdateStream !== undefined) {
                localVarQueryParameter['ps_update_stream'] = psUpdateStream;
            }

            if (resolution !== undefined) {
                localVarQueryParameter['resolution'] = resolution;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (updatedDt !== undefined) {
                localVarQueryParameter['updated_dt'] = (updatedDt as any instanceof Date) ?
                    (updatedDt as any).toISOString() :
                    updatedDt;
            }

            if (updatedDtDate !== undefined) {
                localVarQueryParameter['updated_dt__date'] = (updatedDtDate as any instanceof Date) ?
                    (updatedDtDate as any).toISOString().substr(0,10) :
                    updatedDtDate;
            }

            if (updatedDtDateGte !== undefined) {
                localVarQueryParameter['updated_dt__date__gte'] = (updatedDtDateGte as any instanceof Date) ?
                    (updatedDtDateGte as any).toISOString().substr(0,10) :
                    updatedDtDateGte;
            }

            if (updatedDtDateLte !== undefined) {
                localVarQueryParameter['updated_dt__date__lte'] = (updatedDtDateLte as any instanceof Date) ?
                    (updatedDtDateLte as any).toISOString().substr(0,10) :
                    updatedDtDateLte;
            }

            if (updatedDtGt !== undefined) {
                localVarQueryParameter['updated_dt__gt'] = (updatedDtGt as any instanceof Date) ?
                    (updatedDtGt as any).toISOString() :
                    updatedDtGt;
            }

            if (updatedDtGte !== undefined) {
                localVarQueryParameter['updated_dt__gte'] = (updatedDtGte as any instanceof Date) ?
                    (updatedDtGte as any).toISOString() :
                    updatedDtGte;
            }

            if (updatedDtLt !== undefined) {
                localVarQueryParameter['updated_dt__lt'] = (updatedDtLt as any instanceof Date) ?
                    (updatedDtLt as any).toISOString() :
                    updatedDtLt;
            }

            if (updatedDtLte !== undefined) {
                localVarQueryParameter['updated_dt__lte'] = (updatedDtLte as any instanceof Date) ?
                    (updatedDtLte as any).toISOString() :
                    updatedDtLte;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid A UUID string identifying this Tracker.
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1TrackersRetrieve: async (uuid: string, excludeFields?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('osidbApiV1TrackersRetrieve', 'uuid', uuid)
            const localVarPath = `/osidb/api/v1/trackers/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }

            if (includeMetaAttr) {
                localVarQueryParameter['include_meta_attr'] = includeMetaAttr;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {string} uuid A UUID string identifying this Tracker.
         * @param {Tracker} tracker 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1TrackersUpdate: async (bugzillaApiKey: string, jiraApiKey: string, uuid: string, tracker: Tracker, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bugzillaApiKey' is not null or undefined
            assertParamExists('osidbApiV1TrackersUpdate', 'bugzillaApiKey', bugzillaApiKey)
            // verify required parameter 'jiraApiKey' is not null or undefined
            assertParamExists('osidbApiV1TrackersUpdate', 'jiraApiKey', jiraApiKey)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('osidbApiV1TrackersUpdate', 'uuid', uuid)
            // verify required parameter 'tracker' is not null or undefined
            assertParamExists('osidbApiV1TrackersUpdate', 'tracker', tracker)
            const localVarPath = `/osidb/api/v1/trackers/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (bugzillaApiKey != null) {
                localVarHeaderParameter['Bugzilla-Api-Key'] = String(bugzillaApiKey);
            }

            if (jiraApiKey != null) {
                localVarHeaderParameter['Jira-Api-Key'] = String(jiraApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tracker, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * unauthenticated view providing healthcheck on osidb service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbHealthyRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/osidb/healthy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View that provides information about the currently logged-in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbWhoamiRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/osidb/whoami`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OsidbApi - functional programming interface
 * @export
 */
export const OsidbApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OsidbApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {AffectPost} affectPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1AffectsCreate(bugzillaApiKey: string, affectPost: AffectPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1AffectsCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1AffectsCreate(bugzillaApiKey, affectPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} affectId 
         * @param {AffectCVSSPost} affectCVSSPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1AffectsCvssScoresCreate(affectId: string, affectCVSSPost: AffectCVSSPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1AffectsCvssScoresCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1AffectsCvssScoresCreate(affectId, affectCVSSPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Destroy the instance and proxy the delete to Bugzilla.
         * @param {string} affectId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1AffectsCvssScoresDestroy(affectId: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200ResponseAllOf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1AffectsCvssScoresDestroy(affectId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} affectId 
         * @param {string} [comment] 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {string} [cvssVersion] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {'NIST' | 'RH'} [issuer] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {number} [score] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {string} [vector] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1AffectsCvssScoresList(affectId: string, comment?: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, cvssVersion?: string, excludeFields?: Array<string>, includeFields?: Array<string>, issuer?: 'NIST' | 'RH', limit?: number, offset?: number, score?: number, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, vector?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1AffectsCvssScoresList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1AffectsCvssScoresList(affectId, comment, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, cvssVersion, excludeFields, includeFields, issuer, limit, offset, score, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, vector, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} affectId 
         * @param {string} id 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1AffectsCvssScoresRetrieve(affectId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1AffectsCvssScoresCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1AffectsCvssScoresRetrieve(affectId, id, excludeFields, includeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} affectId 
         * @param {string} id 
         * @param {AffectCVSSPut} affectCVSSPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1AffectsCvssScoresUpdate(affectId: string, id: string, affectCVSSPut: AffectCVSSPut, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1AffectsCvssScoresCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1AffectsCvssScoresUpdate(affectId, id, affectCVSSPut, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Destroy the instance and proxy the delete to Bugzilla
         * @param {string} uuid A UUID string identifying this Affect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1AffectsDestroy(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200ResponseAllOf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1AffectsDestroy(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {'' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED'} [affectedness] 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {string} [cvss2] 
         * @param {number} [cvss2Score] 
         * @param {number} [cvss2ScoreGt] 
         * @param {number} [cvss2ScoreGte] 
         * @param {number} [cvss2ScoreLt] 
         * @param {number} [cvss2ScoreLte] 
         * @param {string} [cvss3] 
         * @param {number} [cvss3Score] 
         * @param {number} [cvss3ScoreGt] 
         * @param {number} [cvss3ScoreGte] 
         * @param {number} [cvss3ScoreLt] 
         * @param {number} [cvss3ScoreLte] 
         * @param {string} [cvssScoresComment] 
         * @param {string} [cvssScoresCreatedDt] 
         * @param {string} [cvssScoresCreatedDtDate] 
         * @param {string} [cvssScoresCreatedDtDateGte] 
         * @param {string} [cvssScoresCreatedDtDateLte] 
         * @param {string} [cvssScoresCreatedDtGt] 
         * @param {string} [cvssScoresCreatedDtGte] 
         * @param {string} [cvssScoresCreatedDtLt] 
         * @param {string} [cvssScoresCreatedDtLte] 
         * @param {string} [cvssScoresCvssVersion] 
         * @param {'NIST' | 'RH'} [cvssScoresIssuer] 
         * @param {number} [cvssScoresScore] 
         * @param {string} [cvssScoresUpdatedDt] 
         * @param {string} [cvssScoresUpdatedDtDate] 
         * @param {string} [cvssScoresUpdatedDtDateGte] 
         * @param {string} [cvssScoresUpdatedDtDateLte] 
         * @param {string} [cvssScoresUpdatedDtGt] 
         * @param {string} [cvssScoresUpdatedDtGte] 
         * @param {string} [cvssScoresUpdatedDtLt] 
         * @param {string} [cvssScoresUpdatedDtLte] 
         * @param {string} [cvssScoresUuid] 
         * @param {string} [cvssScoresVector] 
         * @param {boolean} [embargoed] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {string} [flawComponent] 
         * @param {string} [flawCreatedDt] 
         * @param {string} [flawCreatedDtDate] 
         * @param {string} [flawCreatedDtDateGte] 
         * @param {string} [flawCreatedDtDateLte] 
         * @param {string} [flawCreatedDtGt] 
         * @param {string} [flawCreatedDtGte] 
         * @param {string} [flawCreatedDtLt] 
         * @param {string} [flawCreatedDtLte] 
         * @param {string} [flawCveId] 
         * @param {string} [flawCvss2] 
         * @param {number} [flawCvss2Score] 
         * @param {number} [flawCvss2ScoreGt] 
         * @param {number} [flawCvss2ScoreGte] 
         * @param {number} [flawCvss2ScoreLt] 
         * @param {number} [flawCvss2ScoreLte] 
         * @param {string} [flawCvss3] 
         * @param {number} [flawCvss3Score] 
         * @param {number} [flawCvss3ScoreGt] 
         * @param {number} [flawCvss3ScoreGte] 
         * @param {number} [flawCvss3ScoreLt] 
         * @param {number} [flawCvss3ScoreLte] 
         * @param {string} [flawCweId] 
         * @param {boolean} [flawEmbargoed] 
         * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [flawImpact] 
         * @param {boolean} [flawIsMajorIncident] 
         * @param {string} [flawNvdCvss2] 
         * @param {string} [flawNvdCvss3] 
         * @param {string} [flawReportedDt] 
         * @param {string} [flawReportedDtDate] 
         * @param {string} [flawReportedDtDateGte] 
         * @param {string} [flawReportedDtDateLte] 
         * @param {string} [flawReportedDtGt] 
         * @param {string} [flawReportedDtGte] 
         * @param {string} [flawReportedDtLt] 
         * @param {string} [flawReportedDtLte] 
         * @param {'' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF'} [flawSource] 
         * @param {'VULNERABILITY' | 'WEAKNESS'} [flawType] 
         * @param {string} [flawUnembargoDt] 
         * @param {string} [flawUpdatedDt] 
         * @param {string} [flawUpdatedDtDate] 
         * @param {string} [flawUpdatedDtDateGte] 
         * @param {string} [flawUpdatedDtDateLte] 
         * @param {string} [flawUpdatedDtGt] 
         * @param {string} [flawUpdatedDtGte] 
         * @param {string} [flawUpdatedDtLt] 
         * @param {string} [flawUpdatedDtLte] 
         * @param {string} [flawUuid] 
         * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [impact] 
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {Array<'-affectedness' | '-created_dt' | '-cvss2' | '-cvss2_score' | '-cvss3' | '-cvss3_score' | '-cvss_scores__comment' | '-cvss_scores__created_dt' | '-cvss_scores__issuer' | '-cvss_scores__score' | '-cvss_scores__updated_dt' | '-cvss_scores__uuid' | '-cvss_scores__vector' | '-flaw__component' | '-flaw__created_dt' | '-flaw__cve_id' | '-flaw__cvss2' | '-flaw__cvss2_score' | '-flaw__cvss3' | '-flaw__cvss3_score' | '-flaw__cwe_id' | '-flaw__impact' | '-flaw__nvd_cvss2' | '-flaw__nvd_cvss3' | '-flaw__reported_dt' | '-flaw__source' | '-flaw__type' | '-flaw__unembargo_dt' | '-flaw__updated_dt' | '-flaw__uuid' | '-impact' | '-ps_component' | '-ps_module' | '-resolution' | '-trackers__created_dt' | '-trackers__external_system_id' | '-trackers__ps_update_stream' | '-trackers__resolution' | '-trackers__status' | '-trackers__type' | '-trackers__updated_dt' | '-trackers__uuid' | '-type' | '-updated_dt' | '-uuid' | 'affectedness' | 'created_dt' | 'cvss2' | 'cvss2_score' | 'cvss3' | 'cvss3_score' | 'cvss_scores__comment' | 'cvss_scores__created_dt' | 'cvss_scores__issuer' | 'cvss_scores__score' | 'cvss_scores__updated_dt' | 'cvss_scores__uuid' | 'cvss_scores__vector' | 'flaw__component' | 'flaw__created_dt' | 'flaw__cve_id' | 'flaw__cvss2' | 'flaw__cvss2_score' | 'flaw__cvss3' | 'flaw__cvss3_score' | 'flaw__cwe_id' | 'flaw__impact' | 'flaw__nvd_cvss2' | 'flaw__nvd_cvss3' | 'flaw__reported_dt' | 'flaw__source' | 'flaw__type' | 'flaw__unembargo_dt' | 'flaw__updated_dt' | 'flaw__uuid' | 'impact' | 'ps_component' | 'ps_module' | 'resolution' | 'trackers__created_dt' | 'trackers__external_system_id' | 'trackers__ps_update_stream' | 'trackers__resolution' | 'trackers__status' | 'trackers__type' | 'trackers__updated_dt' | 'trackers__uuid' | 'type' | 'updated_dt' | 'uuid'>} [order] Ordering
         * @param {string} [psComponent] 
         * @param {string} [psModule] 
         * @param {'' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT'} [resolution] 
         * @param {string} [trackersCreatedDt] 
         * @param {string} [trackersCreatedDtDate] 
         * @param {string} [trackersCreatedDtDateGte] 
         * @param {string} [trackersCreatedDtDateLte] 
         * @param {string} [trackersCreatedDtGt] 
         * @param {string} [trackersCreatedDtGte] 
         * @param {string} [trackersCreatedDtLt] 
         * @param {string} [trackersCreatedDtLte] 
         * @param {boolean} [trackersEmbargoed] 
         * @param {string} [trackersExternalSystemId] 
         * @param {string} [trackersPsUpdateStream] 
         * @param {string} [trackersResolution] 
         * @param {string} [trackersStatus] 
         * @param {'BUGZILLA' | 'JIRA'} [trackersType] 
         * @param {string} [trackersUpdatedDt] 
         * @param {string} [trackersUpdatedDtDate] 
         * @param {string} [trackersUpdatedDtDateGte] 
         * @param {string} [trackersUpdatedDtDateLte] 
         * @param {string} [trackersUpdatedDtGt] 
         * @param {string} [trackersUpdatedDtGte] 
         * @param {string} [trackersUpdatedDtLt] 
         * @param {string} [trackersUpdatedDtLte] 
         * @param {string} [trackersUuid] 
         * @param {'DEFAULT'} [type] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1AffectsList(affectedness?: '' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED', createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, cvss2?: string, cvss2Score?: number, cvss2ScoreGt?: number, cvss2ScoreGte?: number, cvss2ScoreLt?: number, cvss2ScoreLte?: number, cvss3?: string, cvss3Score?: number, cvss3ScoreGt?: number, cvss3ScoreGte?: number, cvss3ScoreLt?: number, cvss3ScoreLte?: number, cvssScoresComment?: string, cvssScoresCreatedDt?: string, cvssScoresCreatedDtDate?: string, cvssScoresCreatedDtDateGte?: string, cvssScoresCreatedDtDateLte?: string, cvssScoresCreatedDtGt?: string, cvssScoresCreatedDtGte?: string, cvssScoresCreatedDtLt?: string, cvssScoresCreatedDtLte?: string, cvssScoresCvssVersion?: string, cvssScoresIssuer?: 'NIST' | 'RH', cvssScoresScore?: number, cvssScoresUpdatedDt?: string, cvssScoresUpdatedDtDate?: string, cvssScoresUpdatedDtDateGte?: string, cvssScoresUpdatedDtDateLte?: string, cvssScoresUpdatedDtGt?: string, cvssScoresUpdatedDtGte?: string, cvssScoresUpdatedDtLt?: string, cvssScoresUpdatedDtLte?: string, cvssScoresUuid?: string, cvssScoresVector?: string, embargoed?: boolean, excludeFields?: Array<string>, flawComponent?: string, flawCreatedDt?: string, flawCreatedDtDate?: string, flawCreatedDtDateGte?: string, flawCreatedDtDateLte?: string, flawCreatedDtGt?: string, flawCreatedDtGte?: string, flawCreatedDtLt?: string, flawCreatedDtLte?: string, flawCveId?: string, flawCvss2?: string, flawCvss2Score?: number, flawCvss2ScoreGt?: number, flawCvss2ScoreGte?: number, flawCvss2ScoreLt?: number, flawCvss2ScoreLte?: number, flawCvss3?: string, flawCvss3Score?: number, flawCvss3ScoreGt?: number, flawCvss3ScoreGte?: number, flawCvss3ScoreLt?: number, flawCvss3ScoreLte?: number, flawCweId?: string, flawEmbargoed?: boolean, flawImpact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', flawIsMajorIncident?: boolean, flawNvdCvss2?: string, flawNvdCvss3?: string, flawReportedDt?: string, flawReportedDtDate?: string, flawReportedDtDateGte?: string, flawReportedDtDateLte?: string, flawReportedDtGt?: string, flawReportedDtGte?: string, flawReportedDtLt?: string, flawReportedDtLte?: string, flawSource?: '' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF', flawType?: 'VULNERABILITY' | 'WEAKNESS', flawUnembargoDt?: string, flawUpdatedDt?: string, flawUpdatedDtDate?: string, flawUpdatedDtDateGte?: string, flawUpdatedDtDateLte?: string, flawUpdatedDtGt?: string, flawUpdatedDtGte?: string, flawUpdatedDtLt?: string, flawUpdatedDtLte?: string, flawUuid?: string, impact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', includeFields?: Array<string>, includeMetaAttr?: Array<string>, limit?: number, offset?: number, order?: Array<'-affectedness' | '-created_dt' | '-cvss2' | '-cvss2_score' | '-cvss3' | '-cvss3_score' | '-cvss_scores__comment' | '-cvss_scores__created_dt' | '-cvss_scores__issuer' | '-cvss_scores__score' | '-cvss_scores__updated_dt' | '-cvss_scores__uuid' | '-cvss_scores__vector' | '-flaw__component' | '-flaw__created_dt' | '-flaw__cve_id' | '-flaw__cvss2' | '-flaw__cvss2_score' | '-flaw__cvss3' | '-flaw__cvss3_score' | '-flaw__cwe_id' | '-flaw__impact' | '-flaw__nvd_cvss2' | '-flaw__nvd_cvss3' | '-flaw__reported_dt' | '-flaw__source' | '-flaw__type' | '-flaw__unembargo_dt' | '-flaw__updated_dt' | '-flaw__uuid' | '-impact' | '-ps_component' | '-ps_module' | '-resolution' | '-trackers__created_dt' | '-trackers__external_system_id' | '-trackers__ps_update_stream' | '-trackers__resolution' | '-trackers__status' | '-trackers__type' | '-trackers__updated_dt' | '-trackers__uuid' | '-type' | '-updated_dt' | '-uuid' | 'affectedness' | 'created_dt' | 'cvss2' | 'cvss2_score' | 'cvss3' | 'cvss3_score' | 'cvss_scores__comment' | 'cvss_scores__created_dt' | 'cvss_scores__issuer' | 'cvss_scores__score' | 'cvss_scores__updated_dt' | 'cvss_scores__uuid' | 'cvss_scores__vector' | 'flaw__component' | 'flaw__created_dt' | 'flaw__cve_id' | 'flaw__cvss2' | 'flaw__cvss2_score' | 'flaw__cvss3' | 'flaw__cvss3_score' | 'flaw__cwe_id' | 'flaw__impact' | 'flaw__nvd_cvss2' | 'flaw__nvd_cvss3' | 'flaw__reported_dt' | 'flaw__source' | 'flaw__type' | 'flaw__unembargo_dt' | 'flaw__updated_dt' | 'flaw__uuid' | 'impact' | 'ps_component' | 'ps_module' | 'resolution' | 'trackers__created_dt' | 'trackers__external_system_id' | 'trackers__ps_update_stream' | 'trackers__resolution' | 'trackers__status' | 'trackers__type' | 'trackers__updated_dt' | 'trackers__uuid' | 'type' | 'updated_dt' | 'uuid'>, psComponent?: string, psModule?: string, resolution?: '' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT', trackersCreatedDt?: string, trackersCreatedDtDate?: string, trackersCreatedDtDateGte?: string, trackersCreatedDtDateLte?: string, trackersCreatedDtGt?: string, trackersCreatedDtGte?: string, trackersCreatedDtLt?: string, trackersCreatedDtLte?: string, trackersEmbargoed?: boolean, trackersExternalSystemId?: string, trackersPsUpdateStream?: string, trackersResolution?: string, trackersStatus?: string, trackersType?: 'BUGZILLA' | 'JIRA', trackersUpdatedDt?: string, trackersUpdatedDtDate?: string, trackersUpdatedDtDateGte?: string, trackersUpdatedDtDateLte?: string, trackersUpdatedDtGt?: string, trackersUpdatedDtGte?: string, trackersUpdatedDtLt?: string, trackersUpdatedDtLte?: string, trackersUuid?: string, type?: 'DEFAULT', updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1AffectsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1AffectsList(affectedness, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, cvss2, cvss2Score, cvss2ScoreGt, cvss2ScoreGte, cvss2ScoreLt, cvss2ScoreLte, cvss3, cvss3Score, cvss3ScoreGt, cvss3ScoreGte, cvss3ScoreLt, cvss3ScoreLte, cvssScoresComment, cvssScoresCreatedDt, cvssScoresCreatedDtDate, cvssScoresCreatedDtDateGte, cvssScoresCreatedDtDateLte, cvssScoresCreatedDtGt, cvssScoresCreatedDtGte, cvssScoresCreatedDtLt, cvssScoresCreatedDtLte, cvssScoresCvssVersion, cvssScoresIssuer, cvssScoresScore, cvssScoresUpdatedDt, cvssScoresUpdatedDtDate, cvssScoresUpdatedDtDateGte, cvssScoresUpdatedDtDateLte, cvssScoresUpdatedDtGt, cvssScoresUpdatedDtGte, cvssScoresUpdatedDtLt, cvssScoresUpdatedDtLte, cvssScoresUuid, cvssScoresVector, embargoed, excludeFields, flawComponent, flawCreatedDt, flawCreatedDtDate, flawCreatedDtDateGte, flawCreatedDtDateLte, flawCreatedDtGt, flawCreatedDtGte, flawCreatedDtLt, flawCreatedDtLte, flawCveId, flawCvss2, flawCvss2Score, flawCvss2ScoreGt, flawCvss2ScoreGte, flawCvss2ScoreLt, flawCvss2ScoreLte, flawCvss3, flawCvss3Score, flawCvss3ScoreGt, flawCvss3ScoreGte, flawCvss3ScoreLt, flawCvss3ScoreLte, flawCweId, flawEmbargoed, flawImpact, flawIsMajorIncident, flawNvdCvss2, flawNvdCvss3, flawReportedDt, flawReportedDtDate, flawReportedDtDateGte, flawReportedDtDateLte, flawReportedDtGt, flawReportedDtGte, flawReportedDtLt, flawReportedDtLte, flawSource, flawType, flawUnembargoDt, flawUpdatedDt, flawUpdatedDtDate, flawUpdatedDtDateGte, flawUpdatedDtDateLte, flawUpdatedDtGt, flawUpdatedDtGte, flawUpdatedDtLt, flawUpdatedDtLte, flawUuid, impact, includeFields, includeMetaAttr, limit, offset, order, psComponent, psModule, resolution, trackersCreatedDt, trackersCreatedDtDate, trackersCreatedDtDateGte, trackersCreatedDtDateLte, trackersCreatedDtGt, trackersCreatedDtGte, trackersCreatedDtLt, trackersCreatedDtLte, trackersEmbargoed, trackersExternalSystemId, trackersPsUpdateStream, trackersResolution, trackersStatus, trackersType, trackersUpdatedDt, trackersUpdatedDtDate, trackersUpdatedDtDateGte, trackersUpdatedDtDateLte, trackersUpdatedDtGt, trackersUpdatedDtGte, trackersUpdatedDtLt, trackersUpdatedDtLte, trackersUuid, type, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid A UUID string identifying this Affect.
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1AffectsRetrieve(uuid: string, excludeFields?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1AffectsCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1AffectsRetrieve(uuid, excludeFields, includeFields, includeMetaAttr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} uuid A UUID string identifying this Affect.
         * @param {Affect} affect 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1AffectsUpdate(bugzillaApiKey: string, uuid: string, affect: Affect, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1AffectsCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1AffectsUpdate(bugzillaApiKey, uuid, affect, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} flawId 
         * @param {FlawAcknowledgmentPost} flawAcknowledgmentPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsAcknowledgmentsCreate(flawId: string, flawAcknowledgmentPost: FlawAcknowledgmentPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsAcknowledgmentsCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsAcknowledgmentsCreate(flawId, flawAcknowledgmentPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Destroy the instance and proxy the delete to Bugzilla
         * @param {string} flawId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsAcknowledgmentsDestroy(flawId: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200ResponseAllOf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsAcknowledgmentsDestroy(flawId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} [affiliation] 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {boolean} [fromUpstream] 
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsAcknowledgmentsList(flawId: string, affiliation?: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, excludeFields?: Array<string>, fromUpstream?: boolean, includeFields?: Array<string>, includeMetaAttr?: Array<string>, limit?: number, name?: string, offset?: number, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsAcknowledgmentsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsAcknowledgmentsList(flawId, affiliation, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, excludeFields, fromUpstream, includeFields, includeMetaAttr, limit, name, offset, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} id 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsAcknowledgmentsRetrieve(flawId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsAcknowledgmentsCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsAcknowledgmentsRetrieve(flawId, id, excludeFields, includeFields, includeMetaAttr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} id 
         * @param {FlawAcknowledgmentPut} flawAcknowledgmentPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsAcknowledgmentsUpdate(flawId: string, id: string, flawAcknowledgmentPut: FlawAcknowledgmentPut, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsAcknowledgmentsCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsAcknowledgmentsUpdate(flawId, id, flawAcknowledgmentPut, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new comment for a given flaw. Beware that freshly created comments are not guaranteed to keep their original UUIDs, especially if multiple comments are created simultaneously.
         * @param {string} flawId A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
         * @param {FlawCommentPost} flawCommentPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsCommentsCreate(flawId: string, flawCommentPost: FlawCommentPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsCommentsCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsCommentsCreate(flawId, flawCommentPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List existing comments for a given flaw. Beware that freshly created comments are not guaranteed to keep their original UUIDs, especially if multiple comments are created simultaneously.
         * @param {string} flawId A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {string} [externalSystemId] 
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {number} [order] Retrieve only FlawComment resource with the specified order number. Regular flaw comments are numbered from 1 up.
         * @param {string} [uuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsCommentsList(flawId: string, excludeFields?: Array<string>, externalSystemId?: string, includeFields?: Array<string>, includeMetaAttr?: Array<string>, limit?: number, offset?: number, order?: number, uuid?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsCommentsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsCommentsList(flawId, excludeFields, externalSystemId, includeFields, includeMetaAttr, limit, offset, order, uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single existing comments for a given flaw. Beware that freshly created comments are not guaranteed to keep their original UUIDs, especially if multiple comments are created simultaneously.
         * @param {string} commentId A string representing the internal OSIDB UUID of the FlawComment resource.
         * @param {string} flawId A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsCommentsRetrieve(commentId: string, flawId: string, excludeFields?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsCommentsCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsCommentsRetrieve(commentId, flawId, excludeFields, includeFields, includeMetaAttr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {FlawPost} flawPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsCreate(bugzillaApiKey: string, jiraApiKey: string, flawPost: FlawPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsCreate(bugzillaApiKey, jiraApiKey, flawPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} flawId 
         * @param {FlawCVSSPost} flawCVSSPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsCvssScoresCreate(flawId: string, flawCVSSPost: FlawCVSSPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsCvssScoresCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsCvssScoresCreate(flawId, flawCVSSPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Destroy the instance and proxy the delete to Bugzilla
         * @param {string} flawId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsCvssScoresDestroy(flawId: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200ResponseAllOf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsCvssScoresDestroy(flawId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} [comment] 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {string} [cvssVersion] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {'NIST' | 'RH'} [issuer] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {number} [score] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {string} [vector] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsCvssScoresList(flawId: string, comment?: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, cvssVersion?: string, excludeFields?: Array<string>, includeFields?: Array<string>, issuer?: 'NIST' | 'RH', limit?: number, offset?: number, score?: number, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, vector?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsCvssScoresList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsCvssScoresList(flawId, comment, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, cvssVersion, excludeFields, includeFields, issuer, limit, offset, score, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, vector, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} id 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsCvssScoresRetrieve(flawId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsCvssScoresCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsCvssScoresRetrieve(flawId, id, excludeFields, includeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} id 
         * @param {FlawCVSSPut} flawCVSSPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsCvssScoresUpdate(flawId: string, id: string, flawCVSSPut: FlawCVSSPut, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsCvssScoresCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsCvssScoresUpdate(flawId, id, flawCVSSPut, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [acknowledgmentsAffiliation] 
         * @param {string} [acknowledgmentsCreatedDt] 
         * @param {string} [acknowledgmentsCreatedDtDate] 
         * @param {string} [acknowledgmentsCreatedDtDateGte] 
         * @param {string} [acknowledgmentsCreatedDtDateLte] 
         * @param {string} [acknowledgmentsCreatedDtGt] 
         * @param {string} [acknowledgmentsCreatedDtGte] 
         * @param {string} [acknowledgmentsCreatedDtLt] 
         * @param {string} [acknowledgmentsCreatedDtLte] 
         * @param {boolean} [acknowledgmentsFromUpstream] 
         * @param {string} [acknowledgmentsName] 
         * @param {string} [acknowledgmentsUpdatedDt] 
         * @param {string} [acknowledgmentsUpdatedDtDate] 
         * @param {string} [acknowledgmentsUpdatedDtDateGte] 
         * @param {string} [acknowledgmentsUpdatedDtDateLte] 
         * @param {string} [acknowledgmentsUpdatedDtGt] 
         * @param {string} [acknowledgmentsUpdatedDtGte] 
         * @param {string} [acknowledgmentsUpdatedDtLt] 
         * @param {string} [acknowledgmentsUpdatedDtLte] 
         * @param {string} [acknowledgmentsUuid] 
         * @param {'' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED'} [affectsAffectedness] 
         * @param {string} [affectsCreatedDt] 
         * @param {string} [affectsCreatedDtDate] 
         * @param {string} [affectsCreatedDtDateGte] 
         * @param {string} [affectsCreatedDtDateLte] 
         * @param {string} [affectsCreatedDtGt] 
         * @param {string} [affectsCreatedDtGte] 
         * @param {string} [affectsCreatedDtLt] 
         * @param {string} [affectsCreatedDtLte] 
         * @param {string} [affectsCvss2] 
         * @param {number} [affectsCvss2Score] 
         * @param {number} [affectsCvss2ScoreGt] 
         * @param {number} [affectsCvss2ScoreGte] 
         * @param {number} [affectsCvss2ScoreLt] 
         * @param {number} [affectsCvss2ScoreLte] 
         * @param {string} [affectsCvss3] 
         * @param {number} [affectsCvss3Score] 
         * @param {number} [affectsCvss3ScoreGt] 
         * @param {number} [affectsCvss3ScoreGte] 
         * @param {number} [affectsCvss3ScoreLt] 
         * @param {number} [affectsCvss3ScoreLte] 
         * @param {boolean} [affectsEmbargoed] 
         * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [affectsImpact] 
         * @param {string} [affectsPsComponent] 
         * @param {string} [affectsPsModule] 
         * @param {'' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT'} [affectsResolution] 
         * @param {string} [affectsTrackersCreatedDt] 
         * @param {string} [affectsTrackersCreatedDtDate] 
         * @param {string} [affectsTrackersCreatedDtDateGte] 
         * @param {string} [affectsTrackersCreatedDtDateLte] 
         * @param {string} [affectsTrackersCreatedDtGt] 
         * @param {string} [affectsTrackersCreatedDtGte] 
         * @param {string} [affectsTrackersCreatedDtLt] 
         * @param {string} [affectsTrackersCreatedDtLte] 
         * @param {boolean} [affectsTrackersEmbargoed] 
         * @param {string} [affectsTrackersErrataAdvisoryName] 
         * @param {number} [affectsTrackersErrataEtId] 
         * @param {string} [affectsTrackersErrataShippedDt] 
         * @param {string} [affectsTrackersErrataShippedDtDate] 
         * @param {string} [affectsTrackersErrataShippedDtDateGte] 
         * @param {string} [affectsTrackersErrataShippedDtDateLte] 
         * @param {string} [affectsTrackersErrataShippedDtGt] 
         * @param {string} [affectsTrackersErrataShippedDtGte] 
         * @param {string} [affectsTrackersErrataShippedDtLt] 
         * @param {string} [affectsTrackersErrataShippedDtLte] 
         * @param {string} [affectsTrackersExternalSystemId] 
         * @param {string} [affectsTrackersPsUpdateStream] 
         * @param {string} [affectsTrackersResolution] 
         * @param {string} [affectsTrackersStatus] 
         * @param {'BUGZILLA' | 'JIRA'} [affectsTrackersType] 
         * @param {string} [affectsTrackersUpdatedDt] 
         * @param {string} [affectsTrackersUpdatedDtDate] 
         * @param {string} [affectsTrackersUpdatedDtDateGte] 
         * @param {string} [affectsTrackersUpdatedDtDateLte] 
         * @param {string} [affectsTrackersUpdatedDtGt] 
         * @param {string} [affectsTrackersUpdatedDtGte] 
         * @param {string} [affectsTrackersUpdatedDtLt] 
         * @param {string} [affectsTrackersUpdatedDtLte] 
         * @param {string} [affectsTrackersUuid] 
         * @param {'DEFAULT'} [affectsType] 
         * @param {string} [affectsUpdatedDt] 
         * @param {string} [affectsUpdatedDtDate] 
         * @param {string} [affectsUpdatedDtDateGte] 
         * @param {string} [affectsUpdatedDtDateLte] 
         * @param {string} [affectsUpdatedDtGt] 
         * @param {string} [affectsUpdatedDtGte] 
         * @param {string} [affectsUpdatedDtLt] 
         * @param {string} [affectsUpdatedDtLte] 
         * @param {string} [affectsUuid] 
         * @param {number} [bzId] 
         * @param {string} [changedAfter] 
         * @param {string} [changedBefore] 
         * @param {string} [component] 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {Array<string>} [cveId] Multiple values may be separated by commas.
         * @param {string} [cvss2] 
         * @param {number} [cvss2Score] 
         * @param {number} [cvss2ScoreGt] 
         * @param {number} [cvss2ScoreGte] 
         * @param {number} [cvss2ScoreLt] 
         * @param {number} [cvss2ScoreLte] 
         * @param {string} [cvss3] 
         * @param {number} [cvss3Score] 
         * @param {number} [cvss3ScoreGt] 
         * @param {number} [cvss3ScoreGte] 
         * @param {number} [cvss3ScoreLt] 
         * @param {number} [cvss3ScoreLte] 
         * @param {string} [cvssScoresComment] 
         * @param {string} [cvssScoresCreatedDt] 
         * @param {string} [cvssScoresCreatedDtDate] 
         * @param {string} [cvssScoresCreatedDtDateGte] 
         * @param {string} [cvssScoresCreatedDtDateLte] 
         * @param {string} [cvssScoresCreatedDtGt] 
         * @param {string} [cvssScoresCreatedDtGte] 
         * @param {string} [cvssScoresCreatedDtLt] 
         * @param {string} [cvssScoresCreatedDtLte] 
         * @param {string} [cvssScoresCvssVersion] 
         * @param {'NIST' | 'RH'} [cvssScoresIssuer] 
         * @param {number} [cvssScoresScore] 
         * @param {string} [cvssScoresUpdatedDt] 
         * @param {string} [cvssScoresUpdatedDtDate] 
         * @param {string} [cvssScoresUpdatedDtDateGte] 
         * @param {string} [cvssScoresUpdatedDtDateLte] 
         * @param {string} [cvssScoresUpdatedDtGt] 
         * @param {string} [cvssScoresUpdatedDtGte] 
         * @param {string} [cvssScoresUpdatedDtLt] 
         * @param {string} [cvssScoresUpdatedDtLte] 
         * @param {string} [cvssScoresUuid] 
         * @param {string} [cvssScoresVector] 
         * @param {string} [cweId] 
         * @param {string} [description] 
         * @param {boolean} [embargoed] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [flawMetaType] Include flaw metas with specified type only, multiple values may be separated by commas. 
         * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [impact] 
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {boolean} [isMajorIncident] 
         * @param {number} [limit] Number of results to return per page.
         * @param {'' | 'APPROVED' | 'CISA_APPROVED' | 'INVALID' | 'REJECTED' | 'REQUESTED'} [majorIncidentState] 
         * @param {'' | 'APPROVED' | 'REJECTED' | 'REQUESTED'} [nistCvssValidation] 
         * @param {string} [nvdCvss2] 
         * @param {string} [nvdCvss3] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {Array<'-acknowledgments__affiliation' | '-acknowledgments__created_dt' | '-acknowledgments__from_upstream' | '-acknowledgments__name' | '-acknowledgments__updated_dt' | '-acknowledgments__uuid' | '-affects__affectedness' | '-affects__created_dt' | '-affects__cvss2' | '-affects__cvss2_score' | '-affects__cvss3' | '-affects__cvss3_score' | '-affects__impact' | '-affects__ps_component' | '-affects__ps_module' | '-affects__resolution' | '-affects__trackers__created_dt' | '-affects__trackers__errata__advisory_name' | '-affects__trackers__errata__et_id' | '-affects__trackers__errata__shipped_dt' | '-affects__trackers__external_system_id' | '-affects__trackers__ps_update_stream' | '-affects__trackers__resolution' | '-affects__trackers__status' | '-affects__trackers__type' | '-affects__trackers__updated_dt' | '-affects__trackers__uuid' | '-affects__type' | '-affects__updated_dt' | '-affects__uuid' | '-component' | '-created_dt' | '-cve_id' | '-cvss2' | '-cvss2_score' | '-cvss3' | '-cvss3_score' | '-cvss_scores__comment' | '-cvss_scores__created_dt' | '-cvss_scores__issuer' | '-cvss_scores__score' | '-cvss_scores__updated_dt' | '-cvss_scores__uuid' | '-cvss_scores__vector' | '-cwe_id' | '-impact' | '-major_incident_state' | '-nist_cvss_validation' | '-nvd_cvss2' | '-nvd_cvss3' | '-references__created_dt' | '-references__description' | '-references__type' | '-references__updated_dt' | '-references__url' | '-references__uuid' | '-reported_dt' | '-requires_summary' | '-source' | '-type' | '-unembargo_dt' | '-updated_dt' | '-uuid' | 'acknowledgments__affiliation' | 'acknowledgments__created_dt' | 'acknowledgments__from_upstream' | 'acknowledgments__name' | 'acknowledgments__updated_dt' | 'acknowledgments__uuid' | 'affects__affectedness' | 'affects__created_dt' | 'affects__cvss2' | 'affects__cvss2_score' | 'affects__cvss3' | 'affects__cvss3_score' | 'affects__impact' | 'affects__ps_component' | 'affects__ps_module' | 'affects__resolution' | 'affects__trackers__created_dt' | 'affects__trackers__errata__advisory_name' | 'affects__trackers__errata__et_id' | 'affects__trackers__errata__shipped_dt' | 'affects__trackers__external_system_id' | 'affects__trackers__ps_update_stream' | 'affects__trackers__resolution' | 'affects__trackers__status' | 'affects__trackers__type' | 'affects__trackers__updated_dt' | 'affects__trackers__uuid' | 'affects__type' | 'affects__updated_dt' | 'affects__uuid' | 'component' | 'created_dt' | 'cve_id' | 'cvss2' | 'cvss2_score' | 'cvss3' | 'cvss3_score' | 'cvss_scores__comment' | 'cvss_scores__created_dt' | 'cvss_scores__issuer' | 'cvss_scores__score' | 'cvss_scores__updated_dt' | 'cvss_scores__uuid' | 'cvss_scores__vector' | 'cwe_id' | 'impact' | 'major_incident_state' | 'nist_cvss_validation' | 'nvd_cvss2' | 'nvd_cvss3' | 'references__created_dt' | 'references__description' | 'references__type' | 'references__updated_dt' | 'references__url' | 'references__uuid' | 'reported_dt' | 'requires_summary' | 'source' | 'type' | 'unembargo_dt' | 'updated_dt' | 'uuid'>} [order] Ordering
         * @param {string} [referencesCreatedDt] 
         * @param {string} [referencesCreatedDtDate] 
         * @param {string} [referencesCreatedDtDateGte] 
         * @param {string} [referencesCreatedDtDateLte] 
         * @param {string} [referencesCreatedDtGt] 
         * @param {string} [referencesCreatedDtGte] 
         * @param {string} [referencesCreatedDtLt] 
         * @param {string} [referencesCreatedDtLte] 
         * @param {string} [referencesDescription] 
         * @param {'ARTICLE' | 'EXTERNAL' | 'SOURCE'} [referencesType] 
         * @param {string} [referencesUpdatedDt] 
         * @param {string} [referencesUpdatedDtDate] 
         * @param {string} [referencesUpdatedDtDateGte] 
         * @param {string} [referencesUpdatedDtDateLte] 
         * @param {string} [referencesUpdatedDtGt] 
         * @param {string} [referencesUpdatedDtGte] 
         * @param {string} [referencesUpdatedDtLt] 
         * @param {string} [referencesUpdatedDtLte] 
         * @param {string} [referencesUrl] 
         * @param {string} [referencesUuid] 
         * @param {string} [reportedDt] 
         * @param {string} [reportedDtDate] 
         * @param {string} [reportedDtDateGte] 
         * @param {string} [reportedDtDateLte] 
         * @param {string} [reportedDtGt] 
         * @param {string} [reportedDtGte] 
         * @param {string} [reportedDtLt] 
         * @param {string} [reportedDtLte] 
         * @param {'' | 'APPROVED' | 'REJECTED' | 'REQUESTED'} [requiresSummary] 
         * @param {string} [search] 
         * @param {'' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF'} [source] 
         * @param {string} [statement] 
         * @param {string} [summary] 
         * @param {string} [title] 
         * @param {Array<string>} [trackerIds] Filter only Flaws which are related to specified Trackers (through Affects). Multiple tracker IDs may be separated by commas. Also only Affects that have the specified Trackers related will be shown.
         * @param {'VULNERABILITY' | 'WEAKNESS'} [type] 
         * @param {string} [unembargoDt] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsList(acknowledgmentsAffiliation?: string, acknowledgmentsCreatedDt?: string, acknowledgmentsCreatedDtDate?: string, acknowledgmentsCreatedDtDateGte?: string, acknowledgmentsCreatedDtDateLte?: string, acknowledgmentsCreatedDtGt?: string, acknowledgmentsCreatedDtGte?: string, acknowledgmentsCreatedDtLt?: string, acknowledgmentsCreatedDtLte?: string, acknowledgmentsFromUpstream?: boolean, acknowledgmentsName?: string, acknowledgmentsUpdatedDt?: string, acknowledgmentsUpdatedDtDate?: string, acknowledgmentsUpdatedDtDateGte?: string, acknowledgmentsUpdatedDtDateLte?: string, acknowledgmentsUpdatedDtGt?: string, acknowledgmentsUpdatedDtGte?: string, acknowledgmentsUpdatedDtLt?: string, acknowledgmentsUpdatedDtLte?: string, acknowledgmentsUuid?: string, affectsAffectedness?: '' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED', affectsCreatedDt?: string, affectsCreatedDtDate?: string, affectsCreatedDtDateGte?: string, affectsCreatedDtDateLte?: string, affectsCreatedDtGt?: string, affectsCreatedDtGte?: string, affectsCreatedDtLt?: string, affectsCreatedDtLte?: string, affectsCvss2?: string, affectsCvss2Score?: number, affectsCvss2ScoreGt?: number, affectsCvss2ScoreGte?: number, affectsCvss2ScoreLt?: number, affectsCvss2ScoreLte?: number, affectsCvss3?: string, affectsCvss3Score?: number, affectsCvss3ScoreGt?: number, affectsCvss3ScoreGte?: number, affectsCvss3ScoreLt?: number, affectsCvss3ScoreLte?: number, affectsEmbargoed?: boolean, affectsImpact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', affectsPsComponent?: string, affectsPsModule?: string, affectsResolution?: '' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT', affectsTrackersCreatedDt?: string, affectsTrackersCreatedDtDate?: string, affectsTrackersCreatedDtDateGte?: string, affectsTrackersCreatedDtDateLte?: string, affectsTrackersCreatedDtGt?: string, affectsTrackersCreatedDtGte?: string, affectsTrackersCreatedDtLt?: string, affectsTrackersCreatedDtLte?: string, affectsTrackersEmbargoed?: boolean, affectsTrackersErrataAdvisoryName?: string, affectsTrackersErrataEtId?: number, affectsTrackersErrataShippedDt?: string, affectsTrackersErrataShippedDtDate?: string, affectsTrackersErrataShippedDtDateGte?: string, affectsTrackersErrataShippedDtDateLte?: string, affectsTrackersErrataShippedDtGt?: string, affectsTrackersErrataShippedDtGte?: string, affectsTrackersErrataShippedDtLt?: string, affectsTrackersErrataShippedDtLte?: string, affectsTrackersExternalSystemId?: string, affectsTrackersPsUpdateStream?: string, affectsTrackersResolution?: string, affectsTrackersStatus?: string, affectsTrackersType?: 'BUGZILLA' | 'JIRA', affectsTrackersUpdatedDt?: string, affectsTrackersUpdatedDtDate?: string, affectsTrackersUpdatedDtDateGte?: string, affectsTrackersUpdatedDtDateLte?: string, affectsTrackersUpdatedDtGt?: string, affectsTrackersUpdatedDtGte?: string, affectsTrackersUpdatedDtLt?: string, affectsTrackersUpdatedDtLte?: string, affectsTrackersUuid?: string, affectsType?: 'DEFAULT', affectsUpdatedDt?: string, affectsUpdatedDtDate?: string, affectsUpdatedDtDateGte?: string, affectsUpdatedDtDateLte?: string, affectsUpdatedDtGt?: string, affectsUpdatedDtGte?: string, affectsUpdatedDtLt?: string, affectsUpdatedDtLte?: string, affectsUuid?: string, bzId?: number, changedAfter?: string, changedBefore?: string, component?: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, cveId?: Array<string>, cvss2?: string, cvss2Score?: number, cvss2ScoreGt?: number, cvss2ScoreGte?: number, cvss2ScoreLt?: number, cvss2ScoreLte?: number, cvss3?: string, cvss3Score?: number, cvss3ScoreGt?: number, cvss3ScoreGte?: number, cvss3ScoreLt?: number, cvss3ScoreLte?: number, cvssScoresComment?: string, cvssScoresCreatedDt?: string, cvssScoresCreatedDtDate?: string, cvssScoresCreatedDtDateGte?: string, cvssScoresCreatedDtDateLte?: string, cvssScoresCreatedDtGt?: string, cvssScoresCreatedDtGte?: string, cvssScoresCreatedDtLt?: string, cvssScoresCreatedDtLte?: string, cvssScoresCvssVersion?: string, cvssScoresIssuer?: 'NIST' | 'RH', cvssScoresScore?: number, cvssScoresUpdatedDt?: string, cvssScoresUpdatedDtDate?: string, cvssScoresUpdatedDtDateGte?: string, cvssScoresUpdatedDtDateLte?: string, cvssScoresUpdatedDtGt?: string, cvssScoresUpdatedDtGte?: string, cvssScoresUpdatedDtLt?: string, cvssScoresUpdatedDtLte?: string, cvssScoresUuid?: string, cvssScoresVector?: string, cweId?: string, description?: string, embargoed?: boolean, excludeFields?: Array<string>, flawMetaType?: Array<string>, impact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', includeFields?: Array<string>, includeMetaAttr?: Array<string>, isMajorIncident?: boolean, limit?: number, majorIncidentState?: '' | 'APPROVED' | 'CISA_APPROVED' | 'INVALID' | 'REJECTED' | 'REQUESTED', nistCvssValidation?: '' | 'APPROVED' | 'REJECTED' | 'REQUESTED', nvdCvss2?: string, nvdCvss3?: string, offset?: number, order?: Array<'-acknowledgments__affiliation' | '-acknowledgments__created_dt' | '-acknowledgments__from_upstream' | '-acknowledgments__name' | '-acknowledgments__updated_dt' | '-acknowledgments__uuid' | '-affects__affectedness' | '-affects__created_dt' | '-affects__cvss2' | '-affects__cvss2_score' | '-affects__cvss3' | '-affects__cvss3_score' | '-affects__impact' | '-affects__ps_component' | '-affects__ps_module' | '-affects__resolution' | '-affects__trackers__created_dt' | '-affects__trackers__errata__advisory_name' | '-affects__trackers__errata__et_id' | '-affects__trackers__errata__shipped_dt' | '-affects__trackers__external_system_id' | '-affects__trackers__ps_update_stream' | '-affects__trackers__resolution' | '-affects__trackers__status' | '-affects__trackers__type' | '-affects__trackers__updated_dt' | '-affects__trackers__uuid' | '-affects__type' | '-affects__updated_dt' | '-affects__uuid' | '-component' | '-created_dt' | '-cve_id' | '-cvss2' | '-cvss2_score' | '-cvss3' | '-cvss3_score' | '-cvss_scores__comment' | '-cvss_scores__created_dt' | '-cvss_scores__issuer' | '-cvss_scores__score' | '-cvss_scores__updated_dt' | '-cvss_scores__uuid' | '-cvss_scores__vector' | '-cwe_id' | '-impact' | '-major_incident_state' | '-nist_cvss_validation' | '-nvd_cvss2' | '-nvd_cvss3' | '-references__created_dt' | '-references__description' | '-references__type' | '-references__updated_dt' | '-references__url' | '-references__uuid' | '-reported_dt' | '-requires_summary' | '-source' | '-type' | '-unembargo_dt' | '-updated_dt' | '-uuid' | 'acknowledgments__affiliation' | 'acknowledgments__created_dt' | 'acknowledgments__from_upstream' | 'acknowledgments__name' | 'acknowledgments__updated_dt' | 'acknowledgments__uuid' | 'affects__affectedness' | 'affects__created_dt' | 'affects__cvss2' | 'affects__cvss2_score' | 'affects__cvss3' | 'affects__cvss3_score' | 'affects__impact' | 'affects__ps_component' | 'affects__ps_module' | 'affects__resolution' | 'affects__trackers__created_dt' | 'affects__trackers__errata__advisory_name' | 'affects__trackers__errata__et_id' | 'affects__trackers__errata__shipped_dt' | 'affects__trackers__external_system_id' | 'affects__trackers__ps_update_stream' | 'affects__trackers__resolution' | 'affects__trackers__status' | 'affects__trackers__type' | 'affects__trackers__updated_dt' | 'affects__trackers__uuid' | 'affects__type' | 'affects__updated_dt' | 'affects__uuid' | 'component' | 'created_dt' | 'cve_id' | 'cvss2' | 'cvss2_score' | 'cvss3' | 'cvss3_score' | 'cvss_scores__comment' | 'cvss_scores__created_dt' | 'cvss_scores__issuer' | 'cvss_scores__score' | 'cvss_scores__updated_dt' | 'cvss_scores__uuid' | 'cvss_scores__vector' | 'cwe_id' | 'impact' | 'major_incident_state' | 'nist_cvss_validation' | 'nvd_cvss2' | 'nvd_cvss3' | 'references__created_dt' | 'references__description' | 'references__type' | 'references__updated_dt' | 'references__url' | 'references__uuid' | 'reported_dt' | 'requires_summary' | 'source' | 'type' | 'unembargo_dt' | 'updated_dt' | 'uuid'>, referencesCreatedDt?: string, referencesCreatedDtDate?: string, referencesCreatedDtDateGte?: string, referencesCreatedDtDateLte?: string, referencesCreatedDtGt?: string, referencesCreatedDtGte?: string, referencesCreatedDtLt?: string, referencesCreatedDtLte?: string, referencesDescription?: string, referencesType?: 'ARTICLE' | 'EXTERNAL' | 'SOURCE', referencesUpdatedDt?: string, referencesUpdatedDtDate?: string, referencesUpdatedDtDateGte?: string, referencesUpdatedDtDateLte?: string, referencesUpdatedDtGt?: string, referencesUpdatedDtGte?: string, referencesUpdatedDtLt?: string, referencesUpdatedDtLte?: string, referencesUrl?: string, referencesUuid?: string, reportedDt?: string, reportedDtDate?: string, reportedDtDateGte?: string, reportedDtDateLte?: string, reportedDtGt?: string, reportedDtGte?: string, reportedDtLt?: string, reportedDtLte?: string, requiresSummary?: '' | 'APPROVED' | 'REJECTED' | 'REQUESTED', search?: string, source?: '' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF', statement?: string, summary?: string, title?: string, trackerIds?: Array<string>, type?: 'VULNERABILITY' | 'WEAKNESS', unembargoDt?: string, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsList(acknowledgmentsAffiliation, acknowledgmentsCreatedDt, acknowledgmentsCreatedDtDate, acknowledgmentsCreatedDtDateGte, acknowledgmentsCreatedDtDateLte, acknowledgmentsCreatedDtGt, acknowledgmentsCreatedDtGte, acknowledgmentsCreatedDtLt, acknowledgmentsCreatedDtLte, acknowledgmentsFromUpstream, acknowledgmentsName, acknowledgmentsUpdatedDt, acknowledgmentsUpdatedDtDate, acknowledgmentsUpdatedDtDateGte, acknowledgmentsUpdatedDtDateLte, acknowledgmentsUpdatedDtGt, acknowledgmentsUpdatedDtGte, acknowledgmentsUpdatedDtLt, acknowledgmentsUpdatedDtLte, acknowledgmentsUuid, affectsAffectedness, affectsCreatedDt, affectsCreatedDtDate, affectsCreatedDtDateGte, affectsCreatedDtDateLte, affectsCreatedDtGt, affectsCreatedDtGte, affectsCreatedDtLt, affectsCreatedDtLte, affectsCvss2, affectsCvss2Score, affectsCvss2ScoreGt, affectsCvss2ScoreGte, affectsCvss2ScoreLt, affectsCvss2ScoreLte, affectsCvss3, affectsCvss3Score, affectsCvss3ScoreGt, affectsCvss3ScoreGte, affectsCvss3ScoreLt, affectsCvss3ScoreLte, affectsEmbargoed, affectsImpact, affectsPsComponent, affectsPsModule, affectsResolution, affectsTrackersCreatedDt, affectsTrackersCreatedDtDate, affectsTrackersCreatedDtDateGte, affectsTrackersCreatedDtDateLte, affectsTrackersCreatedDtGt, affectsTrackersCreatedDtGte, affectsTrackersCreatedDtLt, affectsTrackersCreatedDtLte, affectsTrackersEmbargoed, affectsTrackersErrataAdvisoryName, affectsTrackersErrataEtId, affectsTrackersErrataShippedDt, affectsTrackersErrataShippedDtDate, affectsTrackersErrataShippedDtDateGte, affectsTrackersErrataShippedDtDateLte, affectsTrackersErrataShippedDtGt, affectsTrackersErrataShippedDtGte, affectsTrackersErrataShippedDtLt, affectsTrackersErrataShippedDtLte, affectsTrackersExternalSystemId, affectsTrackersPsUpdateStream, affectsTrackersResolution, affectsTrackersStatus, affectsTrackersType, affectsTrackersUpdatedDt, affectsTrackersUpdatedDtDate, affectsTrackersUpdatedDtDateGte, affectsTrackersUpdatedDtDateLte, affectsTrackersUpdatedDtGt, affectsTrackersUpdatedDtGte, affectsTrackersUpdatedDtLt, affectsTrackersUpdatedDtLte, affectsTrackersUuid, affectsType, affectsUpdatedDt, affectsUpdatedDtDate, affectsUpdatedDtDateGte, affectsUpdatedDtDateLte, affectsUpdatedDtGt, affectsUpdatedDtGte, affectsUpdatedDtLt, affectsUpdatedDtLte, affectsUuid, bzId, changedAfter, changedBefore, component, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, cveId, cvss2, cvss2Score, cvss2ScoreGt, cvss2ScoreGte, cvss2ScoreLt, cvss2ScoreLte, cvss3, cvss3Score, cvss3ScoreGt, cvss3ScoreGte, cvss3ScoreLt, cvss3ScoreLte, cvssScoresComment, cvssScoresCreatedDt, cvssScoresCreatedDtDate, cvssScoresCreatedDtDateGte, cvssScoresCreatedDtDateLte, cvssScoresCreatedDtGt, cvssScoresCreatedDtGte, cvssScoresCreatedDtLt, cvssScoresCreatedDtLte, cvssScoresCvssVersion, cvssScoresIssuer, cvssScoresScore, cvssScoresUpdatedDt, cvssScoresUpdatedDtDate, cvssScoresUpdatedDtDateGte, cvssScoresUpdatedDtDateLte, cvssScoresUpdatedDtGt, cvssScoresUpdatedDtGte, cvssScoresUpdatedDtLt, cvssScoresUpdatedDtLte, cvssScoresUuid, cvssScoresVector, cweId, description, embargoed, excludeFields, flawMetaType, impact, includeFields, includeMetaAttr, isMajorIncident, limit, majorIncidentState, nistCvssValidation, nvdCvss2, nvdCvss3, offset, order, referencesCreatedDt, referencesCreatedDtDate, referencesCreatedDtDateGte, referencesCreatedDtDateLte, referencesCreatedDtGt, referencesCreatedDtGte, referencesCreatedDtLt, referencesCreatedDtLte, referencesDescription, referencesType, referencesUpdatedDt, referencesUpdatedDtDate, referencesUpdatedDtDateGte, referencesUpdatedDtDateLte, referencesUpdatedDtGt, referencesUpdatedDtGte, referencesUpdatedDtLt, referencesUpdatedDtLte, referencesUrl, referencesUuid, reportedDt, reportedDtDate, reportedDtDateGte, reportedDtDateLte, reportedDtGt, reportedDtGte, reportedDtLt, reportedDtLte, requiresSummary, search, source, statement, summary, title, trackerIds, type, unembargoDt, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} flawId 
         * @param {FlawPackageVersionPost} flawPackageVersionPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsPackageVersionsCreate(flawId: string, flawPackageVersionPost: FlawPackageVersionPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsPackageVersionsCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsPackageVersionsCreate(flawId, flawPackageVersionPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Destroy the instance and proxy the delete to Bugzilla
         * @param {string} flawId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsPackageVersionsDestroy(flawId: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200ResponseAllOf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsPackageVersionsDestroy(flawId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [_package] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {string} [versionsVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsPackageVersionsList(flawId: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, excludeFields?: Array<string>, includeFields?: Array<string>, limit?: number, offset?: number, _package?: string, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, versionsVersion?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsPackageVersionsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsPackageVersionsList(flawId, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, excludeFields, includeFields, limit, offset, _package, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, versionsVersion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} id 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsPackageVersionsRetrieve(flawId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsPackageVersionsCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsPackageVersionsRetrieve(flawId, id, excludeFields, includeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} id 
         * @param {FlawPackageVersionPut} flawPackageVersionPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsPackageVersionsUpdate(flawId: string, id: string, flawPackageVersionPut: FlawPackageVersionPut, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsPackageVersionsCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsPackageVersionsUpdate(flawId, id, flawPackageVersionPut, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} flawId 
         * @param {FlawReferencePost} flawReferencePost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsReferencesCreate(flawId: string, flawReferencePost: FlawReferencePost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsReferencesCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsReferencesCreate(flawId, flawReferencePost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Destroy the instance and proxy the delete to Bugzilla
         * @param {string} flawId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsReferencesDestroy(flawId: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200ResponseAllOf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsReferencesDestroy(flawId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {string} [description] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {'ARTICLE' | 'EXTERNAL' | 'SOURCE'} [type] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [url] 
         * @param {string} [uuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsReferencesList(flawId: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, description?: string, excludeFields?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, limit?: number, offset?: number, type?: 'ARTICLE' | 'EXTERNAL' | 'SOURCE', updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, url?: string, uuid?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsReferencesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsReferencesList(flawId, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, description, excludeFields, includeFields, includeMetaAttr, limit, offset, type, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, url, uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} id 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsReferencesRetrieve(flawId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsReferencesCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsReferencesRetrieve(flawId, id, excludeFields, includeFields, includeMetaAttr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} id 
         * @param {FlawReferencePut} flawReferencePut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsReferencesUpdate(flawId: string, id: string, flawReferencePut: FlawReferencePut, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsReferencesCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsReferencesUpdate(flawId, id, flawReferencePut, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [flawMetaType] Include flaw metas with specified type only, multiple values may be separated by commas. 
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {Array<string>} [trackerIds] Filter only Flaws which are related to specified Trackers (through Affects). Multiple tracker IDs may be separated by commas. Also only Affects that have the specified Trackers related will be shown.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsRetrieve(id: string, excludeFields?: Array<string>, flawMetaType?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, trackerIds?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsRetrieve(id, excludeFields, flawMetaType, includeFields, includeMetaAttr, trackerIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {string} id A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
         * @param {Flaw} flaw 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsUpdate(bugzillaApiKey: string, jiraApiKey: string, id: string, flaw: Flaw, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsUpdate(bugzillaApiKey, jiraApiKey, id, flaw, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * HTTP get /manifest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1ManifestRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200ResponseAllOf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1ManifestRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {'json' | 'yaml'} [format] 
         * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1SchemaRetrieve(format?: 'json' | 'yaml', lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1SchemaRetrieve(format, lang, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * HTTP get /status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1StatusRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1StatusRetrieve200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1StatusRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {TrackerPost} trackerPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1TrackersCreate(bugzillaApiKey: string, jiraApiKey: string, trackerPost: TrackerPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1TrackersCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1TrackersCreate(bugzillaApiKey, jiraApiKey, trackerPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {'' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED'} [affectsAffectedness] 
         * @param {string} [affectsCreatedDt] 
         * @param {string} [affectsCreatedDtDate] 
         * @param {string} [affectsCreatedDtDateGte] 
         * @param {string} [affectsCreatedDtDateLte] 
         * @param {string} [affectsCreatedDtGt] 
         * @param {string} [affectsCreatedDtGte] 
         * @param {string} [affectsCreatedDtLt] 
         * @param {string} [affectsCreatedDtLte] 
         * @param {string} [affectsCvss2] 
         * @param {number} [affectsCvss2Score] 
         * @param {number} [affectsCvss2ScoreGt] 
         * @param {number} [affectsCvss2ScoreGte] 
         * @param {number} [affectsCvss2ScoreLt] 
         * @param {number} [affectsCvss2ScoreLte] 
         * @param {string} [affectsCvss3] 
         * @param {number} [affectsCvss3Score] 
         * @param {number} [affectsCvss3ScoreGt] 
         * @param {number} [affectsCvss3ScoreGte] 
         * @param {number} [affectsCvss3ScoreLt] 
         * @param {number} [affectsCvss3ScoreLte] 
         * @param {boolean} [affectsEmbargoed] 
         * @param {string} [affectsFlawComponent] 
         * @param {string} [affectsFlawCreatedDt] 
         * @param {string} [affectsFlawCreatedDtDate] 
         * @param {string} [affectsFlawCreatedDtDateGte] 
         * @param {string} [affectsFlawCreatedDtDateLte] 
         * @param {string} [affectsFlawCreatedDtGt] 
         * @param {string} [affectsFlawCreatedDtGte] 
         * @param {string} [affectsFlawCreatedDtLt] 
         * @param {string} [affectsFlawCreatedDtLte] 
         * @param {string} [affectsFlawCveId] 
         * @param {string} [affectsFlawCvss2] 
         * @param {number} [affectsFlawCvss2Score] 
         * @param {number} [affectsFlawCvss2ScoreGt] 
         * @param {number} [affectsFlawCvss2ScoreGte] 
         * @param {number} [affectsFlawCvss2ScoreLt] 
         * @param {number} [affectsFlawCvss2ScoreLte] 
         * @param {string} [affectsFlawCvss3] 
         * @param {number} [affectsFlawCvss3Score] 
         * @param {number} [affectsFlawCvss3ScoreGt] 
         * @param {number} [affectsFlawCvss3ScoreGte] 
         * @param {number} [affectsFlawCvss3ScoreLt] 
         * @param {number} [affectsFlawCvss3ScoreLte] 
         * @param {string} [affectsFlawCweId] 
         * @param {boolean} [affectsFlawEmbargoed] 
         * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [affectsFlawImpact] 
         * @param {boolean} [affectsFlawIsMajorIncident] 
         * @param {string} [affectsFlawNvdCvss2] 
         * @param {string} [affectsFlawNvdCvss3] 
         * @param {string} [affectsFlawReportedDt] 
         * @param {string} [affectsFlawReportedDtDate] 
         * @param {string} [affectsFlawReportedDtDateGte] 
         * @param {string} [affectsFlawReportedDtDateLte] 
         * @param {string} [affectsFlawReportedDtGt] 
         * @param {string} [affectsFlawReportedDtGte] 
         * @param {string} [affectsFlawReportedDtLt] 
         * @param {string} [affectsFlawReportedDtLte] 
         * @param {'' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF'} [affectsFlawSource] 
         * @param {'VULNERABILITY' | 'WEAKNESS'} [affectsFlawType] 
         * @param {string} [affectsFlawUnembargoDt] 
         * @param {string} [affectsFlawUpdatedDt] 
         * @param {string} [affectsFlawUpdatedDtDate] 
         * @param {string} [affectsFlawUpdatedDtDateGte] 
         * @param {string} [affectsFlawUpdatedDtDateLte] 
         * @param {string} [affectsFlawUpdatedDtGt] 
         * @param {string} [affectsFlawUpdatedDtGte] 
         * @param {string} [affectsFlawUpdatedDtLt] 
         * @param {string} [affectsFlawUpdatedDtLte] 
         * @param {string} [affectsFlawUuid] 
         * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [affectsImpact] 
         * @param {string} [affectsPsComponent] 
         * @param {string} [affectsPsModule] 
         * @param {'' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT'} [affectsResolution] 
         * @param {'DEFAULT'} [affectsType] 
         * @param {string} [affectsUpdatedDt] 
         * @param {string} [affectsUpdatedDtDate] 
         * @param {string} [affectsUpdatedDtDateGte] 
         * @param {string} [affectsUpdatedDtDateLte] 
         * @param {string} [affectsUpdatedDtGt] 
         * @param {string} [affectsUpdatedDtGte] 
         * @param {string} [affectsUpdatedDtLt] 
         * @param {string} [affectsUpdatedDtLte] 
         * @param {string} [affectsUuid] 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {boolean} [embargoed] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {string} [externalSystemId] 
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {Array<'-affects__affectedness' | '-affects__created_dt' | '-affects__cvss2' | '-affects__cvss2_score' | '-affects__cvss3' | '-affects__cvss3_score' | '-affects__flaw__component' | '-affects__flaw__created_dt' | '-affects__flaw__cve_id' | '-affects__flaw__cvss2' | '-affects__flaw__cvss2_score' | '-affects__flaw__cvss3' | '-affects__flaw__cvss3_score' | '-affects__flaw__cwe_id' | '-affects__flaw__impact' | '-affects__flaw__nvd_cvss2' | '-affects__flaw__nvd_cvss3' | '-affects__flaw__reported_dt' | '-affects__flaw__source' | '-affects__flaw__type' | '-affects__flaw__unembargo_dt' | '-affects__flaw__updated_dt' | '-affects__flaw__uuid' | '-affects__impact' | '-affects__ps_component' | '-affects__ps_module' | '-affects__resolution' | '-affects__type' | '-affects__updated_dt' | '-affects__uuid' | '-created_dt' | '-external_system_id' | '-ps_update_stream' | '-resolution' | '-status' | '-type' | '-updated_dt' | '-uuid' | 'affects__affectedness' | 'affects__created_dt' | 'affects__cvss2' | 'affects__cvss2_score' | 'affects__cvss3' | 'affects__cvss3_score' | 'affects__flaw__component' | 'affects__flaw__created_dt' | 'affects__flaw__cve_id' | 'affects__flaw__cvss2' | 'affects__flaw__cvss2_score' | 'affects__flaw__cvss3' | 'affects__flaw__cvss3_score' | 'affects__flaw__cwe_id' | 'affects__flaw__impact' | 'affects__flaw__nvd_cvss2' | 'affects__flaw__nvd_cvss3' | 'affects__flaw__reported_dt' | 'affects__flaw__source' | 'affects__flaw__type' | 'affects__flaw__unembargo_dt' | 'affects__flaw__updated_dt' | 'affects__flaw__uuid' | 'affects__impact' | 'affects__ps_component' | 'affects__ps_module' | 'affects__resolution' | 'affects__type' | 'affects__updated_dt' | 'affects__uuid' | 'created_dt' | 'external_system_id' | 'ps_update_stream' | 'resolution' | 'status' | 'type' | 'updated_dt' | 'uuid'>} [order] Ordering
         * @param {string} [psUpdateStream] 
         * @param {string} [resolution] 
         * @param {string} [status] 
         * @param {'BUGZILLA' | 'JIRA'} [type] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1TrackersList(affectsAffectedness?: '' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED', affectsCreatedDt?: string, affectsCreatedDtDate?: string, affectsCreatedDtDateGte?: string, affectsCreatedDtDateLte?: string, affectsCreatedDtGt?: string, affectsCreatedDtGte?: string, affectsCreatedDtLt?: string, affectsCreatedDtLte?: string, affectsCvss2?: string, affectsCvss2Score?: number, affectsCvss2ScoreGt?: number, affectsCvss2ScoreGte?: number, affectsCvss2ScoreLt?: number, affectsCvss2ScoreLte?: number, affectsCvss3?: string, affectsCvss3Score?: number, affectsCvss3ScoreGt?: number, affectsCvss3ScoreGte?: number, affectsCvss3ScoreLt?: number, affectsCvss3ScoreLte?: number, affectsEmbargoed?: boolean, affectsFlawComponent?: string, affectsFlawCreatedDt?: string, affectsFlawCreatedDtDate?: string, affectsFlawCreatedDtDateGte?: string, affectsFlawCreatedDtDateLte?: string, affectsFlawCreatedDtGt?: string, affectsFlawCreatedDtGte?: string, affectsFlawCreatedDtLt?: string, affectsFlawCreatedDtLte?: string, affectsFlawCveId?: string, affectsFlawCvss2?: string, affectsFlawCvss2Score?: number, affectsFlawCvss2ScoreGt?: number, affectsFlawCvss2ScoreGte?: number, affectsFlawCvss2ScoreLt?: number, affectsFlawCvss2ScoreLte?: number, affectsFlawCvss3?: string, affectsFlawCvss3Score?: number, affectsFlawCvss3ScoreGt?: number, affectsFlawCvss3ScoreGte?: number, affectsFlawCvss3ScoreLt?: number, affectsFlawCvss3ScoreLte?: number, affectsFlawCweId?: string, affectsFlawEmbargoed?: boolean, affectsFlawImpact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', affectsFlawIsMajorIncident?: boolean, affectsFlawNvdCvss2?: string, affectsFlawNvdCvss3?: string, affectsFlawReportedDt?: string, affectsFlawReportedDtDate?: string, affectsFlawReportedDtDateGte?: string, affectsFlawReportedDtDateLte?: string, affectsFlawReportedDtGt?: string, affectsFlawReportedDtGte?: string, affectsFlawReportedDtLt?: string, affectsFlawReportedDtLte?: string, affectsFlawSource?: '' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF', affectsFlawType?: 'VULNERABILITY' | 'WEAKNESS', affectsFlawUnembargoDt?: string, affectsFlawUpdatedDt?: string, affectsFlawUpdatedDtDate?: string, affectsFlawUpdatedDtDateGte?: string, affectsFlawUpdatedDtDateLte?: string, affectsFlawUpdatedDtGt?: string, affectsFlawUpdatedDtGte?: string, affectsFlawUpdatedDtLt?: string, affectsFlawUpdatedDtLte?: string, affectsFlawUuid?: string, affectsImpact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', affectsPsComponent?: string, affectsPsModule?: string, affectsResolution?: '' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT', affectsType?: 'DEFAULT', affectsUpdatedDt?: string, affectsUpdatedDtDate?: string, affectsUpdatedDtDateGte?: string, affectsUpdatedDtDateLte?: string, affectsUpdatedDtGt?: string, affectsUpdatedDtGte?: string, affectsUpdatedDtLt?: string, affectsUpdatedDtLte?: string, affectsUuid?: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, embargoed?: boolean, excludeFields?: Array<string>, externalSystemId?: string, includeFields?: Array<string>, includeMetaAttr?: Array<string>, limit?: number, offset?: number, order?: Array<'-affects__affectedness' | '-affects__created_dt' | '-affects__cvss2' | '-affects__cvss2_score' | '-affects__cvss3' | '-affects__cvss3_score' | '-affects__flaw__component' | '-affects__flaw__created_dt' | '-affects__flaw__cve_id' | '-affects__flaw__cvss2' | '-affects__flaw__cvss2_score' | '-affects__flaw__cvss3' | '-affects__flaw__cvss3_score' | '-affects__flaw__cwe_id' | '-affects__flaw__impact' | '-affects__flaw__nvd_cvss2' | '-affects__flaw__nvd_cvss3' | '-affects__flaw__reported_dt' | '-affects__flaw__source' | '-affects__flaw__type' | '-affects__flaw__unembargo_dt' | '-affects__flaw__updated_dt' | '-affects__flaw__uuid' | '-affects__impact' | '-affects__ps_component' | '-affects__ps_module' | '-affects__resolution' | '-affects__type' | '-affects__updated_dt' | '-affects__uuid' | '-created_dt' | '-external_system_id' | '-ps_update_stream' | '-resolution' | '-status' | '-type' | '-updated_dt' | '-uuid' | 'affects__affectedness' | 'affects__created_dt' | 'affects__cvss2' | 'affects__cvss2_score' | 'affects__cvss3' | 'affects__cvss3_score' | 'affects__flaw__component' | 'affects__flaw__created_dt' | 'affects__flaw__cve_id' | 'affects__flaw__cvss2' | 'affects__flaw__cvss2_score' | 'affects__flaw__cvss3' | 'affects__flaw__cvss3_score' | 'affects__flaw__cwe_id' | 'affects__flaw__impact' | 'affects__flaw__nvd_cvss2' | 'affects__flaw__nvd_cvss3' | 'affects__flaw__reported_dt' | 'affects__flaw__source' | 'affects__flaw__type' | 'affects__flaw__unembargo_dt' | 'affects__flaw__updated_dt' | 'affects__flaw__uuid' | 'affects__impact' | 'affects__ps_component' | 'affects__ps_module' | 'affects__resolution' | 'affects__type' | 'affects__updated_dt' | 'affects__uuid' | 'created_dt' | 'external_system_id' | 'ps_update_stream' | 'resolution' | 'status' | 'type' | 'updated_dt' | 'uuid'>, psUpdateStream?: string, resolution?: string, status?: string, type?: 'BUGZILLA' | 'JIRA', updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1TrackersList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1TrackersList(affectsAffectedness, affectsCreatedDt, affectsCreatedDtDate, affectsCreatedDtDateGte, affectsCreatedDtDateLte, affectsCreatedDtGt, affectsCreatedDtGte, affectsCreatedDtLt, affectsCreatedDtLte, affectsCvss2, affectsCvss2Score, affectsCvss2ScoreGt, affectsCvss2ScoreGte, affectsCvss2ScoreLt, affectsCvss2ScoreLte, affectsCvss3, affectsCvss3Score, affectsCvss3ScoreGt, affectsCvss3ScoreGte, affectsCvss3ScoreLt, affectsCvss3ScoreLte, affectsEmbargoed, affectsFlawComponent, affectsFlawCreatedDt, affectsFlawCreatedDtDate, affectsFlawCreatedDtDateGte, affectsFlawCreatedDtDateLte, affectsFlawCreatedDtGt, affectsFlawCreatedDtGte, affectsFlawCreatedDtLt, affectsFlawCreatedDtLte, affectsFlawCveId, affectsFlawCvss2, affectsFlawCvss2Score, affectsFlawCvss2ScoreGt, affectsFlawCvss2ScoreGte, affectsFlawCvss2ScoreLt, affectsFlawCvss2ScoreLte, affectsFlawCvss3, affectsFlawCvss3Score, affectsFlawCvss3ScoreGt, affectsFlawCvss3ScoreGte, affectsFlawCvss3ScoreLt, affectsFlawCvss3ScoreLte, affectsFlawCweId, affectsFlawEmbargoed, affectsFlawImpact, affectsFlawIsMajorIncident, affectsFlawNvdCvss2, affectsFlawNvdCvss3, affectsFlawReportedDt, affectsFlawReportedDtDate, affectsFlawReportedDtDateGte, affectsFlawReportedDtDateLte, affectsFlawReportedDtGt, affectsFlawReportedDtGte, affectsFlawReportedDtLt, affectsFlawReportedDtLte, affectsFlawSource, affectsFlawType, affectsFlawUnembargoDt, affectsFlawUpdatedDt, affectsFlawUpdatedDtDate, affectsFlawUpdatedDtDateGte, affectsFlawUpdatedDtDateLte, affectsFlawUpdatedDtGt, affectsFlawUpdatedDtGte, affectsFlawUpdatedDtLt, affectsFlawUpdatedDtLte, affectsFlawUuid, affectsImpact, affectsPsComponent, affectsPsModule, affectsResolution, affectsType, affectsUpdatedDt, affectsUpdatedDtDate, affectsUpdatedDtDateGte, affectsUpdatedDtDateLte, affectsUpdatedDtGt, affectsUpdatedDtGte, affectsUpdatedDtLt, affectsUpdatedDtLte, affectsUuid, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, embargoed, excludeFields, externalSystemId, includeFields, includeMetaAttr, limit, offset, order, psUpdateStream, resolution, status, type, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid A UUID string identifying this Tracker.
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1TrackersRetrieve(uuid: string, excludeFields?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1TrackersCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1TrackersRetrieve(uuid, excludeFields, includeFields, includeMetaAttr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {string} uuid A UUID string identifying this Tracker.
         * @param {Tracker} tracker 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1TrackersUpdate(bugzillaApiKey: string, jiraApiKey: string, uuid: string, tracker: Tracker, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1TrackersCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1TrackersUpdate(bugzillaApiKey, jiraApiKey, uuid, tracker, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * unauthenticated view providing healthcheck on osidb service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbHealthyRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200ResponseAllOf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbHealthyRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * View that provides information about the currently logged-in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbWhoamiRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbWhoamiRetrieve200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbWhoamiRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OsidbApi - factory interface
 * @export
 */
export const OsidbApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OsidbApiFp(configuration)
    return {
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {AffectPost} affectPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsCreate(bugzillaApiKey: string, affectPost: AffectPost, options?: any): AxiosPromise<OsidbApiV1AffectsCreate201Response> {
            return localVarFp.osidbApiV1AffectsCreate(bugzillaApiKey, affectPost, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} affectId 
         * @param {AffectCVSSPost} affectCVSSPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsCvssScoresCreate(affectId: string, affectCVSSPost: AffectCVSSPost, options?: any): AxiosPromise<OsidbApiV1AffectsCvssScoresCreate201Response> {
            return localVarFp.osidbApiV1AffectsCvssScoresCreate(affectId, affectCVSSPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Destroy the instance and proxy the delete to Bugzilla.
         * @param {string} affectId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsCvssScoresDestroy(affectId: string, id: string, options?: any): AxiosPromise<AuthTokenCreate200ResponseAllOf> {
            return localVarFp.osidbApiV1AffectsCvssScoresDestroy(affectId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} affectId 
         * @param {string} [comment] 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {string} [cvssVersion] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {'NIST' | 'RH'} [issuer] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {number} [score] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {string} [vector] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsCvssScoresList(affectId: string, comment?: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, cvssVersion?: string, excludeFields?: Array<string>, includeFields?: Array<string>, issuer?: 'NIST' | 'RH', limit?: number, offset?: number, score?: number, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, vector?: string, options?: any): AxiosPromise<OsidbApiV1AffectsCvssScoresList200Response> {
            return localVarFp.osidbApiV1AffectsCvssScoresList(affectId, comment, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, cvssVersion, excludeFields, includeFields, issuer, limit, offset, score, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, vector, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} affectId 
         * @param {string} id 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsCvssScoresRetrieve(affectId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, options?: any): AxiosPromise<OsidbApiV1AffectsCvssScoresCreate201Response> {
            return localVarFp.osidbApiV1AffectsCvssScoresRetrieve(affectId, id, excludeFields, includeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} affectId 
         * @param {string} id 
         * @param {AffectCVSSPut} affectCVSSPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsCvssScoresUpdate(affectId: string, id: string, affectCVSSPut: AffectCVSSPut, options?: any): AxiosPromise<OsidbApiV1AffectsCvssScoresCreate201Response> {
            return localVarFp.osidbApiV1AffectsCvssScoresUpdate(affectId, id, affectCVSSPut, options).then((request) => request(axios, basePath));
        },
        /**
         * Destroy the instance and proxy the delete to Bugzilla
         * @param {string} uuid A UUID string identifying this Affect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsDestroy(uuid: string, options?: any): AxiosPromise<AuthTokenCreate200ResponseAllOf> {
            return localVarFp.osidbApiV1AffectsDestroy(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {'' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED'} [affectedness] 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {string} [cvss2] 
         * @param {number} [cvss2Score] 
         * @param {number} [cvss2ScoreGt] 
         * @param {number} [cvss2ScoreGte] 
         * @param {number} [cvss2ScoreLt] 
         * @param {number} [cvss2ScoreLte] 
         * @param {string} [cvss3] 
         * @param {number} [cvss3Score] 
         * @param {number} [cvss3ScoreGt] 
         * @param {number} [cvss3ScoreGte] 
         * @param {number} [cvss3ScoreLt] 
         * @param {number} [cvss3ScoreLte] 
         * @param {string} [cvssScoresComment] 
         * @param {string} [cvssScoresCreatedDt] 
         * @param {string} [cvssScoresCreatedDtDate] 
         * @param {string} [cvssScoresCreatedDtDateGte] 
         * @param {string} [cvssScoresCreatedDtDateLte] 
         * @param {string} [cvssScoresCreatedDtGt] 
         * @param {string} [cvssScoresCreatedDtGte] 
         * @param {string} [cvssScoresCreatedDtLt] 
         * @param {string} [cvssScoresCreatedDtLte] 
         * @param {string} [cvssScoresCvssVersion] 
         * @param {'NIST' | 'RH'} [cvssScoresIssuer] 
         * @param {number} [cvssScoresScore] 
         * @param {string} [cvssScoresUpdatedDt] 
         * @param {string} [cvssScoresUpdatedDtDate] 
         * @param {string} [cvssScoresUpdatedDtDateGte] 
         * @param {string} [cvssScoresUpdatedDtDateLte] 
         * @param {string} [cvssScoresUpdatedDtGt] 
         * @param {string} [cvssScoresUpdatedDtGte] 
         * @param {string} [cvssScoresUpdatedDtLt] 
         * @param {string} [cvssScoresUpdatedDtLte] 
         * @param {string} [cvssScoresUuid] 
         * @param {string} [cvssScoresVector] 
         * @param {boolean} [embargoed] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {string} [flawComponent] 
         * @param {string} [flawCreatedDt] 
         * @param {string} [flawCreatedDtDate] 
         * @param {string} [flawCreatedDtDateGte] 
         * @param {string} [flawCreatedDtDateLte] 
         * @param {string} [flawCreatedDtGt] 
         * @param {string} [flawCreatedDtGte] 
         * @param {string} [flawCreatedDtLt] 
         * @param {string} [flawCreatedDtLte] 
         * @param {string} [flawCveId] 
         * @param {string} [flawCvss2] 
         * @param {number} [flawCvss2Score] 
         * @param {number} [flawCvss2ScoreGt] 
         * @param {number} [flawCvss2ScoreGte] 
         * @param {number} [flawCvss2ScoreLt] 
         * @param {number} [flawCvss2ScoreLte] 
         * @param {string} [flawCvss3] 
         * @param {number} [flawCvss3Score] 
         * @param {number} [flawCvss3ScoreGt] 
         * @param {number} [flawCvss3ScoreGte] 
         * @param {number} [flawCvss3ScoreLt] 
         * @param {number} [flawCvss3ScoreLte] 
         * @param {string} [flawCweId] 
         * @param {boolean} [flawEmbargoed] 
         * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [flawImpact] 
         * @param {boolean} [flawIsMajorIncident] 
         * @param {string} [flawNvdCvss2] 
         * @param {string} [flawNvdCvss3] 
         * @param {string} [flawReportedDt] 
         * @param {string} [flawReportedDtDate] 
         * @param {string} [flawReportedDtDateGte] 
         * @param {string} [flawReportedDtDateLte] 
         * @param {string} [flawReportedDtGt] 
         * @param {string} [flawReportedDtGte] 
         * @param {string} [flawReportedDtLt] 
         * @param {string} [flawReportedDtLte] 
         * @param {'' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF'} [flawSource] 
         * @param {'VULNERABILITY' | 'WEAKNESS'} [flawType] 
         * @param {string} [flawUnembargoDt] 
         * @param {string} [flawUpdatedDt] 
         * @param {string} [flawUpdatedDtDate] 
         * @param {string} [flawUpdatedDtDateGte] 
         * @param {string} [flawUpdatedDtDateLte] 
         * @param {string} [flawUpdatedDtGt] 
         * @param {string} [flawUpdatedDtGte] 
         * @param {string} [flawUpdatedDtLt] 
         * @param {string} [flawUpdatedDtLte] 
         * @param {string} [flawUuid] 
         * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [impact] 
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {Array<'-affectedness' | '-created_dt' | '-cvss2' | '-cvss2_score' | '-cvss3' | '-cvss3_score' | '-cvss_scores__comment' | '-cvss_scores__created_dt' | '-cvss_scores__issuer' | '-cvss_scores__score' | '-cvss_scores__updated_dt' | '-cvss_scores__uuid' | '-cvss_scores__vector' | '-flaw__component' | '-flaw__created_dt' | '-flaw__cve_id' | '-flaw__cvss2' | '-flaw__cvss2_score' | '-flaw__cvss3' | '-flaw__cvss3_score' | '-flaw__cwe_id' | '-flaw__impact' | '-flaw__nvd_cvss2' | '-flaw__nvd_cvss3' | '-flaw__reported_dt' | '-flaw__source' | '-flaw__type' | '-flaw__unembargo_dt' | '-flaw__updated_dt' | '-flaw__uuid' | '-impact' | '-ps_component' | '-ps_module' | '-resolution' | '-trackers__created_dt' | '-trackers__external_system_id' | '-trackers__ps_update_stream' | '-trackers__resolution' | '-trackers__status' | '-trackers__type' | '-trackers__updated_dt' | '-trackers__uuid' | '-type' | '-updated_dt' | '-uuid' | 'affectedness' | 'created_dt' | 'cvss2' | 'cvss2_score' | 'cvss3' | 'cvss3_score' | 'cvss_scores__comment' | 'cvss_scores__created_dt' | 'cvss_scores__issuer' | 'cvss_scores__score' | 'cvss_scores__updated_dt' | 'cvss_scores__uuid' | 'cvss_scores__vector' | 'flaw__component' | 'flaw__created_dt' | 'flaw__cve_id' | 'flaw__cvss2' | 'flaw__cvss2_score' | 'flaw__cvss3' | 'flaw__cvss3_score' | 'flaw__cwe_id' | 'flaw__impact' | 'flaw__nvd_cvss2' | 'flaw__nvd_cvss3' | 'flaw__reported_dt' | 'flaw__source' | 'flaw__type' | 'flaw__unembargo_dt' | 'flaw__updated_dt' | 'flaw__uuid' | 'impact' | 'ps_component' | 'ps_module' | 'resolution' | 'trackers__created_dt' | 'trackers__external_system_id' | 'trackers__ps_update_stream' | 'trackers__resolution' | 'trackers__status' | 'trackers__type' | 'trackers__updated_dt' | 'trackers__uuid' | 'type' | 'updated_dt' | 'uuid'>} [order] Ordering
         * @param {string} [psComponent] 
         * @param {string} [psModule] 
         * @param {'' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT'} [resolution] 
         * @param {string} [trackersCreatedDt] 
         * @param {string} [trackersCreatedDtDate] 
         * @param {string} [trackersCreatedDtDateGte] 
         * @param {string} [trackersCreatedDtDateLte] 
         * @param {string} [trackersCreatedDtGt] 
         * @param {string} [trackersCreatedDtGte] 
         * @param {string} [trackersCreatedDtLt] 
         * @param {string} [trackersCreatedDtLte] 
         * @param {boolean} [trackersEmbargoed] 
         * @param {string} [trackersExternalSystemId] 
         * @param {string} [trackersPsUpdateStream] 
         * @param {string} [trackersResolution] 
         * @param {string} [trackersStatus] 
         * @param {'BUGZILLA' | 'JIRA'} [trackersType] 
         * @param {string} [trackersUpdatedDt] 
         * @param {string} [trackersUpdatedDtDate] 
         * @param {string} [trackersUpdatedDtDateGte] 
         * @param {string} [trackersUpdatedDtDateLte] 
         * @param {string} [trackersUpdatedDtGt] 
         * @param {string} [trackersUpdatedDtGte] 
         * @param {string} [trackersUpdatedDtLt] 
         * @param {string} [trackersUpdatedDtLte] 
         * @param {string} [trackersUuid] 
         * @param {'DEFAULT'} [type] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsList(affectedness?: '' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED', createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, cvss2?: string, cvss2Score?: number, cvss2ScoreGt?: number, cvss2ScoreGte?: number, cvss2ScoreLt?: number, cvss2ScoreLte?: number, cvss3?: string, cvss3Score?: number, cvss3ScoreGt?: number, cvss3ScoreGte?: number, cvss3ScoreLt?: number, cvss3ScoreLte?: number, cvssScoresComment?: string, cvssScoresCreatedDt?: string, cvssScoresCreatedDtDate?: string, cvssScoresCreatedDtDateGte?: string, cvssScoresCreatedDtDateLte?: string, cvssScoresCreatedDtGt?: string, cvssScoresCreatedDtGte?: string, cvssScoresCreatedDtLt?: string, cvssScoresCreatedDtLte?: string, cvssScoresCvssVersion?: string, cvssScoresIssuer?: 'NIST' | 'RH', cvssScoresScore?: number, cvssScoresUpdatedDt?: string, cvssScoresUpdatedDtDate?: string, cvssScoresUpdatedDtDateGte?: string, cvssScoresUpdatedDtDateLte?: string, cvssScoresUpdatedDtGt?: string, cvssScoresUpdatedDtGte?: string, cvssScoresUpdatedDtLt?: string, cvssScoresUpdatedDtLte?: string, cvssScoresUuid?: string, cvssScoresVector?: string, embargoed?: boolean, excludeFields?: Array<string>, flawComponent?: string, flawCreatedDt?: string, flawCreatedDtDate?: string, flawCreatedDtDateGte?: string, flawCreatedDtDateLte?: string, flawCreatedDtGt?: string, flawCreatedDtGte?: string, flawCreatedDtLt?: string, flawCreatedDtLte?: string, flawCveId?: string, flawCvss2?: string, flawCvss2Score?: number, flawCvss2ScoreGt?: number, flawCvss2ScoreGte?: number, flawCvss2ScoreLt?: number, flawCvss2ScoreLte?: number, flawCvss3?: string, flawCvss3Score?: number, flawCvss3ScoreGt?: number, flawCvss3ScoreGte?: number, flawCvss3ScoreLt?: number, flawCvss3ScoreLte?: number, flawCweId?: string, flawEmbargoed?: boolean, flawImpact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', flawIsMajorIncident?: boolean, flawNvdCvss2?: string, flawNvdCvss3?: string, flawReportedDt?: string, flawReportedDtDate?: string, flawReportedDtDateGte?: string, flawReportedDtDateLte?: string, flawReportedDtGt?: string, flawReportedDtGte?: string, flawReportedDtLt?: string, flawReportedDtLte?: string, flawSource?: '' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF', flawType?: 'VULNERABILITY' | 'WEAKNESS', flawUnembargoDt?: string, flawUpdatedDt?: string, flawUpdatedDtDate?: string, flawUpdatedDtDateGte?: string, flawUpdatedDtDateLte?: string, flawUpdatedDtGt?: string, flawUpdatedDtGte?: string, flawUpdatedDtLt?: string, flawUpdatedDtLte?: string, flawUuid?: string, impact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', includeFields?: Array<string>, includeMetaAttr?: Array<string>, limit?: number, offset?: number, order?: Array<'-affectedness' | '-created_dt' | '-cvss2' | '-cvss2_score' | '-cvss3' | '-cvss3_score' | '-cvss_scores__comment' | '-cvss_scores__created_dt' | '-cvss_scores__issuer' | '-cvss_scores__score' | '-cvss_scores__updated_dt' | '-cvss_scores__uuid' | '-cvss_scores__vector' | '-flaw__component' | '-flaw__created_dt' | '-flaw__cve_id' | '-flaw__cvss2' | '-flaw__cvss2_score' | '-flaw__cvss3' | '-flaw__cvss3_score' | '-flaw__cwe_id' | '-flaw__impact' | '-flaw__nvd_cvss2' | '-flaw__nvd_cvss3' | '-flaw__reported_dt' | '-flaw__source' | '-flaw__type' | '-flaw__unembargo_dt' | '-flaw__updated_dt' | '-flaw__uuid' | '-impact' | '-ps_component' | '-ps_module' | '-resolution' | '-trackers__created_dt' | '-trackers__external_system_id' | '-trackers__ps_update_stream' | '-trackers__resolution' | '-trackers__status' | '-trackers__type' | '-trackers__updated_dt' | '-trackers__uuid' | '-type' | '-updated_dt' | '-uuid' | 'affectedness' | 'created_dt' | 'cvss2' | 'cvss2_score' | 'cvss3' | 'cvss3_score' | 'cvss_scores__comment' | 'cvss_scores__created_dt' | 'cvss_scores__issuer' | 'cvss_scores__score' | 'cvss_scores__updated_dt' | 'cvss_scores__uuid' | 'cvss_scores__vector' | 'flaw__component' | 'flaw__created_dt' | 'flaw__cve_id' | 'flaw__cvss2' | 'flaw__cvss2_score' | 'flaw__cvss3' | 'flaw__cvss3_score' | 'flaw__cwe_id' | 'flaw__impact' | 'flaw__nvd_cvss2' | 'flaw__nvd_cvss3' | 'flaw__reported_dt' | 'flaw__source' | 'flaw__type' | 'flaw__unembargo_dt' | 'flaw__updated_dt' | 'flaw__uuid' | 'impact' | 'ps_component' | 'ps_module' | 'resolution' | 'trackers__created_dt' | 'trackers__external_system_id' | 'trackers__ps_update_stream' | 'trackers__resolution' | 'trackers__status' | 'trackers__type' | 'trackers__updated_dt' | 'trackers__uuid' | 'type' | 'updated_dt' | 'uuid'>, psComponent?: string, psModule?: string, resolution?: '' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT', trackersCreatedDt?: string, trackersCreatedDtDate?: string, trackersCreatedDtDateGte?: string, trackersCreatedDtDateLte?: string, trackersCreatedDtGt?: string, trackersCreatedDtGte?: string, trackersCreatedDtLt?: string, trackersCreatedDtLte?: string, trackersEmbargoed?: boolean, trackersExternalSystemId?: string, trackersPsUpdateStream?: string, trackersResolution?: string, trackersStatus?: string, trackersType?: 'BUGZILLA' | 'JIRA', trackersUpdatedDt?: string, trackersUpdatedDtDate?: string, trackersUpdatedDtDateGte?: string, trackersUpdatedDtDateLte?: string, trackersUpdatedDtGt?: string, trackersUpdatedDtGte?: string, trackersUpdatedDtLt?: string, trackersUpdatedDtLte?: string, trackersUuid?: string, type?: 'DEFAULT', updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, options?: any): AxiosPromise<OsidbApiV1AffectsList200Response> {
            return localVarFp.osidbApiV1AffectsList(affectedness, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, cvss2, cvss2Score, cvss2ScoreGt, cvss2ScoreGte, cvss2ScoreLt, cvss2ScoreLte, cvss3, cvss3Score, cvss3ScoreGt, cvss3ScoreGte, cvss3ScoreLt, cvss3ScoreLte, cvssScoresComment, cvssScoresCreatedDt, cvssScoresCreatedDtDate, cvssScoresCreatedDtDateGte, cvssScoresCreatedDtDateLte, cvssScoresCreatedDtGt, cvssScoresCreatedDtGte, cvssScoresCreatedDtLt, cvssScoresCreatedDtLte, cvssScoresCvssVersion, cvssScoresIssuer, cvssScoresScore, cvssScoresUpdatedDt, cvssScoresUpdatedDtDate, cvssScoresUpdatedDtDateGte, cvssScoresUpdatedDtDateLte, cvssScoresUpdatedDtGt, cvssScoresUpdatedDtGte, cvssScoresUpdatedDtLt, cvssScoresUpdatedDtLte, cvssScoresUuid, cvssScoresVector, embargoed, excludeFields, flawComponent, flawCreatedDt, flawCreatedDtDate, flawCreatedDtDateGte, flawCreatedDtDateLte, flawCreatedDtGt, flawCreatedDtGte, flawCreatedDtLt, flawCreatedDtLte, flawCveId, flawCvss2, flawCvss2Score, flawCvss2ScoreGt, flawCvss2ScoreGte, flawCvss2ScoreLt, flawCvss2ScoreLte, flawCvss3, flawCvss3Score, flawCvss3ScoreGt, flawCvss3ScoreGte, flawCvss3ScoreLt, flawCvss3ScoreLte, flawCweId, flawEmbargoed, flawImpact, flawIsMajorIncident, flawNvdCvss2, flawNvdCvss3, flawReportedDt, flawReportedDtDate, flawReportedDtDateGte, flawReportedDtDateLte, flawReportedDtGt, flawReportedDtGte, flawReportedDtLt, flawReportedDtLte, flawSource, flawType, flawUnembargoDt, flawUpdatedDt, flawUpdatedDtDate, flawUpdatedDtDateGte, flawUpdatedDtDateLte, flawUpdatedDtGt, flawUpdatedDtGte, flawUpdatedDtLt, flawUpdatedDtLte, flawUuid, impact, includeFields, includeMetaAttr, limit, offset, order, psComponent, psModule, resolution, trackersCreatedDt, trackersCreatedDtDate, trackersCreatedDtDateGte, trackersCreatedDtDateLte, trackersCreatedDtGt, trackersCreatedDtGte, trackersCreatedDtLt, trackersCreatedDtLte, trackersEmbargoed, trackersExternalSystemId, trackersPsUpdateStream, trackersResolution, trackersStatus, trackersType, trackersUpdatedDt, trackersUpdatedDtDate, trackersUpdatedDtDateGte, trackersUpdatedDtDateLte, trackersUpdatedDtGt, trackersUpdatedDtGte, trackersUpdatedDtLt, trackersUpdatedDtLte, trackersUuid, type, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid A UUID string identifying this Affect.
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsRetrieve(uuid: string, excludeFields?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, options?: any): AxiosPromise<OsidbApiV1AffectsCreate201Response> {
            return localVarFp.osidbApiV1AffectsRetrieve(uuid, excludeFields, includeFields, includeMetaAttr, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} uuid A UUID string identifying this Affect.
         * @param {Affect} affect 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsUpdate(bugzillaApiKey: string, uuid: string, affect: Affect, options?: any): AxiosPromise<OsidbApiV1AffectsCreate201Response> {
            return localVarFp.osidbApiV1AffectsUpdate(bugzillaApiKey, uuid, affect, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} flawId 
         * @param {FlawAcknowledgmentPost} flawAcknowledgmentPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsAcknowledgmentsCreate(flawId: string, flawAcknowledgmentPost: FlawAcknowledgmentPost, options?: any): AxiosPromise<OsidbApiV1FlawsAcknowledgmentsCreate201Response> {
            return localVarFp.osidbApiV1FlawsAcknowledgmentsCreate(flawId, flawAcknowledgmentPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Destroy the instance and proxy the delete to Bugzilla
         * @param {string} flawId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsAcknowledgmentsDestroy(flawId: string, id: string, options?: any): AxiosPromise<AuthTokenCreate200ResponseAllOf> {
            return localVarFp.osidbApiV1FlawsAcknowledgmentsDestroy(flawId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} [affiliation] 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {boolean} [fromUpstream] 
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsAcknowledgmentsList(flawId: string, affiliation?: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, excludeFields?: Array<string>, fromUpstream?: boolean, includeFields?: Array<string>, includeMetaAttr?: Array<string>, limit?: number, name?: string, offset?: number, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, options?: any): AxiosPromise<OsidbApiV1FlawsAcknowledgmentsList200Response> {
            return localVarFp.osidbApiV1FlawsAcknowledgmentsList(flawId, affiliation, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, excludeFields, fromUpstream, includeFields, includeMetaAttr, limit, name, offset, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} id 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsAcknowledgmentsRetrieve(flawId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, options?: any): AxiosPromise<OsidbApiV1FlawsAcknowledgmentsCreate201Response> {
            return localVarFp.osidbApiV1FlawsAcknowledgmentsRetrieve(flawId, id, excludeFields, includeFields, includeMetaAttr, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} id 
         * @param {FlawAcknowledgmentPut} flawAcknowledgmentPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsAcknowledgmentsUpdate(flawId: string, id: string, flawAcknowledgmentPut: FlawAcknowledgmentPut, options?: any): AxiosPromise<OsidbApiV1FlawsAcknowledgmentsCreate201Response> {
            return localVarFp.osidbApiV1FlawsAcknowledgmentsUpdate(flawId, id, flawAcknowledgmentPut, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new comment for a given flaw. Beware that freshly created comments are not guaranteed to keep their original UUIDs, especially if multiple comments are created simultaneously.
         * @param {string} flawId A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
         * @param {FlawCommentPost} flawCommentPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsCommentsCreate(flawId: string, flawCommentPost: FlawCommentPost, options?: any): AxiosPromise<OsidbApiV1FlawsCommentsCreate201Response> {
            return localVarFp.osidbApiV1FlawsCommentsCreate(flawId, flawCommentPost, options).then((request) => request(axios, basePath));
        },
        /**
         * List existing comments for a given flaw. Beware that freshly created comments are not guaranteed to keep their original UUIDs, especially if multiple comments are created simultaneously.
         * @param {string} flawId A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {string} [externalSystemId] 
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {number} [order] Retrieve only FlawComment resource with the specified order number. Regular flaw comments are numbered from 1 up.
         * @param {string} [uuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsCommentsList(flawId: string, excludeFields?: Array<string>, externalSystemId?: string, includeFields?: Array<string>, includeMetaAttr?: Array<string>, limit?: number, offset?: number, order?: number, uuid?: string, options?: any): AxiosPromise<OsidbApiV1FlawsCommentsList200Response> {
            return localVarFp.osidbApiV1FlawsCommentsList(flawId, excludeFields, externalSystemId, includeFields, includeMetaAttr, limit, offset, order, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single existing comments for a given flaw. Beware that freshly created comments are not guaranteed to keep their original UUIDs, especially if multiple comments are created simultaneously.
         * @param {string} commentId A string representing the internal OSIDB UUID of the FlawComment resource.
         * @param {string} flawId A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsCommentsRetrieve(commentId: string, flawId: string, excludeFields?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, options?: any): AxiosPromise<OsidbApiV1FlawsCommentsCreate201Response> {
            return localVarFp.osidbApiV1FlawsCommentsRetrieve(commentId, flawId, excludeFields, includeFields, includeMetaAttr, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {FlawPost} flawPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsCreate(bugzillaApiKey: string, jiraApiKey: string, flawPost: FlawPost, options?: any): AxiosPromise<OsidbApiV1FlawsCreate201Response> {
            return localVarFp.osidbApiV1FlawsCreate(bugzillaApiKey, jiraApiKey, flawPost, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} flawId 
         * @param {FlawCVSSPost} flawCVSSPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsCvssScoresCreate(flawId: string, flawCVSSPost: FlawCVSSPost, options?: any): AxiosPromise<OsidbApiV1FlawsCvssScoresCreate201Response> {
            return localVarFp.osidbApiV1FlawsCvssScoresCreate(flawId, flawCVSSPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Destroy the instance and proxy the delete to Bugzilla
         * @param {string} flawId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsCvssScoresDestroy(flawId: string, id: string, options?: any): AxiosPromise<AuthTokenCreate200ResponseAllOf> {
            return localVarFp.osidbApiV1FlawsCvssScoresDestroy(flawId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} [comment] 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {string} [cvssVersion] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {'NIST' | 'RH'} [issuer] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {number} [score] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {string} [vector] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsCvssScoresList(flawId: string, comment?: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, cvssVersion?: string, excludeFields?: Array<string>, includeFields?: Array<string>, issuer?: 'NIST' | 'RH', limit?: number, offset?: number, score?: number, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, vector?: string, options?: any): AxiosPromise<OsidbApiV1FlawsCvssScoresList200Response> {
            return localVarFp.osidbApiV1FlawsCvssScoresList(flawId, comment, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, cvssVersion, excludeFields, includeFields, issuer, limit, offset, score, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, vector, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} id 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsCvssScoresRetrieve(flawId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, options?: any): AxiosPromise<OsidbApiV1FlawsCvssScoresCreate201Response> {
            return localVarFp.osidbApiV1FlawsCvssScoresRetrieve(flawId, id, excludeFields, includeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} id 
         * @param {FlawCVSSPut} flawCVSSPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsCvssScoresUpdate(flawId: string, id: string, flawCVSSPut: FlawCVSSPut, options?: any): AxiosPromise<OsidbApiV1FlawsCvssScoresCreate201Response> {
            return localVarFp.osidbApiV1FlawsCvssScoresUpdate(flawId, id, flawCVSSPut, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [acknowledgmentsAffiliation] 
         * @param {string} [acknowledgmentsCreatedDt] 
         * @param {string} [acknowledgmentsCreatedDtDate] 
         * @param {string} [acknowledgmentsCreatedDtDateGte] 
         * @param {string} [acknowledgmentsCreatedDtDateLte] 
         * @param {string} [acknowledgmentsCreatedDtGt] 
         * @param {string} [acknowledgmentsCreatedDtGte] 
         * @param {string} [acknowledgmentsCreatedDtLt] 
         * @param {string} [acknowledgmentsCreatedDtLte] 
         * @param {boolean} [acknowledgmentsFromUpstream] 
         * @param {string} [acknowledgmentsName] 
         * @param {string} [acknowledgmentsUpdatedDt] 
         * @param {string} [acknowledgmentsUpdatedDtDate] 
         * @param {string} [acknowledgmentsUpdatedDtDateGte] 
         * @param {string} [acknowledgmentsUpdatedDtDateLte] 
         * @param {string} [acknowledgmentsUpdatedDtGt] 
         * @param {string} [acknowledgmentsUpdatedDtGte] 
         * @param {string} [acknowledgmentsUpdatedDtLt] 
         * @param {string} [acknowledgmentsUpdatedDtLte] 
         * @param {string} [acknowledgmentsUuid] 
         * @param {'' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED'} [affectsAffectedness] 
         * @param {string} [affectsCreatedDt] 
         * @param {string} [affectsCreatedDtDate] 
         * @param {string} [affectsCreatedDtDateGte] 
         * @param {string} [affectsCreatedDtDateLte] 
         * @param {string} [affectsCreatedDtGt] 
         * @param {string} [affectsCreatedDtGte] 
         * @param {string} [affectsCreatedDtLt] 
         * @param {string} [affectsCreatedDtLte] 
         * @param {string} [affectsCvss2] 
         * @param {number} [affectsCvss2Score] 
         * @param {number} [affectsCvss2ScoreGt] 
         * @param {number} [affectsCvss2ScoreGte] 
         * @param {number} [affectsCvss2ScoreLt] 
         * @param {number} [affectsCvss2ScoreLte] 
         * @param {string} [affectsCvss3] 
         * @param {number} [affectsCvss3Score] 
         * @param {number} [affectsCvss3ScoreGt] 
         * @param {number} [affectsCvss3ScoreGte] 
         * @param {number} [affectsCvss3ScoreLt] 
         * @param {number} [affectsCvss3ScoreLte] 
         * @param {boolean} [affectsEmbargoed] 
         * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [affectsImpact] 
         * @param {string} [affectsPsComponent] 
         * @param {string} [affectsPsModule] 
         * @param {'' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT'} [affectsResolution] 
         * @param {string} [affectsTrackersCreatedDt] 
         * @param {string} [affectsTrackersCreatedDtDate] 
         * @param {string} [affectsTrackersCreatedDtDateGte] 
         * @param {string} [affectsTrackersCreatedDtDateLte] 
         * @param {string} [affectsTrackersCreatedDtGt] 
         * @param {string} [affectsTrackersCreatedDtGte] 
         * @param {string} [affectsTrackersCreatedDtLt] 
         * @param {string} [affectsTrackersCreatedDtLte] 
         * @param {boolean} [affectsTrackersEmbargoed] 
         * @param {string} [affectsTrackersErrataAdvisoryName] 
         * @param {number} [affectsTrackersErrataEtId] 
         * @param {string} [affectsTrackersErrataShippedDt] 
         * @param {string} [affectsTrackersErrataShippedDtDate] 
         * @param {string} [affectsTrackersErrataShippedDtDateGte] 
         * @param {string} [affectsTrackersErrataShippedDtDateLte] 
         * @param {string} [affectsTrackersErrataShippedDtGt] 
         * @param {string} [affectsTrackersErrataShippedDtGte] 
         * @param {string} [affectsTrackersErrataShippedDtLt] 
         * @param {string} [affectsTrackersErrataShippedDtLte] 
         * @param {string} [affectsTrackersExternalSystemId] 
         * @param {string} [affectsTrackersPsUpdateStream] 
         * @param {string} [affectsTrackersResolution] 
         * @param {string} [affectsTrackersStatus] 
         * @param {'BUGZILLA' | 'JIRA'} [affectsTrackersType] 
         * @param {string} [affectsTrackersUpdatedDt] 
         * @param {string} [affectsTrackersUpdatedDtDate] 
         * @param {string} [affectsTrackersUpdatedDtDateGte] 
         * @param {string} [affectsTrackersUpdatedDtDateLte] 
         * @param {string} [affectsTrackersUpdatedDtGt] 
         * @param {string} [affectsTrackersUpdatedDtGte] 
         * @param {string} [affectsTrackersUpdatedDtLt] 
         * @param {string} [affectsTrackersUpdatedDtLte] 
         * @param {string} [affectsTrackersUuid] 
         * @param {'DEFAULT'} [affectsType] 
         * @param {string} [affectsUpdatedDt] 
         * @param {string} [affectsUpdatedDtDate] 
         * @param {string} [affectsUpdatedDtDateGte] 
         * @param {string} [affectsUpdatedDtDateLte] 
         * @param {string} [affectsUpdatedDtGt] 
         * @param {string} [affectsUpdatedDtGte] 
         * @param {string} [affectsUpdatedDtLt] 
         * @param {string} [affectsUpdatedDtLte] 
         * @param {string} [affectsUuid] 
         * @param {number} [bzId] 
         * @param {string} [changedAfter] 
         * @param {string} [changedBefore] 
         * @param {string} [component] 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {Array<string>} [cveId] Multiple values may be separated by commas.
         * @param {string} [cvss2] 
         * @param {number} [cvss2Score] 
         * @param {number} [cvss2ScoreGt] 
         * @param {number} [cvss2ScoreGte] 
         * @param {number} [cvss2ScoreLt] 
         * @param {number} [cvss2ScoreLte] 
         * @param {string} [cvss3] 
         * @param {number} [cvss3Score] 
         * @param {number} [cvss3ScoreGt] 
         * @param {number} [cvss3ScoreGte] 
         * @param {number} [cvss3ScoreLt] 
         * @param {number} [cvss3ScoreLte] 
         * @param {string} [cvssScoresComment] 
         * @param {string} [cvssScoresCreatedDt] 
         * @param {string} [cvssScoresCreatedDtDate] 
         * @param {string} [cvssScoresCreatedDtDateGte] 
         * @param {string} [cvssScoresCreatedDtDateLte] 
         * @param {string} [cvssScoresCreatedDtGt] 
         * @param {string} [cvssScoresCreatedDtGte] 
         * @param {string} [cvssScoresCreatedDtLt] 
         * @param {string} [cvssScoresCreatedDtLte] 
         * @param {string} [cvssScoresCvssVersion] 
         * @param {'NIST' | 'RH'} [cvssScoresIssuer] 
         * @param {number} [cvssScoresScore] 
         * @param {string} [cvssScoresUpdatedDt] 
         * @param {string} [cvssScoresUpdatedDtDate] 
         * @param {string} [cvssScoresUpdatedDtDateGte] 
         * @param {string} [cvssScoresUpdatedDtDateLte] 
         * @param {string} [cvssScoresUpdatedDtGt] 
         * @param {string} [cvssScoresUpdatedDtGte] 
         * @param {string} [cvssScoresUpdatedDtLt] 
         * @param {string} [cvssScoresUpdatedDtLte] 
         * @param {string} [cvssScoresUuid] 
         * @param {string} [cvssScoresVector] 
         * @param {string} [cweId] 
         * @param {string} [description] 
         * @param {boolean} [embargoed] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [flawMetaType] Include flaw metas with specified type only, multiple values may be separated by commas. 
         * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [impact] 
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {boolean} [isMajorIncident] 
         * @param {number} [limit] Number of results to return per page.
         * @param {'' | 'APPROVED' | 'CISA_APPROVED' | 'INVALID' | 'REJECTED' | 'REQUESTED'} [majorIncidentState] 
         * @param {'' | 'APPROVED' | 'REJECTED' | 'REQUESTED'} [nistCvssValidation] 
         * @param {string} [nvdCvss2] 
         * @param {string} [nvdCvss3] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {Array<'-acknowledgments__affiliation' | '-acknowledgments__created_dt' | '-acknowledgments__from_upstream' | '-acknowledgments__name' | '-acknowledgments__updated_dt' | '-acknowledgments__uuid' | '-affects__affectedness' | '-affects__created_dt' | '-affects__cvss2' | '-affects__cvss2_score' | '-affects__cvss3' | '-affects__cvss3_score' | '-affects__impact' | '-affects__ps_component' | '-affects__ps_module' | '-affects__resolution' | '-affects__trackers__created_dt' | '-affects__trackers__errata__advisory_name' | '-affects__trackers__errata__et_id' | '-affects__trackers__errata__shipped_dt' | '-affects__trackers__external_system_id' | '-affects__trackers__ps_update_stream' | '-affects__trackers__resolution' | '-affects__trackers__status' | '-affects__trackers__type' | '-affects__trackers__updated_dt' | '-affects__trackers__uuid' | '-affects__type' | '-affects__updated_dt' | '-affects__uuid' | '-component' | '-created_dt' | '-cve_id' | '-cvss2' | '-cvss2_score' | '-cvss3' | '-cvss3_score' | '-cvss_scores__comment' | '-cvss_scores__created_dt' | '-cvss_scores__issuer' | '-cvss_scores__score' | '-cvss_scores__updated_dt' | '-cvss_scores__uuid' | '-cvss_scores__vector' | '-cwe_id' | '-impact' | '-major_incident_state' | '-nist_cvss_validation' | '-nvd_cvss2' | '-nvd_cvss3' | '-references__created_dt' | '-references__description' | '-references__type' | '-references__updated_dt' | '-references__url' | '-references__uuid' | '-reported_dt' | '-requires_summary' | '-source' | '-type' | '-unembargo_dt' | '-updated_dt' | '-uuid' | 'acknowledgments__affiliation' | 'acknowledgments__created_dt' | 'acknowledgments__from_upstream' | 'acknowledgments__name' | 'acknowledgments__updated_dt' | 'acknowledgments__uuid' | 'affects__affectedness' | 'affects__created_dt' | 'affects__cvss2' | 'affects__cvss2_score' | 'affects__cvss3' | 'affects__cvss3_score' | 'affects__impact' | 'affects__ps_component' | 'affects__ps_module' | 'affects__resolution' | 'affects__trackers__created_dt' | 'affects__trackers__errata__advisory_name' | 'affects__trackers__errata__et_id' | 'affects__trackers__errata__shipped_dt' | 'affects__trackers__external_system_id' | 'affects__trackers__ps_update_stream' | 'affects__trackers__resolution' | 'affects__trackers__status' | 'affects__trackers__type' | 'affects__trackers__updated_dt' | 'affects__trackers__uuid' | 'affects__type' | 'affects__updated_dt' | 'affects__uuid' | 'component' | 'created_dt' | 'cve_id' | 'cvss2' | 'cvss2_score' | 'cvss3' | 'cvss3_score' | 'cvss_scores__comment' | 'cvss_scores__created_dt' | 'cvss_scores__issuer' | 'cvss_scores__score' | 'cvss_scores__updated_dt' | 'cvss_scores__uuid' | 'cvss_scores__vector' | 'cwe_id' | 'impact' | 'major_incident_state' | 'nist_cvss_validation' | 'nvd_cvss2' | 'nvd_cvss3' | 'references__created_dt' | 'references__description' | 'references__type' | 'references__updated_dt' | 'references__url' | 'references__uuid' | 'reported_dt' | 'requires_summary' | 'source' | 'type' | 'unembargo_dt' | 'updated_dt' | 'uuid'>} [order] Ordering
         * @param {string} [referencesCreatedDt] 
         * @param {string} [referencesCreatedDtDate] 
         * @param {string} [referencesCreatedDtDateGte] 
         * @param {string} [referencesCreatedDtDateLte] 
         * @param {string} [referencesCreatedDtGt] 
         * @param {string} [referencesCreatedDtGte] 
         * @param {string} [referencesCreatedDtLt] 
         * @param {string} [referencesCreatedDtLte] 
         * @param {string} [referencesDescription] 
         * @param {'ARTICLE' | 'EXTERNAL' | 'SOURCE'} [referencesType] 
         * @param {string} [referencesUpdatedDt] 
         * @param {string} [referencesUpdatedDtDate] 
         * @param {string} [referencesUpdatedDtDateGte] 
         * @param {string} [referencesUpdatedDtDateLte] 
         * @param {string} [referencesUpdatedDtGt] 
         * @param {string} [referencesUpdatedDtGte] 
         * @param {string} [referencesUpdatedDtLt] 
         * @param {string} [referencesUpdatedDtLte] 
         * @param {string} [referencesUrl] 
         * @param {string} [referencesUuid] 
         * @param {string} [reportedDt] 
         * @param {string} [reportedDtDate] 
         * @param {string} [reportedDtDateGte] 
         * @param {string} [reportedDtDateLte] 
         * @param {string} [reportedDtGt] 
         * @param {string} [reportedDtGte] 
         * @param {string} [reportedDtLt] 
         * @param {string} [reportedDtLte] 
         * @param {'' | 'APPROVED' | 'REJECTED' | 'REQUESTED'} [requiresSummary] 
         * @param {string} [search] 
         * @param {'' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF'} [source] 
         * @param {string} [statement] 
         * @param {string} [summary] 
         * @param {string} [title] 
         * @param {Array<string>} [trackerIds] Filter only Flaws which are related to specified Trackers (through Affects). Multiple tracker IDs may be separated by commas. Also only Affects that have the specified Trackers related will be shown.
         * @param {'VULNERABILITY' | 'WEAKNESS'} [type] 
         * @param {string} [unembargoDt] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsList(acknowledgmentsAffiliation?: string, acknowledgmentsCreatedDt?: string, acknowledgmentsCreatedDtDate?: string, acknowledgmentsCreatedDtDateGte?: string, acknowledgmentsCreatedDtDateLte?: string, acknowledgmentsCreatedDtGt?: string, acknowledgmentsCreatedDtGte?: string, acknowledgmentsCreatedDtLt?: string, acknowledgmentsCreatedDtLte?: string, acknowledgmentsFromUpstream?: boolean, acknowledgmentsName?: string, acknowledgmentsUpdatedDt?: string, acknowledgmentsUpdatedDtDate?: string, acknowledgmentsUpdatedDtDateGte?: string, acknowledgmentsUpdatedDtDateLte?: string, acknowledgmentsUpdatedDtGt?: string, acknowledgmentsUpdatedDtGte?: string, acknowledgmentsUpdatedDtLt?: string, acknowledgmentsUpdatedDtLte?: string, acknowledgmentsUuid?: string, affectsAffectedness?: '' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED', affectsCreatedDt?: string, affectsCreatedDtDate?: string, affectsCreatedDtDateGte?: string, affectsCreatedDtDateLte?: string, affectsCreatedDtGt?: string, affectsCreatedDtGte?: string, affectsCreatedDtLt?: string, affectsCreatedDtLte?: string, affectsCvss2?: string, affectsCvss2Score?: number, affectsCvss2ScoreGt?: number, affectsCvss2ScoreGte?: number, affectsCvss2ScoreLt?: number, affectsCvss2ScoreLte?: number, affectsCvss3?: string, affectsCvss3Score?: number, affectsCvss3ScoreGt?: number, affectsCvss3ScoreGte?: number, affectsCvss3ScoreLt?: number, affectsCvss3ScoreLte?: number, affectsEmbargoed?: boolean, affectsImpact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', affectsPsComponent?: string, affectsPsModule?: string, affectsResolution?: '' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT', affectsTrackersCreatedDt?: string, affectsTrackersCreatedDtDate?: string, affectsTrackersCreatedDtDateGte?: string, affectsTrackersCreatedDtDateLte?: string, affectsTrackersCreatedDtGt?: string, affectsTrackersCreatedDtGte?: string, affectsTrackersCreatedDtLt?: string, affectsTrackersCreatedDtLte?: string, affectsTrackersEmbargoed?: boolean, affectsTrackersErrataAdvisoryName?: string, affectsTrackersErrataEtId?: number, affectsTrackersErrataShippedDt?: string, affectsTrackersErrataShippedDtDate?: string, affectsTrackersErrataShippedDtDateGte?: string, affectsTrackersErrataShippedDtDateLte?: string, affectsTrackersErrataShippedDtGt?: string, affectsTrackersErrataShippedDtGte?: string, affectsTrackersErrataShippedDtLt?: string, affectsTrackersErrataShippedDtLte?: string, affectsTrackersExternalSystemId?: string, affectsTrackersPsUpdateStream?: string, affectsTrackersResolution?: string, affectsTrackersStatus?: string, affectsTrackersType?: 'BUGZILLA' | 'JIRA', affectsTrackersUpdatedDt?: string, affectsTrackersUpdatedDtDate?: string, affectsTrackersUpdatedDtDateGte?: string, affectsTrackersUpdatedDtDateLte?: string, affectsTrackersUpdatedDtGt?: string, affectsTrackersUpdatedDtGte?: string, affectsTrackersUpdatedDtLt?: string, affectsTrackersUpdatedDtLte?: string, affectsTrackersUuid?: string, affectsType?: 'DEFAULT', affectsUpdatedDt?: string, affectsUpdatedDtDate?: string, affectsUpdatedDtDateGte?: string, affectsUpdatedDtDateLte?: string, affectsUpdatedDtGt?: string, affectsUpdatedDtGte?: string, affectsUpdatedDtLt?: string, affectsUpdatedDtLte?: string, affectsUuid?: string, bzId?: number, changedAfter?: string, changedBefore?: string, component?: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, cveId?: Array<string>, cvss2?: string, cvss2Score?: number, cvss2ScoreGt?: number, cvss2ScoreGte?: number, cvss2ScoreLt?: number, cvss2ScoreLte?: number, cvss3?: string, cvss3Score?: number, cvss3ScoreGt?: number, cvss3ScoreGte?: number, cvss3ScoreLt?: number, cvss3ScoreLte?: number, cvssScoresComment?: string, cvssScoresCreatedDt?: string, cvssScoresCreatedDtDate?: string, cvssScoresCreatedDtDateGte?: string, cvssScoresCreatedDtDateLte?: string, cvssScoresCreatedDtGt?: string, cvssScoresCreatedDtGte?: string, cvssScoresCreatedDtLt?: string, cvssScoresCreatedDtLte?: string, cvssScoresCvssVersion?: string, cvssScoresIssuer?: 'NIST' | 'RH', cvssScoresScore?: number, cvssScoresUpdatedDt?: string, cvssScoresUpdatedDtDate?: string, cvssScoresUpdatedDtDateGte?: string, cvssScoresUpdatedDtDateLte?: string, cvssScoresUpdatedDtGt?: string, cvssScoresUpdatedDtGte?: string, cvssScoresUpdatedDtLt?: string, cvssScoresUpdatedDtLte?: string, cvssScoresUuid?: string, cvssScoresVector?: string, cweId?: string, description?: string, embargoed?: boolean, excludeFields?: Array<string>, flawMetaType?: Array<string>, impact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', includeFields?: Array<string>, includeMetaAttr?: Array<string>, isMajorIncident?: boolean, limit?: number, majorIncidentState?: '' | 'APPROVED' | 'CISA_APPROVED' | 'INVALID' | 'REJECTED' | 'REQUESTED', nistCvssValidation?: '' | 'APPROVED' | 'REJECTED' | 'REQUESTED', nvdCvss2?: string, nvdCvss3?: string, offset?: number, order?: Array<'-acknowledgments__affiliation' | '-acknowledgments__created_dt' | '-acknowledgments__from_upstream' | '-acknowledgments__name' | '-acknowledgments__updated_dt' | '-acknowledgments__uuid' | '-affects__affectedness' | '-affects__created_dt' | '-affects__cvss2' | '-affects__cvss2_score' | '-affects__cvss3' | '-affects__cvss3_score' | '-affects__impact' | '-affects__ps_component' | '-affects__ps_module' | '-affects__resolution' | '-affects__trackers__created_dt' | '-affects__trackers__errata__advisory_name' | '-affects__trackers__errata__et_id' | '-affects__trackers__errata__shipped_dt' | '-affects__trackers__external_system_id' | '-affects__trackers__ps_update_stream' | '-affects__trackers__resolution' | '-affects__trackers__status' | '-affects__trackers__type' | '-affects__trackers__updated_dt' | '-affects__trackers__uuid' | '-affects__type' | '-affects__updated_dt' | '-affects__uuid' | '-component' | '-created_dt' | '-cve_id' | '-cvss2' | '-cvss2_score' | '-cvss3' | '-cvss3_score' | '-cvss_scores__comment' | '-cvss_scores__created_dt' | '-cvss_scores__issuer' | '-cvss_scores__score' | '-cvss_scores__updated_dt' | '-cvss_scores__uuid' | '-cvss_scores__vector' | '-cwe_id' | '-impact' | '-major_incident_state' | '-nist_cvss_validation' | '-nvd_cvss2' | '-nvd_cvss3' | '-references__created_dt' | '-references__description' | '-references__type' | '-references__updated_dt' | '-references__url' | '-references__uuid' | '-reported_dt' | '-requires_summary' | '-source' | '-type' | '-unembargo_dt' | '-updated_dt' | '-uuid' | 'acknowledgments__affiliation' | 'acknowledgments__created_dt' | 'acknowledgments__from_upstream' | 'acknowledgments__name' | 'acknowledgments__updated_dt' | 'acknowledgments__uuid' | 'affects__affectedness' | 'affects__created_dt' | 'affects__cvss2' | 'affects__cvss2_score' | 'affects__cvss3' | 'affects__cvss3_score' | 'affects__impact' | 'affects__ps_component' | 'affects__ps_module' | 'affects__resolution' | 'affects__trackers__created_dt' | 'affects__trackers__errata__advisory_name' | 'affects__trackers__errata__et_id' | 'affects__trackers__errata__shipped_dt' | 'affects__trackers__external_system_id' | 'affects__trackers__ps_update_stream' | 'affects__trackers__resolution' | 'affects__trackers__status' | 'affects__trackers__type' | 'affects__trackers__updated_dt' | 'affects__trackers__uuid' | 'affects__type' | 'affects__updated_dt' | 'affects__uuid' | 'component' | 'created_dt' | 'cve_id' | 'cvss2' | 'cvss2_score' | 'cvss3' | 'cvss3_score' | 'cvss_scores__comment' | 'cvss_scores__created_dt' | 'cvss_scores__issuer' | 'cvss_scores__score' | 'cvss_scores__updated_dt' | 'cvss_scores__uuid' | 'cvss_scores__vector' | 'cwe_id' | 'impact' | 'major_incident_state' | 'nist_cvss_validation' | 'nvd_cvss2' | 'nvd_cvss3' | 'references__created_dt' | 'references__description' | 'references__type' | 'references__updated_dt' | 'references__url' | 'references__uuid' | 'reported_dt' | 'requires_summary' | 'source' | 'type' | 'unembargo_dt' | 'updated_dt' | 'uuid'>, referencesCreatedDt?: string, referencesCreatedDtDate?: string, referencesCreatedDtDateGte?: string, referencesCreatedDtDateLte?: string, referencesCreatedDtGt?: string, referencesCreatedDtGte?: string, referencesCreatedDtLt?: string, referencesCreatedDtLte?: string, referencesDescription?: string, referencesType?: 'ARTICLE' | 'EXTERNAL' | 'SOURCE', referencesUpdatedDt?: string, referencesUpdatedDtDate?: string, referencesUpdatedDtDateGte?: string, referencesUpdatedDtDateLte?: string, referencesUpdatedDtGt?: string, referencesUpdatedDtGte?: string, referencesUpdatedDtLt?: string, referencesUpdatedDtLte?: string, referencesUrl?: string, referencesUuid?: string, reportedDt?: string, reportedDtDate?: string, reportedDtDateGte?: string, reportedDtDateLte?: string, reportedDtGt?: string, reportedDtGte?: string, reportedDtLt?: string, reportedDtLte?: string, requiresSummary?: '' | 'APPROVED' | 'REJECTED' | 'REQUESTED', search?: string, source?: '' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF', statement?: string, summary?: string, title?: string, trackerIds?: Array<string>, type?: 'VULNERABILITY' | 'WEAKNESS', unembargoDt?: string, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, options?: any): AxiosPromise<OsidbApiV1FlawsList200Response> {
            return localVarFp.osidbApiV1FlawsList(acknowledgmentsAffiliation, acknowledgmentsCreatedDt, acknowledgmentsCreatedDtDate, acknowledgmentsCreatedDtDateGte, acknowledgmentsCreatedDtDateLte, acknowledgmentsCreatedDtGt, acknowledgmentsCreatedDtGte, acknowledgmentsCreatedDtLt, acknowledgmentsCreatedDtLte, acknowledgmentsFromUpstream, acknowledgmentsName, acknowledgmentsUpdatedDt, acknowledgmentsUpdatedDtDate, acknowledgmentsUpdatedDtDateGte, acknowledgmentsUpdatedDtDateLte, acknowledgmentsUpdatedDtGt, acknowledgmentsUpdatedDtGte, acknowledgmentsUpdatedDtLt, acknowledgmentsUpdatedDtLte, acknowledgmentsUuid, affectsAffectedness, affectsCreatedDt, affectsCreatedDtDate, affectsCreatedDtDateGte, affectsCreatedDtDateLte, affectsCreatedDtGt, affectsCreatedDtGte, affectsCreatedDtLt, affectsCreatedDtLte, affectsCvss2, affectsCvss2Score, affectsCvss2ScoreGt, affectsCvss2ScoreGte, affectsCvss2ScoreLt, affectsCvss2ScoreLte, affectsCvss3, affectsCvss3Score, affectsCvss3ScoreGt, affectsCvss3ScoreGte, affectsCvss3ScoreLt, affectsCvss3ScoreLte, affectsEmbargoed, affectsImpact, affectsPsComponent, affectsPsModule, affectsResolution, affectsTrackersCreatedDt, affectsTrackersCreatedDtDate, affectsTrackersCreatedDtDateGte, affectsTrackersCreatedDtDateLte, affectsTrackersCreatedDtGt, affectsTrackersCreatedDtGte, affectsTrackersCreatedDtLt, affectsTrackersCreatedDtLte, affectsTrackersEmbargoed, affectsTrackersErrataAdvisoryName, affectsTrackersErrataEtId, affectsTrackersErrataShippedDt, affectsTrackersErrataShippedDtDate, affectsTrackersErrataShippedDtDateGte, affectsTrackersErrataShippedDtDateLte, affectsTrackersErrataShippedDtGt, affectsTrackersErrataShippedDtGte, affectsTrackersErrataShippedDtLt, affectsTrackersErrataShippedDtLte, affectsTrackersExternalSystemId, affectsTrackersPsUpdateStream, affectsTrackersResolution, affectsTrackersStatus, affectsTrackersType, affectsTrackersUpdatedDt, affectsTrackersUpdatedDtDate, affectsTrackersUpdatedDtDateGte, affectsTrackersUpdatedDtDateLte, affectsTrackersUpdatedDtGt, affectsTrackersUpdatedDtGte, affectsTrackersUpdatedDtLt, affectsTrackersUpdatedDtLte, affectsTrackersUuid, affectsType, affectsUpdatedDt, affectsUpdatedDtDate, affectsUpdatedDtDateGte, affectsUpdatedDtDateLte, affectsUpdatedDtGt, affectsUpdatedDtGte, affectsUpdatedDtLt, affectsUpdatedDtLte, affectsUuid, bzId, changedAfter, changedBefore, component, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, cveId, cvss2, cvss2Score, cvss2ScoreGt, cvss2ScoreGte, cvss2ScoreLt, cvss2ScoreLte, cvss3, cvss3Score, cvss3ScoreGt, cvss3ScoreGte, cvss3ScoreLt, cvss3ScoreLte, cvssScoresComment, cvssScoresCreatedDt, cvssScoresCreatedDtDate, cvssScoresCreatedDtDateGte, cvssScoresCreatedDtDateLte, cvssScoresCreatedDtGt, cvssScoresCreatedDtGte, cvssScoresCreatedDtLt, cvssScoresCreatedDtLte, cvssScoresCvssVersion, cvssScoresIssuer, cvssScoresScore, cvssScoresUpdatedDt, cvssScoresUpdatedDtDate, cvssScoresUpdatedDtDateGte, cvssScoresUpdatedDtDateLte, cvssScoresUpdatedDtGt, cvssScoresUpdatedDtGte, cvssScoresUpdatedDtLt, cvssScoresUpdatedDtLte, cvssScoresUuid, cvssScoresVector, cweId, description, embargoed, excludeFields, flawMetaType, impact, includeFields, includeMetaAttr, isMajorIncident, limit, majorIncidentState, nistCvssValidation, nvdCvss2, nvdCvss3, offset, order, referencesCreatedDt, referencesCreatedDtDate, referencesCreatedDtDateGte, referencesCreatedDtDateLte, referencesCreatedDtGt, referencesCreatedDtGte, referencesCreatedDtLt, referencesCreatedDtLte, referencesDescription, referencesType, referencesUpdatedDt, referencesUpdatedDtDate, referencesUpdatedDtDateGte, referencesUpdatedDtDateLte, referencesUpdatedDtGt, referencesUpdatedDtGte, referencesUpdatedDtLt, referencesUpdatedDtLte, referencesUrl, referencesUuid, reportedDt, reportedDtDate, reportedDtDateGte, reportedDtDateLte, reportedDtGt, reportedDtGte, reportedDtLt, reportedDtLte, requiresSummary, search, source, statement, summary, title, trackerIds, type, unembargoDt, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} flawId 
         * @param {FlawPackageVersionPost} flawPackageVersionPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsPackageVersionsCreate(flawId: string, flawPackageVersionPost: FlawPackageVersionPost, options?: any): AxiosPromise<OsidbApiV1FlawsPackageVersionsCreate201Response> {
            return localVarFp.osidbApiV1FlawsPackageVersionsCreate(flawId, flawPackageVersionPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Destroy the instance and proxy the delete to Bugzilla
         * @param {string} flawId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsPackageVersionsDestroy(flawId: string, id: string, options?: any): AxiosPromise<AuthTokenCreate200ResponseAllOf> {
            return localVarFp.osidbApiV1FlawsPackageVersionsDestroy(flawId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [_package] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {string} [versionsVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsPackageVersionsList(flawId: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, excludeFields?: Array<string>, includeFields?: Array<string>, limit?: number, offset?: number, _package?: string, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, versionsVersion?: string, options?: any): AxiosPromise<OsidbApiV1FlawsPackageVersionsList200Response> {
            return localVarFp.osidbApiV1FlawsPackageVersionsList(flawId, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, excludeFields, includeFields, limit, offset, _package, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, versionsVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} id 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsPackageVersionsRetrieve(flawId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, options?: any): AxiosPromise<OsidbApiV1FlawsPackageVersionsCreate201Response> {
            return localVarFp.osidbApiV1FlawsPackageVersionsRetrieve(flawId, id, excludeFields, includeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} id 
         * @param {FlawPackageVersionPut} flawPackageVersionPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsPackageVersionsUpdate(flawId: string, id: string, flawPackageVersionPut: FlawPackageVersionPut, options?: any): AxiosPromise<OsidbApiV1FlawsPackageVersionsCreate201Response> {
            return localVarFp.osidbApiV1FlawsPackageVersionsUpdate(flawId, id, flawPackageVersionPut, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} flawId 
         * @param {FlawReferencePost} flawReferencePost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsReferencesCreate(flawId: string, flawReferencePost: FlawReferencePost, options?: any): AxiosPromise<OsidbApiV1FlawsReferencesCreate201Response> {
            return localVarFp.osidbApiV1FlawsReferencesCreate(flawId, flawReferencePost, options).then((request) => request(axios, basePath));
        },
        /**
         * Destroy the instance and proxy the delete to Bugzilla
         * @param {string} flawId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsReferencesDestroy(flawId: string, id: string, options?: any): AxiosPromise<AuthTokenCreate200ResponseAllOf> {
            return localVarFp.osidbApiV1FlawsReferencesDestroy(flawId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {string} [description] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {'ARTICLE' | 'EXTERNAL' | 'SOURCE'} [type] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [url] 
         * @param {string} [uuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsReferencesList(flawId: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, description?: string, excludeFields?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, limit?: number, offset?: number, type?: 'ARTICLE' | 'EXTERNAL' | 'SOURCE', updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, url?: string, uuid?: string, options?: any): AxiosPromise<OsidbApiV1FlawsReferencesList200Response> {
            return localVarFp.osidbApiV1FlawsReferencesList(flawId, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, description, excludeFields, includeFields, includeMetaAttr, limit, offset, type, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, url, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} id 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsReferencesRetrieve(flawId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, options?: any): AxiosPromise<OsidbApiV1FlawsReferencesCreate201Response> {
            return localVarFp.osidbApiV1FlawsReferencesRetrieve(flawId, id, excludeFields, includeFields, includeMetaAttr, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} id 
         * @param {FlawReferencePut} flawReferencePut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsReferencesUpdate(flawId: string, id: string, flawReferencePut: FlawReferencePut, options?: any): AxiosPromise<OsidbApiV1FlawsReferencesCreate201Response> {
            return localVarFp.osidbApiV1FlawsReferencesUpdate(flawId, id, flawReferencePut, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [flawMetaType] Include flaw metas with specified type only, multiple values may be separated by commas. 
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {Array<string>} [trackerIds] Filter only Flaws which are related to specified Trackers (through Affects). Multiple tracker IDs may be separated by commas. Also only Affects that have the specified Trackers related will be shown.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsRetrieve(id: string, excludeFields?: Array<string>, flawMetaType?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, trackerIds?: Array<string>, options?: any): AxiosPromise<OsidbApiV1FlawsCreate201Response> {
            return localVarFp.osidbApiV1FlawsRetrieve(id, excludeFields, flawMetaType, includeFields, includeMetaAttr, trackerIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {string} id A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
         * @param {Flaw} flaw 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsUpdate(bugzillaApiKey: string, jiraApiKey: string, id: string, flaw: Flaw, options?: any): AxiosPromise<OsidbApiV1FlawsCreate201Response> {
            return localVarFp.osidbApiV1FlawsUpdate(bugzillaApiKey, jiraApiKey, id, flaw, options).then((request) => request(axios, basePath));
        },
        /**
         * HTTP get /manifest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1ManifestRetrieve(options?: any): AxiosPromise<AuthTokenCreate200ResponseAllOf> {
            return localVarFp.osidbApiV1ManifestRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {'json' | 'yaml'} [format] 
         * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1SchemaRetrieve(format?: 'json' | 'yaml', lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.osidbApiV1SchemaRetrieve(format, lang, options).then((request) => request(axios, basePath));
        },
        /**
         * HTTP get /status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1StatusRetrieve(options?: any): AxiosPromise<OsidbApiV1StatusRetrieve200Response> {
            return localVarFp.osidbApiV1StatusRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {TrackerPost} trackerPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1TrackersCreate(bugzillaApiKey: string, jiraApiKey: string, trackerPost: TrackerPost, options?: any): AxiosPromise<OsidbApiV1TrackersCreate201Response> {
            return localVarFp.osidbApiV1TrackersCreate(bugzillaApiKey, jiraApiKey, trackerPost, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {'' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED'} [affectsAffectedness] 
         * @param {string} [affectsCreatedDt] 
         * @param {string} [affectsCreatedDtDate] 
         * @param {string} [affectsCreatedDtDateGte] 
         * @param {string} [affectsCreatedDtDateLte] 
         * @param {string} [affectsCreatedDtGt] 
         * @param {string} [affectsCreatedDtGte] 
         * @param {string} [affectsCreatedDtLt] 
         * @param {string} [affectsCreatedDtLte] 
         * @param {string} [affectsCvss2] 
         * @param {number} [affectsCvss2Score] 
         * @param {number} [affectsCvss2ScoreGt] 
         * @param {number} [affectsCvss2ScoreGte] 
         * @param {number} [affectsCvss2ScoreLt] 
         * @param {number} [affectsCvss2ScoreLte] 
         * @param {string} [affectsCvss3] 
         * @param {number} [affectsCvss3Score] 
         * @param {number} [affectsCvss3ScoreGt] 
         * @param {number} [affectsCvss3ScoreGte] 
         * @param {number} [affectsCvss3ScoreLt] 
         * @param {number} [affectsCvss3ScoreLte] 
         * @param {boolean} [affectsEmbargoed] 
         * @param {string} [affectsFlawComponent] 
         * @param {string} [affectsFlawCreatedDt] 
         * @param {string} [affectsFlawCreatedDtDate] 
         * @param {string} [affectsFlawCreatedDtDateGte] 
         * @param {string} [affectsFlawCreatedDtDateLte] 
         * @param {string} [affectsFlawCreatedDtGt] 
         * @param {string} [affectsFlawCreatedDtGte] 
         * @param {string} [affectsFlawCreatedDtLt] 
         * @param {string} [affectsFlawCreatedDtLte] 
         * @param {string} [affectsFlawCveId] 
         * @param {string} [affectsFlawCvss2] 
         * @param {number} [affectsFlawCvss2Score] 
         * @param {number} [affectsFlawCvss2ScoreGt] 
         * @param {number} [affectsFlawCvss2ScoreGte] 
         * @param {number} [affectsFlawCvss2ScoreLt] 
         * @param {number} [affectsFlawCvss2ScoreLte] 
         * @param {string} [affectsFlawCvss3] 
         * @param {number} [affectsFlawCvss3Score] 
         * @param {number} [affectsFlawCvss3ScoreGt] 
         * @param {number} [affectsFlawCvss3ScoreGte] 
         * @param {number} [affectsFlawCvss3ScoreLt] 
         * @param {number} [affectsFlawCvss3ScoreLte] 
         * @param {string} [affectsFlawCweId] 
         * @param {boolean} [affectsFlawEmbargoed] 
         * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [affectsFlawImpact] 
         * @param {boolean} [affectsFlawIsMajorIncident] 
         * @param {string} [affectsFlawNvdCvss2] 
         * @param {string} [affectsFlawNvdCvss3] 
         * @param {string} [affectsFlawReportedDt] 
         * @param {string} [affectsFlawReportedDtDate] 
         * @param {string} [affectsFlawReportedDtDateGte] 
         * @param {string} [affectsFlawReportedDtDateLte] 
         * @param {string} [affectsFlawReportedDtGt] 
         * @param {string} [affectsFlawReportedDtGte] 
         * @param {string} [affectsFlawReportedDtLt] 
         * @param {string} [affectsFlawReportedDtLte] 
         * @param {'' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF'} [affectsFlawSource] 
         * @param {'VULNERABILITY' | 'WEAKNESS'} [affectsFlawType] 
         * @param {string} [affectsFlawUnembargoDt] 
         * @param {string} [affectsFlawUpdatedDt] 
         * @param {string} [affectsFlawUpdatedDtDate] 
         * @param {string} [affectsFlawUpdatedDtDateGte] 
         * @param {string} [affectsFlawUpdatedDtDateLte] 
         * @param {string} [affectsFlawUpdatedDtGt] 
         * @param {string} [affectsFlawUpdatedDtGte] 
         * @param {string} [affectsFlawUpdatedDtLt] 
         * @param {string} [affectsFlawUpdatedDtLte] 
         * @param {string} [affectsFlawUuid] 
         * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [affectsImpact] 
         * @param {string} [affectsPsComponent] 
         * @param {string} [affectsPsModule] 
         * @param {'' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT'} [affectsResolution] 
         * @param {'DEFAULT'} [affectsType] 
         * @param {string} [affectsUpdatedDt] 
         * @param {string} [affectsUpdatedDtDate] 
         * @param {string} [affectsUpdatedDtDateGte] 
         * @param {string} [affectsUpdatedDtDateLte] 
         * @param {string} [affectsUpdatedDtGt] 
         * @param {string} [affectsUpdatedDtGte] 
         * @param {string} [affectsUpdatedDtLt] 
         * @param {string} [affectsUpdatedDtLte] 
         * @param {string} [affectsUuid] 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {boolean} [embargoed] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {string} [externalSystemId] 
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {Array<'-affects__affectedness' | '-affects__created_dt' | '-affects__cvss2' | '-affects__cvss2_score' | '-affects__cvss3' | '-affects__cvss3_score' | '-affects__flaw__component' | '-affects__flaw__created_dt' | '-affects__flaw__cve_id' | '-affects__flaw__cvss2' | '-affects__flaw__cvss2_score' | '-affects__flaw__cvss3' | '-affects__flaw__cvss3_score' | '-affects__flaw__cwe_id' | '-affects__flaw__impact' | '-affects__flaw__nvd_cvss2' | '-affects__flaw__nvd_cvss3' | '-affects__flaw__reported_dt' | '-affects__flaw__source' | '-affects__flaw__type' | '-affects__flaw__unembargo_dt' | '-affects__flaw__updated_dt' | '-affects__flaw__uuid' | '-affects__impact' | '-affects__ps_component' | '-affects__ps_module' | '-affects__resolution' | '-affects__type' | '-affects__updated_dt' | '-affects__uuid' | '-created_dt' | '-external_system_id' | '-ps_update_stream' | '-resolution' | '-status' | '-type' | '-updated_dt' | '-uuid' | 'affects__affectedness' | 'affects__created_dt' | 'affects__cvss2' | 'affects__cvss2_score' | 'affects__cvss3' | 'affects__cvss3_score' | 'affects__flaw__component' | 'affects__flaw__created_dt' | 'affects__flaw__cve_id' | 'affects__flaw__cvss2' | 'affects__flaw__cvss2_score' | 'affects__flaw__cvss3' | 'affects__flaw__cvss3_score' | 'affects__flaw__cwe_id' | 'affects__flaw__impact' | 'affects__flaw__nvd_cvss2' | 'affects__flaw__nvd_cvss3' | 'affects__flaw__reported_dt' | 'affects__flaw__source' | 'affects__flaw__type' | 'affects__flaw__unembargo_dt' | 'affects__flaw__updated_dt' | 'affects__flaw__uuid' | 'affects__impact' | 'affects__ps_component' | 'affects__ps_module' | 'affects__resolution' | 'affects__type' | 'affects__updated_dt' | 'affects__uuid' | 'created_dt' | 'external_system_id' | 'ps_update_stream' | 'resolution' | 'status' | 'type' | 'updated_dt' | 'uuid'>} [order] Ordering
         * @param {string} [psUpdateStream] 
         * @param {string} [resolution] 
         * @param {string} [status] 
         * @param {'BUGZILLA' | 'JIRA'} [type] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1TrackersList(affectsAffectedness?: '' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED', affectsCreatedDt?: string, affectsCreatedDtDate?: string, affectsCreatedDtDateGte?: string, affectsCreatedDtDateLte?: string, affectsCreatedDtGt?: string, affectsCreatedDtGte?: string, affectsCreatedDtLt?: string, affectsCreatedDtLte?: string, affectsCvss2?: string, affectsCvss2Score?: number, affectsCvss2ScoreGt?: number, affectsCvss2ScoreGte?: number, affectsCvss2ScoreLt?: number, affectsCvss2ScoreLte?: number, affectsCvss3?: string, affectsCvss3Score?: number, affectsCvss3ScoreGt?: number, affectsCvss3ScoreGte?: number, affectsCvss3ScoreLt?: number, affectsCvss3ScoreLte?: number, affectsEmbargoed?: boolean, affectsFlawComponent?: string, affectsFlawCreatedDt?: string, affectsFlawCreatedDtDate?: string, affectsFlawCreatedDtDateGte?: string, affectsFlawCreatedDtDateLte?: string, affectsFlawCreatedDtGt?: string, affectsFlawCreatedDtGte?: string, affectsFlawCreatedDtLt?: string, affectsFlawCreatedDtLte?: string, affectsFlawCveId?: string, affectsFlawCvss2?: string, affectsFlawCvss2Score?: number, affectsFlawCvss2ScoreGt?: number, affectsFlawCvss2ScoreGte?: number, affectsFlawCvss2ScoreLt?: number, affectsFlawCvss2ScoreLte?: number, affectsFlawCvss3?: string, affectsFlawCvss3Score?: number, affectsFlawCvss3ScoreGt?: number, affectsFlawCvss3ScoreGte?: number, affectsFlawCvss3ScoreLt?: number, affectsFlawCvss3ScoreLte?: number, affectsFlawCweId?: string, affectsFlawEmbargoed?: boolean, affectsFlawImpact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', affectsFlawIsMajorIncident?: boolean, affectsFlawNvdCvss2?: string, affectsFlawNvdCvss3?: string, affectsFlawReportedDt?: string, affectsFlawReportedDtDate?: string, affectsFlawReportedDtDateGte?: string, affectsFlawReportedDtDateLte?: string, affectsFlawReportedDtGt?: string, affectsFlawReportedDtGte?: string, affectsFlawReportedDtLt?: string, affectsFlawReportedDtLte?: string, affectsFlawSource?: '' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF', affectsFlawType?: 'VULNERABILITY' | 'WEAKNESS', affectsFlawUnembargoDt?: string, affectsFlawUpdatedDt?: string, affectsFlawUpdatedDtDate?: string, affectsFlawUpdatedDtDateGte?: string, affectsFlawUpdatedDtDateLte?: string, affectsFlawUpdatedDtGt?: string, affectsFlawUpdatedDtGte?: string, affectsFlawUpdatedDtLt?: string, affectsFlawUpdatedDtLte?: string, affectsFlawUuid?: string, affectsImpact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', affectsPsComponent?: string, affectsPsModule?: string, affectsResolution?: '' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT', affectsType?: 'DEFAULT', affectsUpdatedDt?: string, affectsUpdatedDtDate?: string, affectsUpdatedDtDateGte?: string, affectsUpdatedDtDateLte?: string, affectsUpdatedDtGt?: string, affectsUpdatedDtGte?: string, affectsUpdatedDtLt?: string, affectsUpdatedDtLte?: string, affectsUuid?: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, embargoed?: boolean, excludeFields?: Array<string>, externalSystemId?: string, includeFields?: Array<string>, includeMetaAttr?: Array<string>, limit?: number, offset?: number, order?: Array<'-affects__affectedness' | '-affects__created_dt' | '-affects__cvss2' | '-affects__cvss2_score' | '-affects__cvss3' | '-affects__cvss3_score' | '-affects__flaw__component' | '-affects__flaw__created_dt' | '-affects__flaw__cve_id' | '-affects__flaw__cvss2' | '-affects__flaw__cvss2_score' | '-affects__flaw__cvss3' | '-affects__flaw__cvss3_score' | '-affects__flaw__cwe_id' | '-affects__flaw__impact' | '-affects__flaw__nvd_cvss2' | '-affects__flaw__nvd_cvss3' | '-affects__flaw__reported_dt' | '-affects__flaw__source' | '-affects__flaw__type' | '-affects__flaw__unembargo_dt' | '-affects__flaw__updated_dt' | '-affects__flaw__uuid' | '-affects__impact' | '-affects__ps_component' | '-affects__ps_module' | '-affects__resolution' | '-affects__type' | '-affects__updated_dt' | '-affects__uuid' | '-created_dt' | '-external_system_id' | '-ps_update_stream' | '-resolution' | '-status' | '-type' | '-updated_dt' | '-uuid' | 'affects__affectedness' | 'affects__created_dt' | 'affects__cvss2' | 'affects__cvss2_score' | 'affects__cvss3' | 'affects__cvss3_score' | 'affects__flaw__component' | 'affects__flaw__created_dt' | 'affects__flaw__cve_id' | 'affects__flaw__cvss2' | 'affects__flaw__cvss2_score' | 'affects__flaw__cvss3' | 'affects__flaw__cvss3_score' | 'affects__flaw__cwe_id' | 'affects__flaw__impact' | 'affects__flaw__nvd_cvss2' | 'affects__flaw__nvd_cvss3' | 'affects__flaw__reported_dt' | 'affects__flaw__source' | 'affects__flaw__type' | 'affects__flaw__unembargo_dt' | 'affects__flaw__updated_dt' | 'affects__flaw__uuid' | 'affects__impact' | 'affects__ps_component' | 'affects__ps_module' | 'affects__resolution' | 'affects__type' | 'affects__updated_dt' | 'affects__uuid' | 'created_dt' | 'external_system_id' | 'ps_update_stream' | 'resolution' | 'status' | 'type' | 'updated_dt' | 'uuid'>, psUpdateStream?: string, resolution?: string, status?: string, type?: 'BUGZILLA' | 'JIRA', updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, options?: any): AxiosPromise<OsidbApiV1TrackersList200Response> {
            return localVarFp.osidbApiV1TrackersList(affectsAffectedness, affectsCreatedDt, affectsCreatedDtDate, affectsCreatedDtDateGte, affectsCreatedDtDateLte, affectsCreatedDtGt, affectsCreatedDtGte, affectsCreatedDtLt, affectsCreatedDtLte, affectsCvss2, affectsCvss2Score, affectsCvss2ScoreGt, affectsCvss2ScoreGte, affectsCvss2ScoreLt, affectsCvss2ScoreLte, affectsCvss3, affectsCvss3Score, affectsCvss3ScoreGt, affectsCvss3ScoreGte, affectsCvss3ScoreLt, affectsCvss3ScoreLte, affectsEmbargoed, affectsFlawComponent, affectsFlawCreatedDt, affectsFlawCreatedDtDate, affectsFlawCreatedDtDateGte, affectsFlawCreatedDtDateLte, affectsFlawCreatedDtGt, affectsFlawCreatedDtGte, affectsFlawCreatedDtLt, affectsFlawCreatedDtLte, affectsFlawCveId, affectsFlawCvss2, affectsFlawCvss2Score, affectsFlawCvss2ScoreGt, affectsFlawCvss2ScoreGte, affectsFlawCvss2ScoreLt, affectsFlawCvss2ScoreLte, affectsFlawCvss3, affectsFlawCvss3Score, affectsFlawCvss3ScoreGt, affectsFlawCvss3ScoreGte, affectsFlawCvss3ScoreLt, affectsFlawCvss3ScoreLte, affectsFlawCweId, affectsFlawEmbargoed, affectsFlawImpact, affectsFlawIsMajorIncident, affectsFlawNvdCvss2, affectsFlawNvdCvss3, affectsFlawReportedDt, affectsFlawReportedDtDate, affectsFlawReportedDtDateGte, affectsFlawReportedDtDateLte, affectsFlawReportedDtGt, affectsFlawReportedDtGte, affectsFlawReportedDtLt, affectsFlawReportedDtLte, affectsFlawSource, affectsFlawType, affectsFlawUnembargoDt, affectsFlawUpdatedDt, affectsFlawUpdatedDtDate, affectsFlawUpdatedDtDateGte, affectsFlawUpdatedDtDateLte, affectsFlawUpdatedDtGt, affectsFlawUpdatedDtGte, affectsFlawUpdatedDtLt, affectsFlawUpdatedDtLte, affectsFlawUuid, affectsImpact, affectsPsComponent, affectsPsModule, affectsResolution, affectsType, affectsUpdatedDt, affectsUpdatedDtDate, affectsUpdatedDtDateGte, affectsUpdatedDtDateLte, affectsUpdatedDtGt, affectsUpdatedDtGte, affectsUpdatedDtLt, affectsUpdatedDtLte, affectsUuid, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, embargoed, excludeFields, externalSystemId, includeFields, includeMetaAttr, limit, offset, order, psUpdateStream, resolution, status, type, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid A UUID string identifying this Tracker.
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1TrackersRetrieve(uuid: string, excludeFields?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, options?: any): AxiosPromise<OsidbApiV1TrackersCreate201Response> {
            return localVarFp.osidbApiV1TrackersRetrieve(uuid, excludeFields, includeFields, includeMetaAttr, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {string} uuid A UUID string identifying this Tracker.
         * @param {Tracker} tracker 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1TrackersUpdate(bugzillaApiKey: string, jiraApiKey: string, uuid: string, tracker: Tracker, options?: any): AxiosPromise<OsidbApiV1TrackersCreate201Response> {
            return localVarFp.osidbApiV1TrackersUpdate(bugzillaApiKey, jiraApiKey, uuid, tracker, options).then((request) => request(axios, basePath));
        },
        /**
         * unauthenticated view providing healthcheck on osidb service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbHealthyRetrieve(options?: any): AxiosPromise<AuthTokenCreate200ResponseAllOf> {
            return localVarFp.osidbHealthyRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * View that provides information about the currently logged-in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbWhoamiRetrieve(options?: any): AxiosPromise<OsidbWhoamiRetrieve200Response> {
            return localVarFp.osidbWhoamiRetrieve(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OsidbApi - object-oriented interface
 * @export
 * @class OsidbApi
 * @extends {BaseAPI}
 */
export class OsidbApi extends BaseAPI {
    /**
     * 
     * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
     * @param {AffectPost} affectPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1AffectsCreate(bugzillaApiKey: string, affectPost: AffectPost, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1AffectsCreate(bugzillaApiKey, affectPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} affectId 
     * @param {AffectCVSSPost} affectCVSSPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1AffectsCvssScoresCreate(affectId: string, affectCVSSPost: AffectCVSSPost, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1AffectsCvssScoresCreate(affectId, affectCVSSPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Destroy the instance and proxy the delete to Bugzilla.
     * @param {string} affectId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1AffectsCvssScoresDestroy(affectId: string, id: string, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1AffectsCvssScoresDestroy(affectId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} affectId 
     * @param {string} [comment] 
     * @param {string} [createdDt] 
     * @param {string} [createdDtDate] 
     * @param {string} [createdDtDateGte] 
     * @param {string} [createdDtDateLte] 
     * @param {string} [createdDtGt] 
     * @param {string} [createdDtGte] 
     * @param {string} [createdDtLt] 
     * @param {string} [createdDtLte] 
     * @param {string} [cvssVersion] 
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {'NIST' | 'RH'} [issuer] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {number} [score] 
     * @param {string} [updatedDt] 
     * @param {string} [updatedDtDate] 
     * @param {string} [updatedDtDateGte] 
     * @param {string} [updatedDtDateLte] 
     * @param {string} [updatedDtGt] 
     * @param {string} [updatedDtGte] 
     * @param {string} [updatedDtLt] 
     * @param {string} [updatedDtLte] 
     * @param {string} [uuid] 
     * @param {string} [vector] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1AffectsCvssScoresList(affectId: string, comment?: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, cvssVersion?: string, excludeFields?: Array<string>, includeFields?: Array<string>, issuer?: 'NIST' | 'RH', limit?: number, offset?: number, score?: number, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, vector?: string, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1AffectsCvssScoresList(affectId, comment, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, cvssVersion, excludeFields, includeFields, issuer, limit, offset, score, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, vector, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} affectId 
     * @param {string} id 
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1AffectsCvssScoresRetrieve(affectId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1AffectsCvssScoresRetrieve(affectId, id, excludeFields, includeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} affectId 
     * @param {string} id 
     * @param {AffectCVSSPut} affectCVSSPut 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1AffectsCvssScoresUpdate(affectId: string, id: string, affectCVSSPut: AffectCVSSPut, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1AffectsCvssScoresUpdate(affectId, id, affectCVSSPut, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Destroy the instance and proxy the delete to Bugzilla
     * @param {string} uuid A UUID string identifying this Affect.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1AffectsDestroy(uuid: string, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1AffectsDestroy(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {'' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED'} [affectedness] 
     * @param {string} [createdDt] 
     * @param {string} [createdDtDate] 
     * @param {string} [createdDtDateGte] 
     * @param {string} [createdDtDateLte] 
     * @param {string} [createdDtGt] 
     * @param {string} [createdDtGte] 
     * @param {string} [createdDtLt] 
     * @param {string} [createdDtLte] 
     * @param {string} [cvss2] 
     * @param {number} [cvss2Score] 
     * @param {number} [cvss2ScoreGt] 
     * @param {number} [cvss2ScoreGte] 
     * @param {number} [cvss2ScoreLt] 
     * @param {number} [cvss2ScoreLte] 
     * @param {string} [cvss3] 
     * @param {number} [cvss3Score] 
     * @param {number} [cvss3ScoreGt] 
     * @param {number} [cvss3ScoreGte] 
     * @param {number} [cvss3ScoreLt] 
     * @param {number} [cvss3ScoreLte] 
     * @param {string} [cvssScoresComment] 
     * @param {string} [cvssScoresCreatedDt] 
     * @param {string} [cvssScoresCreatedDtDate] 
     * @param {string} [cvssScoresCreatedDtDateGte] 
     * @param {string} [cvssScoresCreatedDtDateLte] 
     * @param {string} [cvssScoresCreatedDtGt] 
     * @param {string} [cvssScoresCreatedDtGte] 
     * @param {string} [cvssScoresCreatedDtLt] 
     * @param {string} [cvssScoresCreatedDtLte] 
     * @param {string} [cvssScoresCvssVersion] 
     * @param {'NIST' | 'RH'} [cvssScoresIssuer] 
     * @param {number} [cvssScoresScore] 
     * @param {string} [cvssScoresUpdatedDt] 
     * @param {string} [cvssScoresUpdatedDtDate] 
     * @param {string} [cvssScoresUpdatedDtDateGte] 
     * @param {string} [cvssScoresUpdatedDtDateLte] 
     * @param {string} [cvssScoresUpdatedDtGt] 
     * @param {string} [cvssScoresUpdatedDtGte] 
     * @param {string} [cvssScoresUpdatedDtLt] 
     * @param {string} [cvssScoresUpdatedDtLte] 
     * @param {string} [cvssScoresUuid] 
     * @param {string} [cvssScoresVector] 
     * @param {boolean} [embargoed] 
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {string} [flawComponent] 
     * @param {string} [flawCreatedDt] 
     * @param {string} [flawCreatedDtDate] 
     * @param {string} [flawCreatedDtDateGte] 
     * @param {string} [flawCreatedDtDateLte] 
     * @param {string} [flawCreatedDtGt] 
     * @param {string} [flawCreatedDtGte] 
     * @param {string} [flawCreatedDtLt] 
     * @param {string} [flawCreatedDtLte] 
     * @param {string} [flawCveId] 
     * @param {string} [flawCvss2] 
     * @param {number} [flawCvss2Score] 
     * @param {number} [flawCvss2ScoreGt] 
     * @param {number} [flawCvss2ScoreGte] 
     * @param {number} [flawCvss2ScoreLt] 
     * @param {number} [flawCvss2ScoreLte] 
     * @param {string} [flawCvss3] 
     * @param {number} [flawCvss3Score] 
     * @param {number} [flawCvss3ScoreGt] 
     * @param {number} [flawCvss3ScoreGte] 
     * @param {number} [flawCvss3ScoreLt] 
     * @param {number} [flawCvss3ScoreLte] 
     * @param {string} [flawCweId] 
     * @param {boolean} [flawEmbargoed] 
     * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [flawImpact] 
     * @param {boolean} [flawIsMajorIncident] 
     * @param {string} [flawNvdCvss2] 
     * @param {string} [flawNvdCvss3] 
     * @param {string} [flawReportedDt] 
     * @param {string} [flawReportedDtDate] 
     * @param {string} [flawReportedDtDateGte] 
     * @param {string} [flawReportedDtDateLte] 
     * @param {string} [flawReportedDtGt] 
     * @param {string} [flawReportedDtGte] 
     * @param {string} [flawReportedDtLt] 
     * @param {string} [flawReportedDtLte] 
     * @param {'' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF'} [flawSource] 
     * @param {'VULNERABILITY' | 'WEAKNESS'} [flawType] 
     * @param {string} [flawUnembargoDt] 
     * @param {string} [flawUpdatedDt] 
     * @param {string} [flawUpdatedDtDate] 
     * @param {string} [flawUpdatedDtDateGte] 
     * @param {string} [flawUpdatedDtDateLte] 
     * @param {string} [flawUpdatedDtGt] 
     * @param {string} [flawUpdatedDtGte] 
     * @param {string} [flawUpdatedDtLt] 
     * @param {string} [flawUpdatedDtLte] 
     * @param {string} [flawUuid] 
     * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [impact] 
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {Array<'-affectedness' | '-created_dt' | '-cvss2' | '-cvss2_score' | '-cvss3' | '-cvss3_score' | '-cvss_scores__comment' | '-cvss_scores__created_dt' | '-cvss_scores__issuer' | '-cvss_scores__score' | '-cvss_scores__updated_dt' | '-cvss_scores__uuid' | '-cvss_scores__vector' | '-flaw__component' | '-flaw__created_dt' | '-flaw__cve_id' | '-flaw__cvss2' | '-flaw__cvss2_score' | '-flaw__cvss3' | '-flaw__cvss3_score' | '-flaw__cwe_id' | '-flaw__impact' | '-flaw__nvd_cvss2' | '-flaw__nvd_cvss3' | '-flaw__reported_dt' | '-flaw__source' | '-flaw__type' | '-flaw__unembargo_dt' | '-flaw__updated_dt' | '-flaw__uuid' | '-impact' | '-ps_component' | '-ps_module' | '-resolution' | '-trackers__created_dt' | '-trackers__external_system_id' | '-trackers__ps_update_stream' | '-trackers__resolution' | '-trackers__status' | '-trackers__type' | '-trackers__updated_dt' | '-trackers__uuid' | '-type' | '-updated_dt' | '-uuid' | 'affectedness' | 'created_dt' | 'cvss2' | 'cvss2_score' | 'cvss3' | 'cvss3_score' | 'cvss_scores__comment' | 'cvss_scores__created_dt' | 'cvss_scores__issuer' | 'cvss_scores__score' | 'cvss_scores__updated_dt' | 'cvss_scores__uuid' | 'cvss_scores__vector' | 'flaw__component' | 'flaw__created_dt' | 'flaw__cve_id' | 'flaw__cvss2' | 'flaw__cvss2_score' | 'flaw__cvss3' | 'flaw__cvss3_score' | 'flaw__cwe_id' | 'flaw__impact' | 'flaw__nvd_cvss2' | 'flaw__nvd_cvss3' | 'flaw__reported_dt' | 'flaw__source' | 'flaw__type' | 'flaw__unembargo_dt' | 'flaw__updated_dt' | 'flaw__uuid' | 'impact' | 'ps_component' | 'ps_module' | 'resolution' | 'trackers__created_dt' | 'trackers__external_system_id' | 'trackers__ps_update_stream' | 'trackers__resolution' | 'trackers__status' | 'trackers__type' | 'trackers__updated_dt' | 'trackers__uuid' | 'type' | 'updated_dt' | 'uuid'>} [order] Ordering
     * @param {string} [psComponent] 
     * @param {string} [psModule] 
     * @param {'' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT'} [resolution] 
     * @param {string} [trackersCreatedDt] 
     * @param {string} [trackersCreatedDtDate] 
     * @param {string} [trackersCreatedDtDateGte] 
     * @param {string} [trackersCreatedDtDateLte] 
     * @param {string} [trackersCreatedDtGt] 
     * @param {string} [trackersCreatedDtGte] 
     * @param {string} [trackersCreatedDtLt] 
     * @param {string} [trackersCreatedDtLte] 
     * @param {boolean} [trackersEmbargoed] 
     * @param {string} [trackersExternalSystemId] 
     * @param {string} [trackersPsUpdateStream] 
     * @param {string} [trackersResolution] 
     * @param {string} [trackersStatus] 
     * @param {'BUGZILLA' | 'JIRA'} [trackersType] 
     * @param {string} [trackersUpdatedDt] 
     * @param {string} [trackersUpdatedDtDate] 
     * @param {string} [trackersUpdatedDtDateGte] 
     * @param {string} [trackersUpdatedDtDateLte] 
     * @param {string} [trackersUpdatedDtGt] 
     * @param {string} [trackersUpdatedDtGte] 
     * @param {string} [trackersUpdatedDtLt] 
     * @param {string} [trackersUpdatedDtLte] 
     * @param {string} [trackersUuid] 
     * @param {'DEFAULT'} [type] 
     * @param {string} [updatedDt] 
     * @param {string} [updatedDtDate] 
     * @param {string} [updatedDtDateGte] 
     * @param {string} [updatedDtDateLte] 
     * @param {string} [updatedDtGt] 
     * @param {string} [updatedDtGte] 
     * @param {string} [updatedDtLt] 
     * @param {string} [updatedDtLte] 
     * @param {string} [uuid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1AffectsList(affectedness?: '' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED', createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, cvss2?: string, cvss2Score?: number, cvss2ScoreGt?: number, cvss2ScoreGte?: number, cvss2ScoreLt?: number, cvss2ScoreLte?: number, cvss3?: string, cvss3Score?: number, cvss3ScoreGt?: number, cvss3ScoreGte?: number, cvss3ScoreLt?: number, cvss3ScoreLte?: number, cvssScoresComment?: string, cvssScoresCreatedDt?: string, cvssScoresCreatedDtDate?: string, cvssScoresCreatedDtDateGte?: string, cvssScoresCreatedDtDateLte?: string, cvssScoresCreatedDtGt?: string, cvssScoresCreatedDtGte?: string, cvssScoresCreatedDtLt?: string, cvssScoresCreatedDtLte?: string, cvssScoresCvssVersion?: string, cvssScoresIssuer?: 'NIST' | 'RH', cvssScoresScore?: number, cvssScoresUpdatedDt?: string, cvssScoresUpdatedDtDate?: string, cvssScoresUpdatedDtDateGte?: string, cvssScoresUpdatedDtDateLte?: string, cvssScoresUpdatedDtGt?: string, cvssScoresUpdatedDtGte?: string, cvssScoresUpdatedDtLt?: string, cvssScoresUpdatedDtLte?: string, cvssScoresUuid?: string, cvssScoresVector?: string, embargoed?: boolean, excludeFields?: Array<string>, flawComponent?: string, flawCreatedDt?: string, flawCreatedDtDate?: string, flawCreatedDtDateGte?: string, flawCreatedDtDateLte?: string, flawCreatedDtGt?: string, flawCreatedDtGte?: string, flawCreatedDtLt?: string, flawCreatedDtLte?: string, flawCveId?: string, flawCvss2?: string, flawCvss2Score?: number, flawCvss2ScoreGt?: number, flawCvss2ScoreGte?: number, flawCvss2ScoreLt?: number, flawCvss2ScoreLte?: number, flawCvss3?: string, flawCvss3Score?: number, flawCvss3ScoreGt?: number, flawCvss3ScoreGte?: number, flawCvss3ScoreLt?: number, flawCvss3ScoreLte?: number, flawCweId?: string, flawEmbargoed?: boolean, flawImpact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', flawIsMajorIncident?: boolean, flawNvdCvss2?: string, flawNvdCvss3?: string, flawReportedDt?: string, flawReportedDtDate?: string, flawReportedDtDateGte?: string, flawReportedDtDateLte?: string, flawReportedDtGt?: string, flawReportedDtGte?: string, flawReportedDtLt?: string, flawReportedDtLte?: string, flawSource?: '' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF', flawType?: 'VULNERABILITY' | 'WEAKNESS', flawUnembargoDt?: string, flawUpdatedDt?: string, flawUpdatedDtDate?: string, flawUpdatedDtDateGte?: string, flawUpdatedDtDateLte?: string, flawUpdatedDtGt?: string, flawUpdatedDtGte?: string, flawUpdatedDtLt?: string, flawUpdatedDtLte?: string, flawUuid?: string, impact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', includeFields?: Array<string>, includeMetaAttr?: Array<string>, limit?: number, offset?: number, order?: Array<'-affectedness' | '-created_dt' | '-cvss2' | '-cvss2_score' | '-cvss3' | '-cvss3_score' | '-cvss_scores__comment' | '-cvss_scores__created_dt' | '-cvss_scores__issuer' | '-cvss_scores__score' | '-cvss_scores__updated_dt' | '-cvss_scores__uuid' | '-cvss_scores__vector' | '-flaw__component' | '-flaw__created_dt' | '-flaw__cve_id' | '-flaw__cvss2' | '-flaw__cvss2_score' | '-flaw__cvss3' | '-flaw__cvss3_score' | '-flaw__cwe_id' | '-flaw__impact' | '-flaw__nvd_cvss2' | '-flaw__nvd_cvss3' | '-flaw__reported_dt' | '-flaw__source' | '-flaw__type' | '-flaw__unembargo_dt' | '-flaw__updated_dt' | '-flaw__uuid' | '-impact' | '-ps_component' | '-ps_module' | '-resolution' | '-trackers__created_dt' | '-trackers__external_system_id' | '-trackers__ps_update_stream' | '-trackers__resolution' | '-trackers__status' | '-trackers__type' | '-trackers__updated_dt' | '-trackers__uuid' | '-type' | '-updated_dt' | '-uuid' | 'affectedness' | 'created_dt' | 'cvss2' | 'cvss2_score' | 'cvss3' | 'cvss3_score' | 'cvss_scores__comment' | 'cvss_scores__created_dt' | 'cvss_scores__issuer' | 'cvss_scores__score' | 'cvss_scores__updated_dt' | 'cvss_scores__uuid' | 'cvss_scores__vector' | 'flaw__component' | 'flaw__created_dt' | 'flaw__cve_id' | 'flaw__cvss2' | 'flaw__cvss2_score' | 'flaw__cvss3' | 'flaw__cvss3_score' | 'flaw__cwe_id' | 'flaw__impact' | 'flaw__nvd_cvss2' | 'flaw__nvd_cvss3' | 'flaw__reported_dt' | 'flaw__source' | 'flaw__type' | 'flaw__unembargo_dt' | 'flaw__updated_dt' | 'flaw__uuid' | 'impact' | 'ps_component' | 'ps_module' | 'resolution' | 'trackers__created_dt' | 'trackers__external_system_id' | 'trackers__ps_update_stream' | 'trackers__resolution' | 'trackers__status' | 'trackers__type' | 'trackers__updated_dt' | 'trackers__uuid' | 'type' | 'updated_dt' | 'uuid'>, psComponent?: string, psModule?: string, resolution?: '' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT', trackersCreatedDt?: string, trackersCreatedDtDate?: string, trackersCreatedDtDateGte?: string, trackersCreatedDtDateLte?: string, trackersCreatedDtGt?: string, trackersCreatedDtGte?: string, trackersCreatedDtLt?: string, trackersCreatedDtLte?: string, trackersEmbargoed?: boolean, trackersExternalSystemId?: string, trackersPsUpdateStream?: string, trackersResolution?: string, trackersStatus?: string, trackersType?: 'BUGZILLA' | 'JIRA', trackersUpdatedDt?: string, trackersUpdatedDtDate?: string, trackersUpdatedDtDateGte?: string, trackersUpdatedDtDateLte?: string, trackersUpdatedDtGt?: string, trackersUpdatedDtGte?: string, trackersUpdatedDtLt?: string, trackersUpdatedDtLte?: string, trackersUuid?: string, type?: 'DEFAULT', updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1AffectsList(affectedness, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, cvss2, cvss2Score, cvss2ScoreGt, cvss2ScoreGte, cvss2ScoreLt, cvss2ScoreLte, cvss3, cvss3Score, cvss3ScoreGt, cvss3ScoreGte, cvss3ScoreLt, cvss3ScoreLte, cvssScoresComment, cvssScoresCreatedDt, cvssScoresCreatedDtDate, cvssScoresCreatedDtDateGte, cvssScoresCreatedDtDateLte, cvssScoresCreatedDtGt, cvssScoresCreatedDtGte, cvssScoresCreatedDtLt, cvssScoresCreatedDtLte, cvssScoresCvssVersion, cvssScoresIssuer, cvssScoresScore, cvssScoresUpdatedDt, cvssScoresUpdatedDtDate, cvssScoresUpdatedDtDateGte, cvssScoresUpdatedDtDateLte, cvssScoresUpdatedDtGt, cvssScoresUpdatedDtGte, cvssScoresUpdatedDtLt, cvssScoresUpdatedDtLte, cvssScoresUuid, cvssScoresVector, embargoed, excludeFields, flawComponent, flawCreatedDt, flawCreatedDtDate, flawCreatedDtDateGte, flawCreatedDtDateLte, flawCreatedDtGt, flawCreatedDtGte, flawCreatedDtLt, flawCreatedDtLte, flawCveId, flawCvss2, flawCvss2Score, flawCvss2ScoreGt, flawCvss2ScoreGte, flawCvss2ScoreLt, flawCvss2ScoreLte, flawCvss3, flawCvss3Score, flawCvss3ScoreGt, flawCvss3ScoreGte, flawCvss3ScoreLt, flawCvss3ScoreLte, flawCweId, flawEmbargoed, flawImpact, flawIsMajorIncident, flawNvdCvss2, flawNvdCvss3, flawReportedDt, flawReportedDtDate, flawReportedDtDateGte, flawReportedDtDateLte, flawReportedDtGt, flawReportedDtGte, flawReportedDtLt, flawReportedDtLte, flawSource, flawType, flawUnembargoDt, flawUpdatedDt, flawUpdatedDtDate, flawUpdatedDtDateGte, flawUpdatedDtDateLte, flawUpdatedDtGt, flawUpdatedDtGte, flawUpdatedDtLt, flawUpdatedDtLte, flawUuid, impact, includeFields, includeMetaAttr, limit, offset, order, psComponent, psModule, resolution, trackersCreatedDt, trackersCreatedDtDate, trackersCreatedDtDateGte, trackersCreatedDtDateLte, trackersCreatedDtGt, trackersCreatedDtGte, trackersCreatedDtLt, trackersCreatedDtLte, trackersEmbargoed, trackersExternalSystemId, trackersPsUpdateStream, trackersResolution, trackersStatus, trackersType, trackersUpdatedDt, trackersUpdatedDtDate, trackersUpdatedDtDateGte, trackersUpdatedDtDateLte, trackersUpdatedDtGt, trackersUpdatedDtGte, trackersUpdatedDtLt, trackersUpdatedDtLte, trackersUuid, type, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid A UUID string identifying this Affect.
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1AffectsRetrieve(uuid: string, excludeFields?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1AffectsRetrieve(uuid, excludeFields, includeFields, includeMetaAttr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
     * @param {string} uuid A UUID string identifying this Affect.
     * @param {Affect} affect 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1AffectsUpdate(bugzillaApiKey: string, uuid: string, affect: Affect, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1AffectsUpdate(bugzillaApiKey, uuid, affect, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} flawId 
     * @param {FlawAcknowledgmentPost} flawAcknowledgmentPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsAcknowledgmentsCreate(flawId: string, flawAcknowledgmentPost: FlawAcknowledgmentPost, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsAcknowledgmentsCreate(flawId, flawAcknowledgmentPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Destroy the instance and proxy the delete to Bugzilla
     * @param {string} flawId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsAcknowledgmentsDestroy(flawId: string, id: string, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsAcknowledgmentsDestroy(flawId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} flawId 
     * @param {string} [affiliation] 
     * @param {string} [createdDt] 
     * @param {string} [createdDtDate] 
     * @param {string} [createdDtDateGte] 
     * @param {string} [createdDtDateLte] 
     * @param {string} [createdDtGt] 
     * @param {string} [createdDtGte] 
     * @param {string} [createdDtLt] 
     * @param {string} [createdDtLte] 
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {boolean} [fromUpstream] 
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] 
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [updatedDt] 
     * @param {string} [updatedDtDate] 
     * @param {string} [updatedDtDateGte] 
     * @param {string} [updatedDtDateLte] 
     * @param {string} [updatedDtGt] 
     * @param {string} [updatedDtGte] 
     * @param {string} [updatedDtLt] 
     * @param {string} [updatedDtLte] 
     * @param {string} [uuid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsAcknowledgmentsList(flawId: string, affiliation?: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, excludeFields?: Array<string>, fromUpstream?: boolean, includeFields?: Array<string>, includeMetaAttr?: Array<string>, limit?: number, name?: string, offset?: number, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsAcknowledgmentsList(flawId, affiliation, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, excludeFields, fromUpstream, includeFields, includeMetaAttr, limit, name, offset, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} flawId 
     * @param {string} id 
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsAcknowledgmentsRetrieve(flawId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsAcknowledgmentsRetrieve(flawId, id, excludeFields, includeFields, includeMetaAttr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} flawId 
     * @param {string} id 
     * @param {FlawAcknowledgmentPut} flawAcknowledgmentPut 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsAcknowledgmentsUpdate(flawId: string, id: string, flawAcknowledgmentPut: FlawAcknowledgmentPut, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsAcknowledgmentsUpdate(flawId, id, flawAcknowledgmentPut, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new comment for a given flaw. Beware that freshly created comments are not guaranteed to keep their original UUIDs, especially if multiple comments are created simultaneously.
     * @param {string} flawId A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
     * @param {FlawCommentPost} flawCommentPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsCommentsCreate(flawId: string, flawCommentPost: FlawCommentPost, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsCommentsCreate(flawId, flawCommentPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List existing comments for a given flaw. Beware that freshly created comments are not guaranteed to keep their original UUIDs, especially if multiple comments are created simultaneously.
     * @param {string} flawId A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {string} [externalSystemId] 
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {number} [order] Retrieve only FlawComment resource with the specified order number. Regular flaw comments are numbered from 1 up.
     * @param {string} [uuid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsCommentsList(flawId: string, excludeFields?: Array<string>, externalSystemId?: string, includeFields?: Array<string>, includeMetaAttr?: Array<string>, limit?: number, offset?: number, order?: number, uuid?: string, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsCommentsList(flawId, excludeFields, externalSystemId, includeFields, includeMetaAttr, limit, offset, order, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single existing comments for a given flaw. Beware that freshly created comments are not guaranteed to keep their original UUIDs, especially if multiple comments are created simultaneously.
     * @param {string} commentId A string representing the internal OSIDB UUID of the FlawComment resource.
     * @param {string} flawId A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsCommentsRetrieve(commentId: string, flawId: string, excludeFields?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsCommentsRetrieve(commentId, flawId, excludeFields, includeFields, includeMetaAttr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
     * @param {string} jiraApiKey User generated api key for Jira authentication.
     * @param {FlawPost} flawPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsCreate(bugzillaApiKey: string, jiraApiKey: string, flawPost: FlawPost, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsCreate(bugzillaApiKey, jiraApiKey, flawPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} flawId 
     * @param {FlawCVSSPost} flawCVSSPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsCvssScoresCreate(flawId: string, flawCVSSPost: FlawCVSSPost, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsCvssScoresCreate(flawId, flawCVSSPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Destroy the instance and proxy the delete to Bugzilla
     * @param {string} flawId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsCvssScoresDestroy(flawId: string, id: string, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsCvssScoresDestroy(flawId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} flawId 
     * @param {string} [comment] 
     * @param {string} [createdDt] 
     * @param {string} [createdDtDate] 
     * @param {string} [createdDtDateGte] 
     * @param {string} [createdDtDateLte] 
     * @param {string} [createdDtGt] 
     * @param {string} [createdDtGte] 
     * @param {string} [createdDtLt] 
     * @param {string} [createdDtLte] 
     * @param {string} [cvssVersion] 
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {'NIST' | 'RH'} [issuer] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {number} [score] 
     * @param {string} [updatedDt] 
     * @param {string} [updatedDtDate] 
     * @param {string} [updatedDtDateGte] 
     * @param {string} [updatedDtDateLte] 
     * @param {string} [updatedDtGt] 
     * @param {string} [updatedDtGte] 
     * @param {string} [updatedDtLt] 
     * @param {string} [updatedDtLte] 
     * @param {string} [uuid] 
     * @param {string} [vector] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsCvssScoresList(flawId: string, comment?: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, cvssVersion?: string, excludeFields?: Array<string>, includeFields?: Array<string>, issuer?: 'NIST' | 'RH', limit?: number, offset?: number, score?: number, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, vector?: string, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsCvssScoresList(flawId, comment, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, cvssVersion, excludeFields, includeFields, issuer, limit, offset, score, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, vector, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} flawId 
     * @param {string} id 
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsCvssScoresRetrieve(flawId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsCvssScoresRetrieve(flawId, id, excludeFields, includeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} flawId 
     * @param {string} id 
     * @param {FlawCVSSPut} flawCVSSPut 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsCvssScoresUpdate(flawId: string, id: string, flawCVSSPut: FlawCVSSPut, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsCvssScoresUpdate(flawId, id, flawCVSSPut, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [acknowledgmentsAffiliation] 
     * @param {string} [acknowledgmentsCreatedDt] 
     * @param {string} [acknowledgmentsCreatedDtDate] 
     * @param {string} [acknowledgmentsCreatedDtDateGte] 
     * @param {string} [acknowledgmentsCreatedDtDateLte] 
     * @param {string} [acknowledgmentsCreatedDtGt] 
     * @param {string} [acknowledgmentsCreatedDtGte] 
     * @param {string} [acknowledgmentsCreatedDtLt] 
     * @param {string} [acknowledgmentsCreatedDtLte] 
     * @param {boolean} [acknowledgmentsFromUpstream] 
     * @param {string} [acknowledgmentsName] 
     * @param {string} [acknowledgmentsUpdatedDt] 
     * @param {string} [acknowledgmentsUpdatedDtDate] 
     * @param {string} [acknowledgmentsUpdatedDtDateGte] 
     * @param {string} [acknowledgmentsUpdatedDtDateLte] 
     * @param {string} [acknowledgmentsUpdatedDtGt] 
     * @param {string} [acknowledgmentsUpdatedDtGte] 
     * @param {string} [acknowledgmentsUpdatedDtLt] 
     * @param {string} [acknowledgmentsUpdatedDtLte] 
     * @param {string} [acknowledgmentsUuid] 
     * @param {'' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED'} [affectsAffectedness] 
     * @param {string} [affectsCreatedDt] 
     * @param {string} [affectsCreatedDtDate] 
     * @param {string} [affectsCreatedDtDateGte] 
     * @param {string} [affectsCreatedDtDateLte] 
     * @param {string} [affectsCreatedDtGt] 
     * @param {string} [affectsCreatedDtGte] 
     * @param {string} [affectsCreatedDtLt] 
     * @param {string} [affectsCreatedDtLte] 
     * @param {string} [affectsCvss2] 
     * @param {number} [affectsCvss2Score] 
     * @param {number} [affectsCvss2ScoreGt] 
     * @param {number} [affectsCvss2ScoreGte] 
     * @param {number} [affectsCvss2ScoreLt] 
     * @param {number} [affectsCvss2ScoreLte] 
     * @param {string} [affectsCvss3] 
     * @param {number} [affectsCvss3Score] 
     * @param {number} [affectsCvss3ScoreGt] 
     * @param {number} [affectsCvss3ScoreGte] 
     * @param {number} [affectsCvss3ScoreLt] 
     * @param {number} [affectsCvss3ScoreLte] 
     * @param {boolean} [affectsEmbargoed] 
     * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [affectsImpact] 
     * @param {string} [affectsPsComponent] 
     * @param {string} [affectsPsModule] 
     * @param {'' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT'} [affectsResolution] 
     * @param {string} [affectsTrackersCreatedDt] 
     * @param {string} [affectsTrackersCreatedDtDate] 
     * @param {string} [affectsTrackersCreatedDtDateGte] 
     * @param {string} [affectsTrackersCreatedDtDateLte] 
     * @param {string} [affectsTrackersCreatedDtGt] 
     * @param {string} [affectsTrackersCreatedDtGte] 
     * @param {string} [affectsTrackersCreatedDtLt] 
     * @param {string} [affectsTrackersCreatedDtLte] 
     * @param {boolean} [affectsTrackersEmbargoed] 
     * @param {string} [affectsTrackersErrataAdvisoryName] 
     * @param {number} [affectsTrackersErrataEtId] 
     * @param {string} [affectsTrackersErrataShippedDt] 
     * @param {string} [affectsTrackersErrataShippedDtDate] 
     * @param {string} [affectsTrackersErrataShippedDtDateGte] 
     * @param {string} [affectsTrackersErrataShippedDtDateLte] 
     * @param {string} [affectsTrackersErrataShippedDtGt] 
     * @param {string} [affectsTrackersErrataShippedDtGte] 
     * @param {string} [affectsTrackersErrataShippedDtLt] 
     * @param {string} [affectsTrackersErrataShippedDtLte] 
     * @param {string} [affectsTrackersExternalSystemId] 
     * @param {string} [affectsTrackersPsUpdateStream] 
     * @param {string} [affectsTrackersResolution] 
     * @param {string} [affectsTrackersStatus] 
     * @param {'BUGZILLA' | 'JIRA'} [affectsTrackersType] 
     * @param {string} [affectsTrackersUpdatedDt] 
     * @param {string} [affectsTrackersUpdatedDtDate] 
     * @param {string} [affectsTrackersUpdatedDtDateGte] 
     * @param {string} [affectsTrackersUpdatedDtDateLte] 
     * @param {string} [affectsTrackersUpdatedDtGt] 
     * @param {string} [affectsTrackersUpdatedDtGte] 
     * @param {string} [affectsTrackersUpdatedDtLt] 
     * @param {string} [affectsTrackersUpdatedDtLte] 
     * @param {string} [affectsTrackersUuid] 
     * @param {'DEFAULT'} [affectsType] 
     * @param {string} [affectsUpdatedDt] 
     * @param {string} [affectsUpdatedDtDate] 
     * @param {string} [affectsUpdatedDtDateGte] 
     * @param {string} [affectsUpdatedDtDateLte] 
     * @param {string} [affectsUpdatedDtGt] 
     * @param {string} [affectsUpdatedDtGte] 
     * @param {string} [affectsUpdatedDtLt] 
     * @param {string} [affectsUpdatedDtLte] 
     * @param {string} [affectsUuid] 
     * @param {number} [bzId] 
     * @param {string} [changedAfter] 
     * @param {string} [changedBefore] 
     * @param {string} [component] 
     * @param {string} [createdDt] 
     * @param {string} [createdDtDate] 
     * @param {string} [createdDtDateGte] 
     * @param {string} [createdDtDateLte] 
     * @param {string} [createdDtGt] 
     * @param {string} [createdDtGte] 
     * @param {string} [createdDtLt] 
     * @param {string} [createdDtLte] 
     * @param {Array<string>} [cveId] Multiple values may be separated by commas.
     * @param {string} [cvss2] 
     * @param {number} [cvss2Score] 
     * @param {number} [cvss2ScoreGt] 
     * @param {number} [cvss2ScoreGte] 
     * @param {number} [cvss2ScoreLt] 
     * @param {number} [cvss2ScoreLte] 
     * @param {string} [cvss3] 
     * @param {number} [cvss3Score] 
     * @param {number} [cvss3ScoreGt] 
     * @param {number} [cvss3ScoreGte] 
     * @param {number} [cvss3ScoreLt] 
     * @param {number} [cvss3ScoreLte] 
     * @param {string} [cvssScoresComment] 
     * @param {string} [cvssScoresCreatedDt] 
     * @param {string} [cvssScoresCreatedDtDate] 
     * @param {string} [cvssScoresCreatedDtDateGte] 
     * @param {string} [cvssScoresCreatedDtDateLte] 
     * @param {string} [cvssScoresCreatedDtGt] 
     * @param {string} [cvssScoresCreatedDtGte] 
     * @param {string} [cvssScoresCreatedDtLt] 
     * @param {string} [cvssScoresCreatedDtLte] 
     * @param {string} [cvssScoresCvssVersion] 
     * @param {'NIST' | 'RH'} [cvssScoresIssuer] 
     * @param {number} [cvssScoresScore] 
     * @param {string} [cvssScoresUpdatedDt] 
     * @param {string} [cvssScoresUpdatedDtDate] 
     * @param {string} [cvssScoresUpdatedDtDateGte] 
     * @param {string} [cvssScoresUpdatedDtDateLte] 
     * @param {string} [cvssScoresUpdatedDtGt] 
     * @param {string} [cvssScoresUpdatedDtGte] 
     * @param {string} [cvssScoresUpdatedDtLt] 
     * @param {string} [cvssScoresUpdatedDtLte] 
     * @param {string} [cvssScoresUuid] 
     * @param {string} [cvssScoresVector] 
     * @param {string} [cweId] 
     * @param {string} [description] 
     * @param {boolean} [embargoed] 
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [flawMetaType] Include flaw metas with specified type only, multiple values may be separated by commas. 
     * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [impact] 
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
     * @param {boolean} [isMajorIncident] 
     * @param {number} [limit] Number of results to return per page.
     * @param {'' | 'APPROVED' | 'CISA_APPROVED' | 'INVALID' | 'REJECTED' | 'REQUESTED'} [majorIncidentState] 
     * @param {'' | 'APPROVED' | 'REJECTED' | 'REQUESTED'} [nistCvssValidation] 
     * @param {string} [nvdCvss2] 
     * @param {string} [nvdCvss3] 
     * @param {number} [offset] The initial index from which to return the results.
     * @param {Array<'-acknowledgments__affiliation' | '-acknowledgments__created_dt' | '-acknowledgments__from_upstream' | '-acknowledgments__name' | '-acknowledgments__updated_dt' | '-acknowledgments__uuid' | '-affects__affectedness' | '-affects__created_dt' | '-affects__cvss2' | '-affects__cvss2_score' | '-affects__cvss3' | '-affects__cvss3_score' | '-affects__impact' | '-affects__ps_component' | '-affects__ps_module' | '-affects__resolution' | '-affects__trackers__created_dt' | '-affects__trackers__errata__advisory_name' | '-affects__trackers__errata__et_id' | '-affects__trackers__errata__shipped_dt' | '-affects__trackers__external_system_id' | '-affects__trackers__ps_update_stream' | '-affects__trackers__resolution' | '-affects__trackers__status' | '-affects__trackers__type' | '-affects__trackers__updated_dt' | '-affects__trackers__uuid' | '-affects__type' | '-affects__updated_dt' | '-affects__uuid' | '-component' | '-created_dt' | '-cve_id' | '-cvss2' | '-cvss2_score' | '-cvss3' | '-cvss3_score' | '-cvss_scores__comment' | '-cvss_scores__created_dt' | '-cvss_scores__issuer' | '-cvss_scores__score' | '-cvss_scores__updated_dt' | '-cvss_scores__uuid' | '-cvss_scores__vector' | '-cwe_id' | '-impact' | '-major_incident_state' | '-nist_cvss_validation' | '-nvd_cvss2' | '-nvd_cvss3' | '-references__created_dt' | '-references__description' | '-references__type' | '-references__updated_dt' | '-references__url' | '-references__uuid' | '-reported_dt' | '-requires_summary' | '-source' | '-type' | '-unembargo_dt' | '-updated_dt' | '-uuid' | 'acknowledgments__affiliation' | 'acknowledgments__created_dt' | 'acknowledgments__from_upstream' | 'acknowledgments__name' | 'acknowledgments__updated_dt' | 'acknowledgments__uuid' | 'affects__affectedness' | 'affects__created_dt' | 'affects__cvss2' | 'affects__cvss2_score' | 'affects__cvss3' | 'affects__cvss3_score' | 'affects__impact' | 'affects__ps_component' | 'affects__ps_module' | 'affects__resolution' | 'affects__trackers__created_dt' | 'affects__trackers__errata__advisory_name' | 'affects__trackers__errata__et_id' | 'affects__trackers__errata__shipped_dt' | 'affects__trackers__external_system_id' | 'affects__trackers__ps_update_stream' | 'affects__trackers__resolution' | 'affects__trackers__status' | 'affects__trackers__type' | 'affects__trackers__updated_dt' | 'affects__trackers__uuid' | 'affects__type' | 'affects__updated_dt' | 'affects__uuid' | 'component' | 'created_dt' | 'cve_id' | 'cvss2' | 'cvss2_score' | 'cvss3' | 'cvss3_score' | 'cvss_scores__comment' | 'cvss_scores__created_dt' | 'cvss_scores__issuer' | 'cvss_scores__score' | 'cvss_scores__updated_dt' | 'cvss_scores__uuid' | 'cvss_scores__vector' | 'cwe_id' | 'impact' | 'major_incident_state' | 'nist_cvss_validation' | 'nvd_cvss2' | 'nvd_cvss3' | 'references__created_dt' | 'references__description' | 'references__type' | 'references__updated_dt' | 'references__url' | 'references__uuid' | 'reported_dt' | 'requires_summary' | 'source' | 'type' | 'unembargo_dt' | 'updated_dt' | 'uuid'>} [order] Ordering
     * @param {string} [referencesCreatedDt] 
     * @param {string} [referencesCreatedDtDate] 
     * @param {string} [referencesCreatedDtDateGte] 
     * @param {string} [referencesCreatedDtDateLte] 
     * @param {string} [referencesCreatedDtGt] 
     * @param {string} [referencesCreatedDtGte] 
     * @param {string} [referencesCreatedDtLt] 
     * @param {string} [referencesCreatedDtLte] 
     * @param {string} [referencesDescription] 
     * @param {'ARTICLE' | 'EXTERNAL' | 'SOURCE'} [referencesType] 
     * @param {string} [referencesUpdatedDt] 
     * @param {string} [referencesUpdatedDtDate] 
     * @param {string} [referencesUpdatedDtDateGte] 
     * @param {string} [referencesUpdatedDtDateLte] 
     * @param {string} [referencesUpdatedDtGt] 
     * @param {string} [referencesUpdatedDtGte] 
     * @param {string} [referencesUpdatedDtLt] 
     * @param {string} [referencesUpdatedDtLte] 
     * @param {string} [referencesUrl] 
     * @param {string} [referencesUuid] 
     * @param {string} [reportedDt] 
     * @param {string} [reportedDtDate] 
     * @param {string} [reportedDtDateGte] 
     * @param {string} [reportedDtDateLte] 
     * @param {string} [reportedDtGt] 
     * @param {string} [reportedDtGte] 
     * @param {string} [reportedDtLt] 
     * @param {string} [reportedDtLte] 
     * @param {'' | 'APPROVED' | 'REJECTED' | 'REQUESTED'} [requiresSummary] 
     * @param {string} [search] 
     * @param {'' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF'} [source] 
     * @param {string} [statement] 
     * @param {string} [summary] 
     * @param {string} [title] 
     * @param {Array<string>} [trackerIds] Filter only Flaws which are related to specified Trackers (through Affects). Multiple tracker IDs may be separated by commas. Also only Affects that have the specified Trackers related will be shown.
     * @param {'VULNERABILITY' | 'WEAKNESS'} [type] 
     * @param {string} [unembargoDt] 
     * @param {string} [updatedDt] 
     * @param {string} [updatedDtDate] 
     * @param {string} [updatedDtDateGte] 
     * @param {string} [updatedDtDateLte] 
     * @param {string} [updatedDtGt] 
     * @param {string} [updatedDtGte] 
     * @param {string} [updatedDtLt] 
     * @param {string} [updatedDtLte] 
     * @param {string} [uuid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsList(acknowledgmentsAffiliation?: string, acknowledgmentsCreatedDt?: string, acknowledgmentsCreatedDtDate?: string, acknowledgmentsCreatedDtDateGte?: string, acknowledgmentsCreatedDtDateLte?: string, acknowledgmentsCreatedDtGt?: string, acknowledgmentsCreatedDtGte?: string, acknowledgmentsCreatedDtLt?: string, acknowledgmentsCreatedDtLte?: string, acknowledgmentsFromUpstream?: boolean, acknowledgmentsName?: string, acknowledgmentsUpdatedDt?: string, acknowledgmentsUpdatedDtDate?: string, acknowledgmentsUpdatedDtDateGte?: string, acknowledgmentsUpdatedDtDateLte?: string, acknowledgmentsUpdatedDtGt?: string, acknowledgmentsUpdatedDtGte?: string, acknowledgmentsUpdatedDtLt?: string, acknowledgmentsUpdatedDtLte?: string, acknowledgmentsUuid?: string, affectsAffectedness?: '' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED', affectsCreatedDt?: string, affectsCreatedDtDate?: string, affectsCreatedDtDateGte?: string, affectsCreatedDtDateLte?: string, affectsCreatedDtGt?: string, affectsCreatedDtGte?: string, affectsCreatedDtLt?: string, affectsCreatedDtLte?: string, affectsCvss2?: string, affectsCvss2Score?: number, affectsCvss2ScoreGt?: number, affectsCvss2ScoreGte?: number, affectsCvss2ScoreLt?: number, affectsCvss2ScoreLte?: number, affectsCvss3?: string, affectsCvss3Score?: number, affectsCvss3ScoreGt?: number, affectsCvss3ScoreGte?: number, affectsCvss3ScoreLt?: number, affectsCvss3ScoreLte?: number, affectsEmbargoed?: boolean, affectsImpact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', affectsPsComponent?: string, affectsPsModule?: string, affectsResolution?: '' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT', affectsTrackersCreatedDt?: string, affectsTrackersCreatedDtDate?: string, affectsTrackersCreatedDtDateGte?: string, affectsTrackersCreatedDtDateLte?: string, affectsTrackersCreatedDtGt?: string, affectsTrackersCreatedDtGte?: string, affectsTrackersCreatedDtLt?: string, affectsTrackersCreatedDtLte?: string, affectsTrackersEmbargoed?: boolean, affectsTrackersErrataAdvisoryName?: string, affectsTrackersErrataEtId?: number, affectsTrackersErrataShippedDt?: string, affectsTrackersErrataShippedDtDate?: string, affectsTrackersErrataShippedDtDateGte?: string, affectsTrackersErrataShippedDtDateLte?: string, affectsTrackersErrataShippedDtGt?: string, affectsTrackersErrataShippedDtGte?: string, affectsTrackersErrataShippedDtLt?: string, affectsTrackersErrataShippedDtLte?: string, affectsTrackersExternalSystemId?: string, affectsTrackersPsUpdateStream?: string, affectsTrackersResolution?: string, affectsTrackersStatus?: string, affectsTrackersType?: 'BUGZILLA' | 'JIRA', affectsTrackersUpdatedDt?: string, affectsTrackersUpdatedDtDate?: string, affectsTrackersUpdatedDtDateGte?: string, affectsTrackersUpdatedDtDateLte?: string, affectsTrackersUpdatedDtGt?: string, affectsTrackersUpdatedDtGte?: string, affectsTrackersUpdatedDtLt?: string, affectsTrackersUpdatedDtLte?: string, affectsTrackersUuid?: string, affectsType?: 'DEFAULT', affectsUpdatedDt?: string, affectsUpdatedDtDate?: string, affectsUpdatedDtDateGte?: string, affectsUpdatedDtDateLte?: string, affectsUpdatedDtGt?: string, affectsUpdatedDtGte?: string, affectsUpdatedDtLt?: string, affectsUpdatedDtLte?: string, affectsUuid?: string, bzId?: number, changedAfter?: string, changedBefore?: string, component?: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, cveId?: Array<string>, cvss2?: string, cvss2Score?: number, cvss2ScoreGt?: number, cvss2ScoreGte?: number, cvss2ScoreLt?: number, cvss2ScoreLte?: number, cvss3?: string, cvss3Score?: number, cvss3ScoreGt?: number, cvss3ScoreGte?: number, cvss3ScoreLt?: number, cvss3ScoreLte?: number, cvssScoresComment?: string, cvssScoresCreatedDt?: string, cvssScoresCreatedDtDate?: string, cvssScoresCreatedDtDateGte?: string, cvssScoresCreatedDtDateLte?: string, cvssScoresCreatedDtGt?: string, cvssScoresCreatedDtGte?: string, cvssScoresCreatedDtLt?: string, cvssScoresCreatedDtLte?: string, cvssScoresCvssVersion?: string, cvssScoresIssuer?: 'NIST' | 'RH', cvssScoresScore?: number, cvssScoresUpdatedDt?: string, cvssScoresUpdatedDtDate?: string, cvssScoresUpdatedDtDateGte?: string, cvssScoresUpdatedDtDateLte?: string, cvssScoresUpdatedDtGt?: string, cvssScoresUpdatedDtGte?: string, cvssScoresUpdatedDtLt?: string, cvssScoresUpdatedDtLte?: string, cvssScoresUuid?: string, cvssScoresVector?: string, cweId?: string, description?: string, embargoed?: boolean, excludeFields?: Array<string>, flawMetaType?: Array<string>, impact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', includeFields?: Array<string>, includeMetaAttr?: Array<string>, isMajorIncident?: boolean, limit?: number, majorIncidentState?: '' | 'APPROVED' | 'CISA_APPROVED' | 'INVALID' | 'REJECTED' | 'REQUESTED', nistCvssValidation?: '' | 'APPROVED' | 'REJECTED' | 'REQUESTED', nvdCvss2?: string, nvdCvss3?: string, offset?: number, order?: Array<'-acknowledgments__affiliation' | '-acknowledgments__created_dt' | '-acknowledgments__from_upstream' | '-acknowledgments__name' | '-acknowledgments__updated_dt' | '-acknowledgments__uuid' | '-affects__affectedness' | '-affects__created_dt' | '-affects__cvss2' | '-affects__cvss2_score' | '-affects__cvss3' | '-affects__cvss3_score' | '-affects__impact' | '-affects__ps_component' | '-affects__ps_module' | '-affects__resolution' | '-affects__trackers__created_dt' | '-affects__trackers__errata__advisory_name' | '-affects__trackers__errata__et_id' | '-affects__trackers__errata__shipped_dt' | '-affects__trackers__external_system_id' | '-affects__trackers__ps_update_stream' | '-affects__trackers__resolution' | '-affects__trackers__status' | '-affects__trackers__type' | '-affects__trackers__updated_dt' | '-affects__trackers__uuid' | '-affects__type' | '-affects__updated_dt' | '-affects__uuid' | '-component' | '-created_dt' | '-cve_id' | '-cvss2' | '-cvss2_score' | '-cvss3' | '-cvss3_score' | '-cvss_scores__comment' | '-cvss_scores__created_dt' | '-cvss_scores__issuer' | '-cvss_scores__score' | '-cvss_scores__updated_dt' | '-cvss_scores__uuid' | '-cvss_scores__vector' | '-cwe_id' | '-impact' | '-major_incident_state' | '-nist_cvss_validation' | '-nvd_cvss2' | '-nvd_cvss3' | '-references__created_dt' | '-references__description' | '-references__type' | '-references__updated_dt' | '-references__url' | '-references__uuid' | '-reported_dt' | '-requires_summary' | '-source' | '-type' | '-unembargo_dt' | '-updated_dt' | '-uuid' | 'acknowledgments__affiliation' | 'acknowledgments__created_dt' | 'acknowledgments__from_upstream' | 'acknowledgments__name' | 'acknowledgments__updated_dt' | 'acknowledgments__uuid' | 'affects__affectedness' | 'affects__created_dt' | 'affects__cvss2' | 'affects__cvss2_score' | 'affects__cvss3' | 'affects__cvss3_score' | 'affects__impact' | 'affects__ps_component' | 'affects__ps_module' | 'affects__resolution' | 'affects__trackers__created_dt' | 'affects__trackers__errata__advisory_name' | 'affects__trackers__errata__et_id' | 'affects__trackers__errata__shipped_dt' | 'affects__trackers__external_system_id' | 'affects__trackers__ps_update_stream' | 'affects__trackers__resolution' | 'affects__trackers__status' | 'affects__trackers__type' | 'affects__trackers__updated_dt' | 'affects__trackers__uuid' | 'affects__type' | 'affects__updated_dt' | 'affects__uuid' | 'component' | 'created_dt' | 'cve_id' | 'cvss2' | 'cvss2_score' | 'cvss3' | 'cvss3_score' | 'cvss_scores__comment' | 'cvss_scores__created_dt' | 'cvss_scores__issuer' | 'cvss_scores__score' | 'cvss_scores__updated_dt' | 'cvss_scores__uuid' | 'cvss_scores__vector' | 'cwe_id' | 'impact' | 'major_incident_state' | 'nist_cvss_validation' | 'nvd_cvss2' | 'nvd_cvss3' | 'references__created_dt' | 'references__description' | 'references__type' | 'references__updated_dt' | 'references__url' | 'references__uuid' | 'reported_dt' | 'requires_summary' | 'source' | 'type' | 'unembargo_dt' | 'updated_dt' | 'uuid'>, referencesCreatedDt?: string, referencesCreatedDtDate?: string, referencesCreatedDtDateGte?: string, referencesCreatedDtDateLte?: string, referencesCreatedDtGt?: string, referencesCreatedDtGte?: string, referencesCreatedDtLt?: string, referencesCreatedDtLte?: string, referencesDescription?: string, referencesType?: 'ARTICLE' | 'EXTERNAL' | 'SOURCE', referencesUpdatedDt?: string, referencesUpdatedDtDate?: string, referencesUpdatedDtDateGte?: string, referencesUpdatedDtDateLte?: string, referencesUpdatedDtGt?: string, referencesUpdatedDtGte?: string, referencesUpdatedDtLt?: string, referencesUpdatedDtLte?: string, referencesUrl?: string, referencesUuid?: string, reportedDt?: string, reportedDtDate?: string, reportedDtDateGte?: string, reportedDtDateLte?: string, reportedDtGt?: string, reportedDtGte?: string, reportedDtLt?: string, reportedDtLte?: string, requiresSummary?: '' | 'APPROVED' | 'REJECTED' | 'REQUESTED', search?: string, source?: '' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF', statement?: string, summary?: string, title?: string, trackerIds?: Array<string>, type?: 'VULNERABILITY' | 'WEAKNESS', unembargoDt?: string, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsList(acknowledgmentsAffiliation, acknowledgmentsCreatedDt, acknowledgmentsCreatedDtDate, acknowledgmentsCreatedDtDateGte, acknowledgmentsCreatedDtDateLte, acknowledgmentsCreatedDtGt, acknowledgmentsCreatedDtGte, acknowledgmentsCreatedDtLt, acknowledgmentsCreatedDtLte, acknowledgmentsFromUpstream, acknowledgmentsName, acknowledgmentsUpdatedDt, acknowledgmentsUpdatedDtDate, acknowledgmentsUpdatedDtDateGte, acknowledgmentsUpdatedDtDateLte, acknowledgmentsUpdatedDtGt, acknowledgmentsUpdatedDtGte, acknowledgmentsUpdatedDtLt, acknowledgmentsUpdatedDtLte, acknowledgmentsUuid, affectsAffectedness, affectsCreatedDt, affectsCreatedDtDate, affectsCreatedDtDateGte, affectsCreatedDtDateLte, affectsCreatedDtGt, affectsCreatedDtGte, affectsCreatedDtLt, affectsCreatedDtLte, affectsCvss2, affectsCvss2Score, affectsCvss2ScoreGt, affectsCvss2ScoreGte, affectsCvss2ScoreLt, affectsCvss2ScoreLte, affectsCvss3, affectsCvss3Score, affectsCvss3ScoreGt, affectsCvss3ScoreGte, affectsCvss3ScoreLt, affectsCvss3ScoreLte, affectsEmbargoed, affectsImpact, affectsPsComponent, affectsPsModule, affectsResolution, affectsTrackersCreatedDt, affectsTrackersCreatedDtDate, affectsTrackersCreatedDtDateGte, affectsTrackersCreatedDtDateLte, affectsTrackersCreatedDtGt, affectsTrackersCreatedDtGte, affectsTrackersCreatedDtLt, affectsTrackersCreatedDtLte, affectsTrackersEmbargoed, affectsTrackersErrataAdvisoryName, affectsTrackersErrataEtId, affectsTrackersErrataShippedDt, affectsTrackersErrataShippedDtDate, affectsTrackersErrataShippedDtDateGte, affectsTrackersErrataShippedDtDateLte, affectsTrackersErrataShippedDtGt, affectsTrackersErrataShippedDtGte, affectsTrackersErrataShippedDtLt, affectsTrackersErrataShippedDtLte, affectsTrackersExternalSystemId, affectsTrackersPsUpdateStream, affectsTrackersResolution, affectsTrackersStatus, affectsTrackersType, affectsTrackersUpdatedDt, affectsTrackersUpdatedDtDate, affectsTrackersUpdatedDtDateGte, affectsTrackersUpdatedDtDateLte, affectsTrackersUpdatedDtGt, affectsTrackersUpdatedDtGte, affectsTrackersUpdatedDtLt, affectsTrackersUpdatedDtLte, affectsTrackersUuid, affectsType, affectsUpdatedDt, affectsUpdatedDtDate, affectsUpdatedDtDateGte, affectsUpdatedDtDateLte, affectsUpdatedDtGt, affectsUpdatedDtGte, affectsUpdatedDtLt, affectsUpdatedDtLte, affectsUuid, bzId, changedAfter, changedBefore, component, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, cveId, cvss2, cvss2Score, cvss2ScoreGt, cvss2ScoreGte, cvss2ScoreLt, cvss2ScoreLte, cvss3, cvss3Score, cvss3ScoreGt, cvss3ScoreGte, cvss3ScoreLt, cvss3ScoreLte, cvssScoresComment, cvssScoresCreatedDt, cvssScoresCreatedDtDate, cvssScoresCreatedDtDateGte, cvssScoresCreatedDtDateLte, cvssScoresCreatedDtGt, cvssScoresCreatedDtGte, cvssScoresCreatedDtLt, cvssScoresCreatedDtLte, cvssScoresCvssVersion, cvssScoresIssuer, cvssScoresScore, cvssScoresUpdatedDt, cvssScoresUpdatedDtDate, cvssScoresUpdatedDtDateGte, cvssScoresUpdatedDtDateLte, cvssScoresUpdatedDtGt, cvssScoresUpdatedDtGte, cvssScoresUpdatedDtLt, cvssScoresUpdatedDtLte, cvssScoresUuid, cvssScoresVector, cweId, description, embargoed, excludeFields, flawMetaType, impact, includeFields, includeMetaAttr, isMajorIncident, limit, majorIncidentState, nistCvssValidation, nvdCvss2, nvdCvss3, offset, order, referencesCreatedDt, referencesCreatedDtDate, referencesCreatedDtDateGte, referencesCreatedDtDateLte, referencesCreatedDtGt, referencesCreatedDtGte, referencesCreatedDtLt, referencesCreatedDtLte, referencesDescription, referencesType, referencesUpdatedDt, referencesUpdatedDtDate, referencesUpdatedDtDateGte, referencesUpdatedDtDateLte, referencesUpdatedDtGt, referencesUpdatedDtGte, referencesUpdatedDtLt, referencesUpdatedDtLte, referencesUrl, referencesUuid, reportedDt, reportedDtDate, reportedDtDateGte, reportedDtDateLte, reportedDtGt, reportedDtGte, reportedDtLt, reportedDtLte, requiresSummary, search, source, statement, summary, title, trackerIds, type, unembargoDt, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} flawId 
     * @param {FlawPackageVersionPost} flawPackageVersionPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsPackageVersionsCreate(flawId: string, flawPackageVersionPost: FlawPackageVersionPost, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsPackageVersionsCreate(flawId, flawPackageVersionPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Destroy the instance and proxy the delete to Bugzilla
     * @param {string} flawId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsPackageVersionsDestroy(flawId: string, id: string, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsPackageVersionsDestroy(flawId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} flawId 
     * @param {string} [createdDt] 
     * @param {string} [createdDtDate] 
     * @param {string} [createdDtDateGte] 
     * @param {string} [createdDtDateLte] 
     * @param {string} [createdDtGt] 
     * @param {string} [createdDtGte] 
     * @param {string} [createdDtLt] 
     * @param {string} [createdDtLte] 
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [_package] 
     * @param {string} [updatedDt] 
     * @param {string} [updatedDtDate] 
     * @param {string} [updatedDtDateGte] 
     * @param {string} [updatedDtDateLte] 
     * @param {string} [updatedDtGt] 
     * @param {string} [updatedDtGte] 
     * @param {string} [updatedDtLt] 
     * @param {string} [updatedDtLte] 
     * @param {string} [uuid] 
     * @param {string} [versionsVersion] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsPackageVersionsList(flawId: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, excludeFields?: Array<string>, includeFields?: Array<string>, limit?: number, offset?: number, _package?: string, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, versionsVersion?: string, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsPackageVersionsList(flawId, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, excludeFields, includeFields, limit, offset, _package, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, versionsVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} flawId 
     * @param {string} id 
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsPackageVersionsRetrieve(flawId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsPackageVersionsRetrieve(flawId, id, excludeFields, includeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} flawId 
     * @param {string} id 
     * @param {FlawPackageVersionPut} flawPackageVersionPut 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsPackageVersionsUpdate(flawId: string, id: string, flawPackageVersionPut: FlawPackageVersionPut, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsPackageVersionsUpdate(flawId, id, flawPackageVersionPut, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} flawId 
     * @param {FlawReferencePost} flawReferencePost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsReferencesCreate(flawId: string, flawReferencePost: FlawReferencePost, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsReferencesCreate(flawId, flawReferencePost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Destroy the instance and proxy the delete to Bugzilla
     * @param {string} flawId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsReferencesDestroy(flawId: string, id: string, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsReferencesDestroy(flawId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} flawId 
     * @param {string} [createdDt] 
     * @param {string} [createdDtDate] 
     * @param {string} [createdDtDateGte] 
     * @param {string} [createdDtDateLte] 
     * @param {string} [createdDtGt] 
     * @param {string} [createdDtGte] 
     * @param {string} [createdDtLt] 
     * @param {string} [createdDtLte] 
     * @param {string} [description] 
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {'ARTICLE' | 'EXTERNAL' | 'SOURCE'} [type] 
     * @param {string} [updatedDt] 
     * @param {string} [updatedDtDate] 
     * @param {string} [updatedDtDateGte] 
     * @param {string} [updatedDtDateLte] 
     * @param {string} [updatedDtGt] 
     * @param {string} [updatedDtGte] 
     * @param {string} [updatedDtLt] 
     * @param {string} [updatedDtLte] 
     * @param {string} [url] 
     * @param {string} [uuid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsReferencesList(flawId: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, description?: string, excludeFields?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, limit?: number, offset?: number, type?: 'ARTICLE' | 'EXTERNAL' | 'SOURCE', updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, url?: string, uuid?: string, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsReferencesList(flawId, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, description, excludeFields, includeFields, includeMetaAttr, limit, offset, type, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, url, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} flawId 
     * @param {string} id 
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsReferencesRetrieve(flawId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsReferencesRetrieve(flawId, id, excludeFields, includeFields, includeMetaAttr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} flawId 
     * @param {string} id 
     * @param {FlawReferencePut} flawReferencePut 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsReferencesUpdate(flawId: string, id: string, flawReferencePut: FlawReferencePut, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsReferencesUpdate(flawId, id, flawReferencePut, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [flawMetaType] Include flaw metas with specified type only, multiple values may be separated by commas. 
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
     * @param {Array<string>} [trackerIds] Filter only Flaws which are related to specified Trackers (through Affects). Multiple tracker IDs may be separated by commas. Also only Affects that have the specified Trackers related will be shown.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsRetrieve(id: string, excludeFields?: Array<string>, flawMetaType?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, trackerIds?: Array<string>, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsRetrieve(id, excludeFields, flawMetaType, includeFields, includeMetaAttr, trackerIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
     * @param {string} jiraApiKey User generated api key for Jira authentication.
     * @param {string} id A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
     * @param {Flaw} flaw 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsUpdate(bugzillaApiKey: string, jiraApiKey: string, id: string, flaw: Flaw, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsUpdate(bugzillaApiKey, jiraApiKey, id, flaw, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HTTP get /manifest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1ManifestRetrieve(options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1ManifestRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
     * @param {'json' | 'yaml'} [format] 
     * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1SchemaRetrieve(format?: 'json' | 'yaml', lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1SchemaRetrieve(format, lang, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HTTP get /status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1StatusRetrieve(options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1StatusRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
     * @param {string} jiraApiKey User generated api key for Jira authentication.
     * @param {TrackerPost} trackerPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1TrackersCreate(bugzillaApiKey: string, jiraApiKey: string, trackerPost: TrackerPost, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1TrackersCreate(bugzillaApiKey, jiraApiKey, trackerPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {'' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED'} [affectsAffectedness] 
     * @param {string} [affectsCreatedDt] 
     * @param {string} [affectsCreatedDtDate] 
     * @param {string} [affectsCreatedDtDateGte] 
     * @param {string} [affectsCreatedDtDateLte] 
     * @param {string} [affectsCreatedDtGt] 
     * @param {string} [affectsCreatedDtGte] 
     * @param {string} [affectsCreatedDtLt] 
     * @param {string} [affectsCreatedDtLte] 
     * @param {string} [affectsCvss2] 
     * @param {number} [affectsCvss2Score] 
     * @param {number} [affectsCvss2ScoreGt] 
     * @param {number} [affectsCvss2ScoreGte] 
     * @param {number} [affectsCvss2ScoreLt] 
     * @param {number} [affectsCvss2ScoreLte] 
     * @param {string} [affectsCvss3] 
     * @param {number} [affectsCvss3Score] 
     * @param {number} [affectsCvss3ScoreGt] 
     * @param {number} [affectsCvss3ScoreGte] 
     * @param {number} [affectsCvss3ScoreLt] 
     * @param {number} [affectsCvss3ScoreLte] 
     * @param {boolean} [affectsEmbargoed] 
     * @param {string} [affectsFlawComponent] 
     * @param {string} [affectsFlawCreatedDt] 
     * @param {string} [affectsFlawCreatedDtDate] 
     * @param {string} [affectsFlawCreatedDtDateGte] 
     * @param {string} [affectsFlawCreatedDtDateLte] 
     * @param {string} [affectsFlawCreatedDtGt] 
     * @param {string} [affectsFlawCreatedDtGte] 
     * @param {string} [affectsFlawCreatedDtLt] 
     * @param {string} [affectsFlawCreatedDtLte] 
     * @param {string} [affectsFlawCveId] 
     * @param {string} [affectsFlawCvss2] 
     * @param {number} [affectsFlawCvss2Score] 
     * @param {number} [affectsFlawCvss2ScoreGt] 
     * @param {number} [affectsFlawCvss2ScoreGte] 
     * @param {number} [affectsFlawCvss2ScoreLt] 
     * @param {number} [affectsFlawCvss2ScoreLte] 
     * @param {string} [affectsFlawCvss3] 
     * @param {number} [affectsFlawCvss3Score] 
     * @param {number} [affectsFlawCvss3ScoreGt] 
     * @param {number} [affectsFlawCvss3ScoreGte] 
     * @param {number} [affectsFlawCvss3ScoreLt] 
     * @param {number} [affectsFlawCvss3ScoreLte] 
     * @param {string} [affectsFlawCweId] 
     * @param {boolean} [affectsFlawEmbargoed] 
     * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [affectsFlawImpact] 
     * @param {boolean} [affectsFlawIsMajorIncident] 
     * @param {string} [affectsFlawNvdCvss2] 
     * @param {string} [affectsFlawNvdCvss3] 
     * @param {string} [affectsFlawReportedDt] 
     * @param {string} [affectsFlawReportedDtDate] 
     * @param {string} [affectsFlawReportedDtDateGte] 
     * @param {string} [affectsFlawReportedDtDateLte] 
     * @param {string} [affectsFlawReportedDtGt] 
     * @param {string} [affectsFlawReportedDtGte] 
     * @param {string} [affectsFlawReportedDtLt] 
     * @param {string} [affectsFlawReportedDtLte] 
     * @param {'' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF'} [affectsFlawSource] 
     * @param {'VULNERABILITY' | 'WEAKNESS'} [affectsFlawType] 
     * @param {string} [affectsFlawUnembargoDt] 
     * @param {string} [affectsFlawUpdatedDt] 
     * @param {string} [affectsFlawUpdatedDtDate] 
     * @param {string} [affectsFlawUpdatedDtDateGte] 
     * @param {string} [affectsFlawUpdatedDtDateLte] 
     * @param {string} [affectsFlawUpdatedDtGt] 
     * @param {string} [affectsFlawUpdatedDtGte] 
     * @param {string} [affectsFlawUpdatedDtLt] 
     * @param {string} [affectsFlawUpdatedDtLte] 
     * @param {string} [affectsFlawUuid] 
     * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [affectsImpact] 
     * @param {string} [affectsPsComponent] 
     * @param {string} [affectsPsModule] 
     * @param {'' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT'} [affectsResolution] 
     * @param {'DEFAULT'} [affectsType] 
     * @param {string} [affectsUpdatedDt] 
     * @param {string} [affectsUpdatedDtDate] 
     * @param {string} [affectsUpdatedDtDateGte] 
     * @param {string} [affectsUpdatedDtDateLte] 
     * @param {string} [affectsUpdatedDtGt] 
     * @param {string} [affectsUpdatedDtGte] 
     * @param {string} [affectsUpdatedDtLt] 
     * @param {string} [affectsUpdatedDtLte] 
     * @param {string} [affectsUuid] 
     * @param {string} [createdDt] 
     * @param {string} [createdDtDate] 
     * @param {string} [createdDtDateGte] 
     * @param {string} [createdDtDateLte] 
     * @param {string} [createdDtGt] 
     * @param {string} [createdDtGte] 
     * @param {string} [createdDtLt] 
     * @param {string} [createdDtLte] 
     * @param {boolean} [embargoed] 
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {string} [externalSystemId] 
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {Array<'-affects__affectedness' | '-affects__created_dt' | '-affects__cvss2' | '-affects__cvss2_score' | '-affects__cvss3' | '-affects__cvss3_score' | '-affects__flaw__component' | '-affects__flaw__created_dt' | '-affects__flaw__cve_id' | '-affects__flaw__cvss2' | '-affects__flaw__cvss2_score' | '-affects__flaw__cvss3' | '-affects__flaw__cvss3_score' | '-affects__flaw__cwe_id' | '-affects__flaw__impact' | '-affects__flaw__nvd_cvss2' | '-affects__flaw__nvd_cvss3' | '-affects__flaw__reported_dt' | '-affects__flaw__source' | '-affects__flaw__type' | '-affects__flaw__unembargo_dt' | '-affects__flaw__updated_dt' | '-affects__flaw__uuid' | '-affects__impact' | '-affects__ps_component' | '-affects__ps_module' | '-affects__resolution' | '-affects__type' | '-affects__updated_dt' | '-affects__uuid' | '-created_dt' | '-external_system_id' | '-ps_update_stream' | '-resolution' | '-status' | '-type' | '-updated_dt' | '-uuid' | 'affects__affectedness' | 'affects__created_dt' | 'affects__cvss2' | 'affects__cvss2_score' | 'affects__cvss3' | 'affects__cvss3_score' | 'affects__flaw__component' | 'affects__flaw__created_dt' | 'affects__flaw__cve_id' | 'affects__flaw__cvss2' | 'affects__flaw__cvss2_score' | 'affects__flaw__cvss3' | 'affects__flaw__cvss3_score' | 'affects__flaw__cwe_id' | 'affects__flaw__impact' | 'affects__flaw__nvd_cvss2' | 'affects__flaw__nvd_cvss3' | 'affects__flaw__reported_dt' | 'affects__flaw__source' | 'affects__flaw__type' | 'affects__flaw__unembargo_dt' | 'affects__flaw__updated_dt' | 'affects__flaw__uuid' | 'affects__impact' | 'affects__ps_component' | 'affects__ps_module' | 'affects__resolution' | 'affects__type' | 'affects__updated_dt' | 'affects__uuid' | 'created_dt' | 'external_system_id' | 'ps_update_stream' | 'resolution' | 'status' | 'type' | 'updated_dt' | 'uuid'>} [order] Ordering
     * @param {string} [psUpdateStream] 
     * @param {string} [resolution] 
     * @param {string} [status] 
     * @param {'BUGZILLA' | 'JIRA'} [type] 
     * @param {string} [updatedDt] 
     * @param {string} [updatedDtDate] 
     * @param {string} [updatedDtDateGte] 
     * @param {string} [updatedDtDateLte] 
     * @param {string} [updatedDtGt] 
     * @param {string} [updatedDtGte] 
     * @param {string} [updatedDtLt] 
     * @param {string} [updatedDtLte] 
     * @param {string} [uuid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1TrackersList(affectsAffectedness?: '' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED', affectsCreatedDt?: string, affectsCreatedDtDate?: string, affectsCreatedDtDateGte?: string, affectsCreatedDtDateLte?: string, affectsCreatedDtGt?: string, affectsCreatedDtGte?: string, affectsCreatedDtLt?: string, affectsCreatedDtLte?: string, affectsCvss2?: string, affectsCvss2Score?: number, affectsCvss2ScoreGt?: number, affectsCvss2ScoreGte?: number, affectsCvss2ScoreLt?: number, affectsCvss2ScoreLte?: number, affectsCvss3?: string, affectsCvss3Score?: number, affectsCvss3ScoreGt?: number, affectsCvss3ScoreGte?: number, affectsCvss3ScoreLt?: number, affectsCvss3ScoreLte?: number, affectsEmbargoed?: boolean, affectsFlawComponent?: string, affectsFlawCreatedDt?: string, affectsFlawCreatedDtDate?: string, affectsFlawCreatedDtDateGte?: string, affectsFlawCreatedDtDateLte?: string, affectsFlawCreatedDtGt?: string, affectsFlawCreatedDtGte?: string, affectsFlawCreatedDtLt?: string, affectsFlawCreatedDtLte?: string, affectsFlawCveId?: string, affectsFlawCvss2?: string, affectsFlawCvss2Score?: number, affectsFlawCvss2ScoreGt?: number, affectsFlawCvss2ScoreGte?: number, affectsFlawCvss2ScoreLt?: number, affectsFlawCvss2ScoreLte?: number, affectsFlawCvss3?: string, affectsFlawCvss3Score?: number, affectsFlawCvss3ScoreGt?: number, affectsFlawCvss3ScoreGte?: number, affectsFlawCvss3ScoreLt?: number, affectsFlawCvss3ScoreLte?: number, affectsFlawCweId?: string, affectsFlawEmbargoed?: boolean, affectsFlawImpact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', affectsFlawIsMajorIncident?: boolean, affectsFlawNvdCvss2?: string, affectsFlawNvdCvss3?: string, affectsFlawReportedDt?: string, affectsFlawReportedDtDate?: string, affectsFlawReportedDtDateGte?: string, affectsFlawReportedDtDateLte?: string, affectsFlawReportedDtGt?: string, affectsFlawReportedDtGte?: string, affectsFlawReportedDtLt?: string, affectsFlawReportedDtLte?: string, affectsFlawSource?: '' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF', affectsFlawType?: 'VULNERABILITY' | 'WEAKNESS', affectsFlawUnembargoDt?: string, affectsFlawUpdatedDt?: string, affectsFlawUpdatedDtDate?: string, affectsFlawUpdatedDtDateGte?: string, affectsFlawUpdatedDtDateLte?: string, affectsFlawUpdatedDtGt?: string, affectsFlawUpdatedDtGte?: string, affectsFlawUpdatedDtLt?: string, affectsFlawUpdatedDtLte?: string, affectsFlawUuid?: string, affectsImpact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', affectsPsComponent?: string, affectsPsModule?: string, affectsResolution?: '' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT', affectsType?: 'DEFAULT', affectsUpdatedDt?: string, affectsUpdatedDtDate?: string, affectsUpdatedDtDateGte?: string, affectsUpdatedDtDateLte?: string, affectsUpdatedDtGt?: string, affectsUpdatedDtGte?: string, affectsUpdatedDtLt?: string, affectsUpdatedDtLte?: string, affectsUuid?: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, embargoed?: boolean, excludeFields?: Array<string>, externalSystemId?: string, includeFields?: Array<string>, includeMetaAttr?: Array<string>, limit?: number, offset?: number, order?: Array<'-affects__affectedness' | '-affects__created_dt' | '-affects__cvss2' | '-affects__cvss2_score' | '-affects__cvss3' | '-affects__cvss3_score' | '-affects__flaw__component' | '-affects__flaw__created_dt' | '-affects__flaw__cve_id' | '-affects__flaw__cvss2' | '-affects__flaw__cvss2_score' | '-affects__flaw__cvss3' | '-affects__flaw__cvss3_score' | '-affects__flaw__cwe_id' | '-affects__flaw__impact' | '-affects__flaw__nvd_cvss2' | '-affects__flaw__nvd_cvss3' | '-affects__flaw__reported_dt' | '-affects__flaw__source' | '-affects__flaw__type' | '-affects__flaw__unembargo_dt' | '-affects__flaw__updated_dt' | '-affects__flaw__uuid' | '-affects__impact' | '-affects__ps_component' | '-affects__ps_module' | '-affects__resolution' | '-affects__type' | '-affects__updated_dt' | '-affects__uuid' | '-created_dt' | '-external_system_id' | '-ps_update_stream' | '-resolution' | '-status' | '-type' | '-updated_dt' | '-uuid' | 'affects__affectedness' | 'affects__created_dt' | 'affects__cvss2' | 'affects__cvss2_score' | 'affects__cvss3' | 'affects__cvss3_score' | 'affects__flaw__component' | 'affects__flaw__created_dt' | 'affects__flaw__cve_id' | 'affects__flaw__cvss2' | 'affects__flaw__cvss2_score' | 'affects__flaw__cvss3' | 'affects__flaw__cvss3_score' | 'affects__flaw__cwe_id' | 'affects__flaw__impact' | 'affects__flaw__nvd_cvss2' | 'affects__flaw__nvd_cvss3' | 'affects__flaw__reported_dt' | 'affects__flaw__source' | 'affects__flaw__type' | 'affects__flaw__unembargo_dt' | 'affects__flaw__updated_dt' | 'affects__flaw__uuid' | 'affects__impact' | 'affects__ps_component' | 'affects__ps_module' | 'affects__resolution' | 'affects__type' | 'affects__updated_dt' | 'affects__uuid' | 'created_dt' | 'external_system_id' | 'ps_update_stream' | 'resolution' | 'status' | 'type' | 'updated_dt' | 'uuid'>, psUpdateStream?: string, resolution?: string, status?: string, type?: 'BUGZILLA' | 'JIRA', updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1TrackersList(affectsAffectedness, affectsCreatedDt, affectsCreatedDtDate, affectsCreatedDtDateGte, affectsCreatedDtDateLte, affectsCreatedDtGt, affectsCreatedDtGte, affectsCreatedDtLt, affectsCreatedDtLte, affectsCvss2, affectsCvss2Score, affectsCvss2ScoreGt, affectsCvss2ScoreGte, affectsCvss2ScoreLt, affectsCvss2ScoreLte, affectsCvss3, affectsCvss3Score, affectsCvss3ScoreGt, affectsCvss3ScoreGte, affectsCvss3ScoreLt, affectsCvss3ScoreLte, affectsEmbargoed, affectsFlawComponent, affectsFlawCreatedDt, affectsFlawCreatedDtDate, affectsFlawCreatedDtDateGte, affectsFlawCreatedDtDateLte, affectsFlawCreatedDtGt, affectsFlawCreatedDtGte, affectsFlawCreatedDtLt, affectsFlawCreatedDtLte, affectsFlawCveId, affectsFlawCvss2, affectsFlawCvss2Score, affectsFlawCvss2ScoreGt, affectsFlawCvss2ScoreGte, affectsFlawCvss2ScoreLt, affectsFlawCvss2ScoreLte, affectsFlawCvss3, affectsFlawCvss3Score, affectsFlawCvss3ScoreGt, affectsFlawCvss3ScoreGte, affectsFlawCvss3ScoreLt, affectsFlawCvss3ScoreLte, affectsFlawCweId, affectsFlawEmbargoed, affectsFlawImpact, affectsFlawIsMajorIncident, affectsFlawNvdCvss2, affectsFlawNvdCvss3, affectsFlawReportedDt, affectsFlawReportedDtDate, affectsFlawReportedDtDateGte, affectsFlawReportedDtDateLte, affectsFlawReportedDtGt, affectsFlawReportedDtGte, affectsFlawReportedDtLt, affectsFlawReportedDtLte, affectsFlawSource, affectsFlawType, affectsFlawUnembargoDt, affectsFlawUpdatedDt, affectsFlawUpdatedDtDate, affectsFlawUpdatedDtDateGte, affectsFlawUpdatedDtDateLte, affectsFlawUpdatedDtGt, affectsFlawUpdatedDtGte, affectsFlawUpdatedDtLt, affectsFlawUpdatedDtLte, affectsFlawUuid, affectsImpact, affectsPsComponent, affectsPsModule, affectsResolution, affectsType, affectsUpdatedDt, affectsUpdatedDtDate, affectsUpdatedDtDateGte, affectsUpdatedDtDateLte, affectsUpdatedDtGt, affectsUpdatedDtGte, affectsUpdatedDtLt, affectsUpdatedDtLte, affectsUuid, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, embargoed, excludeFields, externalSystemId, includeFields, includeMetaAttr, limit, offset, order, psUpdateStream, resolution, status, type, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid A UUID string identifying this Tracker.
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1TrackersRetrieve(uuid: string, excludeFields?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1TrackersRetrieve(uuid, excludeFields, includeFields, includeMetaAttr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
     * @param {string} jiraApiKey User generated api key for Jira authentication.
     * @param {string} uuid A UUID string identifying this Tracker.
     * @param {Tracker} tracker 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1TrackersUpdate(bugzillaApiKey: string, jiraApiKey: string, uuid: string, tracker: Tracker, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1TrackersUpdate(bugzillaApiKey, jiraApiKey, uuid, tracker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * unauthenticated view providing healthcheck on osidb service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbHealthyRetrieve(options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbHealthyRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * View that provides information about the currently logged-in user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbWhoamiRetrieve(options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbWhoamiRetrieve(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OsimApi - axios parameter creator
 * @export
 */
export const OsimApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * workflow adjustion API endpoint  adjust workflow classification of flaw identified by UUID or CVE and return its workflow:state classification (new if changed and old otherwise)  adjust operation is idempotent so when the classification is already adjusted running it results in no operation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osimApiV1WorkflowsAdjustCreate: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osimApiV1WorkflowsAdjustCreate', 'id', id)
            const localVarPath = `/osim/api/v1/workflows/{id}/adjust`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * workflow info API endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osimApiV1WorkflowsRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/osim/api/v1/workflows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * workflow classification API endpoint  for flaw identified by UUID or CVE returns its workflow:state classification  params:      verbose - return also workflows with flaw classification               which represents the reasoning of the result
         * @param {string} id 
         * @param {boolean} [verbose] Return also workflows with flaw classification which represents the reasoning of the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osimApiV1WorkflowsRetrieve2: async (id: string, verbose?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osimApiV1WorkflowsRetrieve2', 'id', id)
            const localVarPath = `/osim/api/v1/workflows/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (verbose !== undefined) {
                localVarQueryParameter['verbose'] = verbose;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * unauthenticated health check API endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osimHealthyRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/osim/healthy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * index API endpoint listing available API endpoints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osimRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/osim/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OsimApi - functional programming interface
 * @export
 */
export const OsimApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OsimApiAxiosParamCreator(configuration)
    return {
        /**
         * workflow adjustion API endpoint  adjust workflow classification of flaw identified by UUID or CVE and return its workflow:state classification (new if changed and old otherwise)  adjust operation is idempotent so when the classification is already adjusted running it results in no operation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osimApiV1WorkflowsAdjustCreate(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200ResponseAllOf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osimApiV1WorkflowsAdjustCreate(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * workflow info API endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osimApiV1WorkflowsRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200ResponseAllOf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osimApiV1WorkflowsRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * workflow classification API endpoint  for flaw identified by UUID or CVE returns its workflow:state classification  params:      verbose - return also workflows with flaw classification               which represents the reasoning of the result
         * @param {string} id 
         * @param {boolean} [verbose] Return also workflows with flaw classification which represents the reasoning of the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osimApiV1WorkflowsRetrieve2(id: string, verbose?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200ResponseAllOf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osimApiV1WorkflowsRetrieve2(id, verbose, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * unauthenticated health check API endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osimHealthyRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200ResponseAllOf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osimHealthyRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * index API endpoint listing available API endpoints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osimRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200ResponseAllOf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osimRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OsimApi - factory interface
 * @export
 */
export const OsimApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OsimApiFp(configuration)
    return {
        /**
         * workflow adjustion API endpoint  adjust workflow classification of flaw identified by UUID or CVE and return its workflow:state classification (new if changed and old otherwise)  adjust operation is idempotent so when the classification is already adjusted running it results in no operation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osimApiV1WorkflowsAdjustCreate(id: string, options?: any): AxiosPromise<AuthTokenCreate200ResponseAllOf> {
            return localVarFp.osimApiV1WorkflowsAdjustCreate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * workflow info API endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osimApiV1WorkflowsRetrieve(options?: any): AxiosPromise<AuthTokenCreate200ResponseAllOf> {
            return localVarFp.osimApiV1WorkflowsRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * workflow classification API endpoint  for flaw identified by UUID or CVE returns its workflow:state classification  params:      verbose - return also workflows with flaw classification               which represents the reasoning of the result
         * @param {string} id 
         * @param {boolean} [verbose] Return also workflows with flaw classification which represents the reasoning of the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osimApiV1WorkflowsRetrieve2(id: string, verbose?: boolean, options?: any): AxiosPromise<AuthTokenCreate200ResponseAllOf> {
            return localVarFp.osimApiV1WorkflowsRetrieve2(id, verbose, options).then((request) => request(axios, basePath));
        },
        /**
         * unauthenticated health check API endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osimHealthyRetrieve(options?: any): AxiosPromise<AuthTokenCreate200ResponseAllOf> {
            return localVarFp.osimHealthyRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * index API endpoint listing available API endpoints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osimRetrieve(options?: any): AxiosPromise<AuthTokenCreate200ResponseAllOf> {
            return localVarFp.osimRetrieve(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OsimApi - object-oriented interface
 * @export
 * @class OsimApi
 * @extends {BaseAPI}
 */
export class OsimApi extends BaseAPI {
    /**
     * workflow adjustion API endpoint  adjust workflow classification of flaw identified by UUID or CVE and return its workflow:state classification (new if changed and old otherwise)  adjust operation is idempotent so when the classification is already adjusted running it results in no operation
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsimApi
     */
    public osimApiV1WorkflowsAdjustCreate(id: string, options?: AxiosRequestConfig) {
        return OsimApiFp(this.configuration).osimApiV1WorkflowsAdjustCreate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * workflow info API endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsimApi
     */
    public osimApiV1WorkflowsRetrieve(options?: AxiosRequestConfig) {
        return OsimApiFp(this.configuration).osimApiV1WorkflowsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * workflow classification API endpoint  for flaw identified by UUID or CVE returns its workflow:state classification  params:      verbose - return also workflows with flaw classification               which represents the reasoning of the result
     * @param {string} id 
     * @param {boolean} [verbose] Return also workflows with flaw classification which represents the reasoning of the result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsimApi
     */
    public osimApiV1WorkflowsRetrieve2(id: string, verbose?: boolean, options?: AxiosRequestConfig) {
        return OsimApiFp(this.configuration).osimApiV1WorkflowsRetrieve2(id, verbose, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * unauthenticated health check API endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsimApi
     */
    public osimHealthyRetrieve(options?: AxiosRequestConfig) {
        return OsimApiFp(this.configuration).osimHealthyRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * index API endpoint listing available API endpoints
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsimApi
     */
    public osimRetrieve(options?: AxiosRequestConfig) {
        return OsimApiFp(this.configuration).osimRetrieve(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TaskmanApi - axios parameter creator
 * @export
 */
export const TaskmanApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new group of tasks
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {string} name 
         * @param {string} [description] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskmanApiV1GroupCreate: async (jiraApiKey: string, name: string, description?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jiraApiKey' is not null or undefined
            assertParamExists('taskmanApiV1GroupCreate', 'jiraApiKey', jiraApiKey)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('taskmanApiV1GroupCreate', 'name', name)
            const localVarPath = `/taskman/api/v1/group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (jiraApiKey != null) {
                localVarHeaderParameter['Jira-Api-Key'] = String(jiraApiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of tasks from a group
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {string} groupKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskmanApiV1GroupRetrieve: async (jiraApiKey: string, groupKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jiraApiKey' is not null or undefined
            assertParamExists('taskmanApiV1GroupRetrieve', 'jiraApiKey', jiraApiKey)
            // verify required parameter 'groupKey' is not null or undefined
            assertParamExists('taskmanApiV1GroupRetrieve', 'groupKey', groupKey)
            const localVarPath = `/taskman/api/v1/group/{group_key}`
                .replace(`{${"group_key"}}`, encodeURIComponent(String(groupKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (jiraApiKey != null) {
                localVarHeaderParameter['Jira-Api-Key'] = String(jiraApiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a task into a group
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {string} groupKey 
         * @param {string} taskKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskmanApiV1GroupUpdate: async (jiraApiKey: string, groupKey: string, taskKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jiraApiKey' is not null or undefined
            assertParamExists('taskmanApiV1GroupUpdate', 'jiraApiKey', jiraApiKey)
            // verify required parameter 'groupKey' is not null or undefined
            assertParamExists('taskmanApiV1GroupUpdate', 'groupKey', groupKey)
            // verify required parameter 'taskKey' is not null or undefined
            assertParamExists('taskmanApiV1GroupUpdate', 'taskKey', taskKey)
            const localVarPath = `/taskman/api/v1/group/{group_key}`
                .replace(`{${"group_key"}}`, encodeURIComponent(String(groupKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (taskKey !== undefined) {
                localVarQueryParameter['task_key'] = taskKey;
            }

            if (jiraApiKey != null) {
                localVarHeaderParameter['Jira-Api-Key'] = String(jiraApiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of tasks from a user
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskmanApiV1TaskAssigneeRetrieve: async (jiraApiKey: string, user: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jiraApiKey' is not null or undefined
            assertParamExists('taskmanApiV1TaskAssigneeRetrieve', 'jiraApiKey', jiraApiKey)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('taskmanApiV1TaskAssigneeRetrieve', 'user', user)
            const localVarPath = `/taskman/api/v1/task/assignee/{user}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (jiraApiKey != null) {
                localVarHeaderParameter['Jira-Api-Key'] = String(jiraApiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assign a task to a user
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {string} taskKey 
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskmanApiV1TaskAssigneeUpdate: async (jiraApiKey: string, taskKey: string, user: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jiraApiKey' is not null or undefined
            assertParamExists('taskmanApiV1TaskAssigneeUpdate', 'jiraApiKey', jiraApiKey)
            // verify required parameter 'taskKey' is not null or undefined
            assertParamExists('taskmanApiV1TaskAssigneeUpdate', 'taskKey', taskKey)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('taskmanApiV1TaskAssigneeUpdate', 'user', user)
            const localVarPath = `/taskman/api/v1/task/assignee/{user}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (taskKey !== undefined) {
                localVarQueryParameter['task_key'] = taskKey;
            }

            if (jiraApiKey != null) {
                localVarHeaderParameter['Jira-Api-Key'] = String(jiraApiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new comment in a task
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {string} content 
         * @param {string} taskKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskmanApiV1TaskCommentCreate: async (jiraApiKey: string, content: string, taskKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jiraApiKey' is not null or undefined
            assertParamExists('taskmanApiV1TaskCommentCreate', 'jiraApiKey', jiraApiKey)
            // verify required parameter 'content' is not null or undefined
            assertParamExists('taskmanApiV1TaskCommentCreate', 'content', content)
            // verify required parameter 'taskKey' is not null or undefined
            assertParamExists('taskmanApiV1TaskCommentCreate', 'taskKey', taskKey)
            const localVarPath = `/taskman/api/v1/task/{task_key}/comment`
                .replace(`{${"task_key"}}`, encodeURIComponent(String(taskKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (content !== undefined) {
                localVarQueryParameter['content'] = content;
            }

            if (jiraApiKey != null) {
                localVarHeaderParameter['Jira-Api-Key'] = String(jiraApiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit a comment in a task
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {string} commentId 
         * @param {string} content 
         * @param {string} taskKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskmanApiV1TaskCommentUpdate: async (jiraApiKey: string, commentId: string, content: string, taskKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jiraApiKey' is not null or undefined
            assertParamExists('taskmanApiV1TaskCommentUpdate', 'jiraApiKey', jiraApiKey)
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('taskmanApiV1TaskCommentUpdate', 'commentId', commentId)
            // verify required parameter 'content' is not null or undefined
            assertParamExists('taskmanApiV1TaskCommentUpdate', 'content', content)
            // verify required parameter 'taskKey' is not null or undefined
            assertParamExists('taskmanApiV1TaskCommentUpdate', 'taskKey', taskKey)
            const localVarPath = `/taskman/api/v1/task/{task_key}/comment/{comment_id}`
                .replace(`{${"comment_id"}}`, encodeURIComponent(String(commentId)))
                .replace(`{${"task_key"}}`, encodeURIComponent(String(taskKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (content !== undefined) {
                localVarQueryParameter['content'] = content;
            }

            if (jiraApiKey != null) {
                localVarHeaderParameter['Jira-Api-Key'] = String(jiraApiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a task in Jira from a Flaw
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {string} flawUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskmanApiV1TaskFlawCreate: async (jiraApiKey: string, flawUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jiraApiKey' is not null or undefined
            assertParamExists('taskmanApiV1TaskFlawCreate', 'jiraApiKey', jiraApiKey)
            // verify required parameter 'flawUuid' is not null or undefined
            assertParamExists('taskmanApiV1TaskFlawCreate', 'flawUuid', flawUuid)
            const localVarPath = `/taskman/api/v1/task/flaw/{flaw_uuid}`
                .replace(`{${"flaw_uuid"}}`, encodeURIComponent(String(flawUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (jiraApiKey != null) {
                localVarHeaderParameter['Jira-Api-Key'] = String(jiraApiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a task from Jira given a Flaw uuid
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {string} flawUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskmanApiV1TaskFlawRetrieve: async (jiraApiKey: string, flawUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jiraApiKey' is not null or undefined
            assertParamExists('taskmanApiV1TaskFlawRetrieve', 'jiraApiKey', jiraApiKey)
            // verify required parameter 'flawUuid' is not null or undefined
            assertParamExists('taskmanApiV1TaskFlawRetrieve', 'flawUuid', flawUuid)
            const localVarPath = `/taskman/api/v1/task/flaw/{flaw_uuid}`
                .replace(`{${"flaw_uuid"}}`, encodeURIComponent(String(flawUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (jiraApiKey != null) {
                localVarHeaderParameter['Jira-Api-Key'] = String(jiraApiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a task in Jira from a Flaw
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {string} flawUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskmanApiV1TaskFlawUpdate: async (jiraApiKey: string, flawUuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jiraApiKey' is not null or undefined
            assertParamExists('taskmanApiV1TaskFlawUpdate', 'jiraApiKey', jiraApiKey)
            // verify required parameter 'flawUuid' is not null or undefined
            assertParamExists('taskmanApiV1TaskFlawUpdate', 'flawUuid', flawUuid)
            const localVarPath = `/taskman/api/v1/task/flaw/{flaw_uuid}`
                .replace(`{${"flaw_uuid"}}`, encodeURIComponent(String(flawUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (jiraApiKey != null) {
                localVarHeaderParameter['Jira-Api-Key'] = String(jiraApiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a task from Jira given a task key
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {string} taskKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskmanApiV1TaskRetrieve: async (jiraApiKey: string, taskKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jiraApiKey' is not null or undefined
            assertParamExists('taskmanApiV1TaskRetrieve', 'jiraApiKey', jiraApiKey)
            // verify required parameter 'taskKey' is not null or undefined
            assertParamExists('taskmanApiV1TaskRetrieve', 'taskKey', taskKey)
            const localVarPath = `/taskman/api/v1/task/{task_key}`
                .replace(`{${"task_key"}}`, encodeURIComponent(String(taskKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (jiraApiKey != null) {
                localVarHeaderParameter['Jira-Api-Key'] = String(jiraApiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change a task workflow status
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {'Closed' | 'In Progress' | 'New' | 'Refinement'} status 
         * @param {string} taskKey 
         * @param {'Closed' | 'In Progress' | 'New' | 'Refinement'} [reason] Reason of status change. Mandatory for rejecting a task.
         * @param {'Can\'t Do' | 'Cannot Reproduce' | 'Done' | 'Done-Errata' | 'Duplicate' | 'MirrorOrphan' | 'Not a Bug' | 'Obsolete' | 'Test Pending' | 'Won\'t Do'} [resolution] Resolution of a CLOSED task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskmanApiV1TaskStatusUpdate: async (jiraApiKey: string, status: 'Closed' | 'In Progress' | 'New' | 'Refinement', taskKey: string, reason?: 'Closed' | 'In Progress' | 'New' | 'Refinement', resolution?: 'Can\'t Do' | 'Cannot Reproduce' | 'Done' | 'Done-Errata' | 'Duplicate' | 'MirrorOrphan' | 'Not a Bug' | 'Obsolete' | 'Test Pending' | 'Won\'t Do', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jiraApiKey' is not null or undefined
            assertParamExists('taskmanApiV1TaskStatusUpdate', 'jiraApiKey', jiraApiKey)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('taskmanApiV1TaskStatusUpdate', 'status', status)
            // verify required parameter 'taskKey' is not null or undefined
            assertParamExists('taskmanApiV1TaskStatusUpdate', 'taskKey', taskKey)
            const localVarPath = `/taskman/api/v1/task/{task_key}/status`
                .replace(`{${"task_key"}}`, encodeURIComponent(String(taskKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (reason !== undefined) {
                localVarQueryParameter['reason'] = reason;
            }

            if (resolution !== undefined) {
                localVarQueryParameter['resolution'] = resolution;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (jiraApiKey != null) {
                localVarHeaderParameter['Jira-Api-Key'] = String(jiraApiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of tasks without an user assigned
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskmanApiV1TaskUnassignedRetrieve: async (jiraApiKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jiraApiKey' is not null or undefined
            assertParamExists('taskmanApiV1TaskUnassignedRetrieve', 'jiraApiKey', jiraApiKey)
            const localVarPath = `/taskman/api/v1/task/unassigned/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (jiraApiKey != null) {
                localVarHeaderParameter['Jira-Api-Key'] = String(jiraApiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * unauthenticated health check API endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskmanHealthyRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/taskman/healthy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskmanApi - functional programming interface
 * @export
 */
export const TaskmanApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TaskmanApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new group of tasks
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {string} name 
         * @param {string} [description] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskmanApiV1GroupCreate(jiraApiKey: string, name: string, description?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskmanApiV1GroupCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskmanApiV1GroupCreate(jiraApiKey, name, description, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of tasks from a group
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {string} groupKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskmanApiV1GroupRetrieve(jiraApiKey: string, groupKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskmanApiV1GroupRetrieve200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskmanApiV1GroupRetrieve(jiraApiKey, groupKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a task into a group
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {string} groupKey 
         * @param {string} taskKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskmanApiV1GroupUpdate(jiraApiKey: string, groupKey: string, taskKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200ResponseAllOf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskmanApiV1GroupUpdate(jiraApiKey, groupKey, taskKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of tasks from a user
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskmanApiV1TaskAssigneeRetrieve(jiraApiKey: string, user: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskmanApiV1GroupRetrieve200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskmanApiV1TaskAssigneeRetrieve(jiraApiKey, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Assign a task to a user
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {string} taskKey 
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskmanApiV1TaskAssigneeUpdate(jiraApiKey: string, taskKey: string, user: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200ResponseAllOf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskmanApiV1TaskAssigneeUpdate(jiraApiKey, taskKey, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new comment in a task
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {string} content 
         * @param {string} taskKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskmanApiV1TaskCommentCreate(jiraApiKey: string, content: string, taskKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskmanApiV1TaskCommentCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskmanApiV1TaskCommentCreate(jiraApiKey, content, taskKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit a comment in a task
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {string} commentId 
         * @param {string} content 
         * @param {string} taskKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskmanApiV1TaskCommentUpdate(jiraApiKey: string, commentId: string, content: string, taskKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskmanApiV1TaskCommentCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskmanApiV1TaskCommentUpdate(jiraApiKey, commentId, content, taskKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a task in Jira from a Flaw
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {string} flawUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskmanApiV1TaskFlawCreate(jiraApiKey: string, flawUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200ResponseAllOf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskmanApiV1TaskFlawCreate(jiraApiKey, flawUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a task from Jira given a Flaw uuid
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {string} flawUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskmanApiV1TaskFlawRetrieve(jiraApiKey: string, flawUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskmanApiV1GroupCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskmanApiV1TaskFlawRetrieve(jiraApiKey, flawUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a task in Jira from a Flaw
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {string} flawUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskmanApiV1TaskFlawUpdate(jiraApiKey: string, flawUuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200ResponseAllOf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskmanApiV1TaskFlawUpdate(jiraApiKey, flawUuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a task from Jira given a task key
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {string} taskKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskmanApiV1TaskRetrieve(jiraApiKey: string, taskKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskmanApiV1GroupCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskmanApiV1TaskRetrieve(jiraApiKey, taskKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change a task workflow status
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {'Closed' | 'In Progress' | 'New' | 'Refinement'} status 
         * @param {string} taskKey 
         * @param {'Closed' | 'In Progress' | 'New' | 'Refinement'} [reason] Reason of status change. Mandatory for rejecting a task.
         * @param {'Can\'t Do' | 'Cannot Reproduce' | 'Done' | 'Done-Errata' | 'Duplicate' | 'MirrorOrphan' | 'Not a Bug' | 'Obsolete' | 'Test Pending' | 'Won\'t Do'} [resolution] Resolution of a CLOSED task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskmanApiV1TaskStatusUpdate(jiraApiKey: string, status: 'Closed' | 'In Progress' | 'New' | 'Refinement', taskKey: string, reason?: 'Closed' | 'In Progress' | 'New' | 'Refinement', resolution?: 'Can\'t Do' | 'Cannot Reproduce' | 'Done' | 'Done-Errata' | 'Duplicate' | 'MirrorOrphan' | 'Not a Bug' | 'Obsolete' | 'Test Pending' | 'Won\'t Do', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200ResponseAllOf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskmanApiV1TaskStatusUpdate(jiraApiKey, status, taskKey, reason, resolution, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of tasks without an user assigned
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskmanApiV1TaskUnassignedRetrieve(jiraApiKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskmanApiV1GroupRetrieve200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskmanApiV1TaskUnassignedRetrieve(jiraApiKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * unauthenticated health check API endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskmanHealthyRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200ResponseAllOf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskmanHealthyRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TaskmanApi - factory interface
 * @export
 */
export const TaskmanApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaskmanApiFp(configuration)
    return {
        /**
         * Create a new group of tasks
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {string} name 
         * @param {string} [description] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskmanApiV1GroupCreate(jiraApiKey: string, name: string, description?: string, options?: any): AxiosPromise<TaskmanApiV1GroupCreate200Response> {
            return localVarFp.taskmanApiV1GroupCreate(jiraApiKey, name, description, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of tasks from a group
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {string} groupKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskmanApiV1GroupRetrieve(jiraApiKey: string, groupKey: string, options?: any): AxiosPromise<TaskmanApiV1GroupRetrieve200Response> {
            return localVarFp.taskmanApiV1GroupRetrieve(jiraApiKey, groupKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a task into a group
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {string} groupKey 
         * @param {string} taskKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskmanApiV1GroupUpdate(jiraApiKey: string, groupKey: string, taskKey: string, options?: any): AxiosPromise<AuthTokenCreate200ResponseAllOf> {
            return localVarFp.taskmanApiV1GroupUpdate(jiraApiKey, groupKey, taskKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of tasks from a user
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskmanApiV1TaskAssigneeRetrieve(jiraApiKey: string, user: string, options?: any): AxiosPromise<TaskmanApiV1GroupRetrieve200Response> {
            return localVarFp.taskmanApiV1TaskAssigneeRetrieve(jiraApiKey, user, options).then((request) => request(axios, basePath));
        },
        /**
         * Assign a task to a user
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {string} taskKey 
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskmanApiV1TaskAssigneeUpdate(jiraApiKey: string, taskKey: string, user: string, options?: any): AxiosPromise<AuthTokenCreate200ResponseAllOf> {
            return localVarFp.taskmanApiV1TaskAssigneeUpdate(jiraApiKey, taskKey, user, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new comment in a task
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {string} content 
         * @param {string} taskKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskmanApiV1TaskCommentCreate(jiraApiKey: string, content: string, taskKey: string, options?: any): AxiosPromise<TaskmanApiV1TaskCommentCreate200Response> {
            return localVarFp.taskmanApiV1TaskCommentCreate(jiraApiKey, content, taskKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit a comment in a task
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {string} commentId 
         * @param {string} content 
         * @param {string} taskKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskmanApiV1TaskCommentUpdate(jiraApiKey: string, commentId: string, content: string, taskKey: string, options?: any): AxiosPromise<TaskmanApiV1TaskCommentCreate200Response> {
            return localVarFp.taskmanApiV1TaskCommentUpdate(jiraApiKey, commentId, content, taskKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a task in Jira from a Flaw
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {string} flawUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskmanApiV1TaskFlawCreate(jiraApiKey: string, flawUuid: string, options?: any): AxiosPromise<AuthTokenCreate200ResponseAllOf> {
            return localVarFp.taskmanApiV1TaskFlawCreate(jiraApiKey, flawUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a task from Jira given a Flaw uuid
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {string} flawUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskmanApiV1TaskFlawRetrieve(jiraApiKey: string, flawUuid: string, options?: any): AxiosPromise<TaskmanApiV1GroupCreate200Response> {
            return localVarFp.taskmanApiV1TaskFlawRetrieve(jiraApiKey, flawUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a task in Jira from a Flaw
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {string} flawUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskmanApiV1TaskFlawUpdate(jiraApiKey: string, flawUuid: string, options?: any): AxiosPromise<AuthTokenCreate200ResponseAllOf> {
            return localVarFp.taskmanApiV1TaskFlawUpdate(jiraApiKey, flawUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a task from Jira given a task key
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {string} taskKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskmanApiV1TaskRetrieve(jiraApiKey: string, taskKey: string, options?: any): AxiosPromise<TaskmanApiV1GroupCreate200Response> {
            return localVarFp.taskmanApiV1TaskRetrieve(jiraApiKey, taskKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Change a task workflow status
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {'Closed' | 'In Progress' | 'New' | 'Refinement'} status 
         * @param {string} taskKey 
         * @param {'Closed' | 'In Progress' | 'New' | 'Refinement'} [reason] Reason of status change. Mandatory for rejecting a task.
         * @param {'Can\'t Do' | 'Cannot Reproduce' | 'Done' | 'Done-Errata' | 'Duplicate' | 'MirrorOrphan' | 'Not a Bug' | 'Obsolete' | 'Test Pending' | 'Won\'t Do'} [resolution] Resolution of a CLOSED task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskmanApiV1TaskStatusUpdate(jiraApiKey: string, status: 'Closed' | 'In Progress' | 'New' | 'Refinement', taskKey: string, reason?: 'Closed' | 'In Progress' | 'New' | 'Refinement', resolution?: 'Can\'t Do' | 'Cannot Reproduce' | 'Done' | 'Done-Errata' | 'Duplicate' | 'MirrorOrphan' | 'Not a Bug' | 'Obsolete' | 'Test Pending' | 'Won\'t Do', options?: any): AxiosPromise<AuthTokenCreate200ResponseAllOf> {
            return localVarFp.taskmanApiV1TaskStatusUpdate(jiraApiKey, status, taskKey, reason, resolution, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of tasks without an user assigned
         * @param {string} jiraApiKey User generated token for Jira authentication.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskmanApiV1TaskUnassignedRetrieve(jiraApiKey: string, options?: any): AxiosPromise<TaskmanApiV1GroupRetrieve200Response> {
            return localVarFp.taskmanApiV1TaskUnassignedRetrieve(jiraApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * unauthenticated health check API endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskmanHealthyRetrieve(options?: any): AxiosPromise<AuthTokenCreate200ResponseAllOf> {
            return localVarFp.taskmanHealthyRetrieve(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TaskmanApi - object-oriented interface
 * @export
 * @class TaskmanApi
 * @extends {BaseAPI}
 */
export class TaskmanApi extends BaseAPI {
    /**
     * Create a new group of tasks
     * @param {string} jiraApiKey User generated token for Jira authentication.
     * @param {string} name 
     * @param {string} [description] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskmanApi
     */
    public taskmanApiV1GroupCreate(jiraApiKey: string, name: string, description?: string, options?: AxiosRequestConfig) {
        return TaskmanApiFp(this.configuration).taskmanApiV1GroupCreate(jiraApiKey, name, description, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of tasks from a group
     * @param {string} jiraApiKey User generated token for Jira authentication.
     * @param {string} groupKey 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskmanApi
     */
    public taskmanApiV1GroupRetrieve(jiraApiKey: string, groupKey: string, options?: AxiosRequestConfig) {
        return TaskmanApiFp(this.configuration).taskmanApiV1GroupRetrieve(jiraApiKey, groupKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a task into a group
     * @param {string} jiraApiKey User generated token for Jira authentication.
     * @param {string} groupKey 
     * @param {string} taskKey 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskmanApi
     */
    public taskmanApiV1GroupUpdate(jiraApiKey: string, groupKey: string, taskKey: string, options?: AxiosRequestConfig) {
        return TaskmanApiFp(this.configuration).taskmanApiV1GroupUpdate(jiraApiKey, groupKey, taskKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of tasks from a user
     * @param {string} jiraApiKey User generated token for Jira authentication.
     * @param {string} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskmanApi
     */
    public taskmanApiV1TaskAssigneeRetrieve(jiraApiKey: string, user: string, options?: AxiosRequestConfig) {
        return TaskmanApiFp(this.configuration).taskmanApiV1TaskAssigneeRetrieve(jiraApiKey, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assign a task to a user
     * @param {string} jiraApiKey User generated token for Jira authentication.
     * @param {string} taskKey 
     * @param {string} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskmanApi
     */
    public taskmanApiV1TaskAssigneeUpdate(jiraApiKey: string, taskKey: string, user: string, options?: AxiosRequestConfig) {
        return TaskmanApiFp(this.configuration).taskmanApiV1TaskAssigneeUpdate(jiraApiKey, taskKey, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new comment in a task
     * @param {string} jiraApiKey User generated token for Jira authentication.
     * @param {string} content 
     * @param {string} taskKey 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskmanApi
     */
    public taskmanApiV1TaskCommentCreate(jiraApiKey: string, content: string, taskKey: string, options?: AxiosRequestConfig) {
        return TaskmanApiFp(this.configuration).taskmanApiV1TaskCommentCreate(jiraApiKey, content, taskKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit a comment in a task
     * @param {string} jiraApiKey User generated token for Jira authentication.
     * @param {string} commentId 
     * @param {string} content 
     * @param {string} taskKey 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskmanApi
     */
    public taskmanApiV1TaskCommentUpdate(jiraApiKey: string, commentId: string, content: string, taskKey: string, options?: AxiosRequestConfig) {
        return TaskmanApiFp(this.configuration).taskmanApiV1TaskCommentUpdate(jiraApiKey, commentId, content, taskKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a task in Jira from a Flaw
     * @param {string} jiraApiKey User generated token for Jira authentication.
     * @param {string} flawUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskmanApi
     */
    public taskmanApiV1TaskFlawCreate(jiraApiKey: string, flawUuid: string, options?: AxiosRequestConfig) {
        return TaskmanApiFp(this.configuration).taskmanApiV1TaskFlawCreate(jiraApiKey, flawUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a task from Jira given a Flaw uuid
     * @param {string} jiraApiKey User generated token for Jira authentication.
     * @param {string} flawUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskmanApi
     */
    public taskmanApiV1TaskFlawRetrieve(jiraApiKey: string, flawUuid: string, options?: AxiosRequestConfig) {
        return TaskmanApiFp(this.configuration).taskmanApiV1TaskFlawRetrieve(jiraApiKey, flawUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a task in Jira from a Flaw
     * @param {string} jiraApiKey User generated token for Jira authentication.
     * @param {string} flawUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskmanApi
     */
    public taskmanApiV1TaskFlawUpdate(jiraApiKey: string, flawUuid: string, options?: AxiosRequestConfig) {
        return TaskmanApiFp(this.configuration).taskmanApiV1TaskFlawUpdate(jiraApiKey, flawUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a task from Jira given a task key
     * @param {string} jiraApiKey User generated token for Jira authentication.
     * @param {string} taskKey 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskmanApi
     */
    public taskmanApiV1TaskRetrieve(jiraApiKey: string, taskKey: string, options?: AxiosRequestConfig) {
        return TaskmanApiFp(this.configuration).taskmanApiV1TaskRetrieve(jiraApiKey, taskKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change a task workflow status
     * @param {string} jiraApiKey User generated token for Jira authentication.
     * @param {'Closed' | 'In Progress' | 'New' | 'Refinement'} status 
     * @param {string} taskKey 
     * @param {'Closed' | 'In Progress' | 'New' | 'Refinement'} [reason] Reason of status change. Mandatory for rejecting a task.
     * @param {'Can\'t Do' | 'Cannot Reproduce' | 'Done' | 'Done-Errata' | 'Duplicate' | 'MirrorOrphan' | 'Not a Bug' | 'Obsolete' | 'Test Pending' | 'Won\'t Do'} [resolution] Resolution of a CLOSED task.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskmanApi
     */
    public taskmanApiV1TaskStatusUpdate(jiraApiKey: string, status: 'Closed' | 'In Progress' | 'New' | 'Refinement', taskKey: string, reason?: 'Closed' | 'In Progress' | 'New' | 'Refinement', resolution?: 'Can\'t Do' | 'Cannot Reproduce' | 'Done' | 'Done-Errata' | 'Duplicate' | 'MirrorOrphan' | 'Not a Bug' | 'Obsolete' | 'Test Pending' | 'Won\'t Do', options?: AxiosRequestConfig) {
        return TaskmanApiFp(this.configuration).taskmanApiV1TaskStatusUpdate(jiraApiKey, status, taskKey, reason, resolution, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of tasks without an user assigned
     * @param {string} jiraApiKey User generated token for Jira authentication.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskmanApi
     */
    public taskmanApiV1TaskUnassignedRetrieve(jiraApiKey: string, options?: AxiosRequestConfig) {
        return TaskmanApiFp(this.configuration).taskmanApiV1TaskUnassignedRetrieve(jiraApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * unauthenticated health check API endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskmanApi
     */
    public taskmanHealthyRetrieve(options?: AxiosRequestConfig) {
        return TaskmanApiFp(this.configuration).taskmanHealthyRetrieve(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TrackersApi - axios parameter creator
 * @export
 */
export const TrackersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Given a list of flaws, generates a list of suggested trackers to file.
         * @param {FlawUUIDList} flawUUIDList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackersApiV1FileCreate: async (flawUUIDList: FlawUUIDList, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flawUUIDList' is not null or undefined
            assertParamExists('trackersApiV1FileCreate', 'flawUUIDList', flawUUIDList)
            const localVarPath = `/trackers/api/v1/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flawUUIDList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrackersApi - functional programming interface
 * @export
 */
export const TrackersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TrackersApiAxiosParamCreator(configuration)
    return {
        /**
         * Given a list of flaws, generates a list of suggested trackers to file.
         * @param {FlawUUIDList} flawUUIDList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackersApiV1FileCreate(flawUUIDList: FlawUUIDList, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TrackerSuggestion>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackersApiV1FileCreate(flawUUIDList, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TrackersApi - factory interface
 * @export
 */
export const TrackersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TrackersApiFp(configuration)
    return {
        /**
         * Given a list of flaws, generates a list of suggested trackers to file.
         * @param {FlawUUIDList} flawUUIDList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackersApiV1FileCreate(flawUUIDList: FlawUUIDList, options?: any): AxiosPromise<Array<TrackerSuggestion>> {
            return localVarFp.trackersApiV1FileCreate(flawUUIDList, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TrackersApi - object-oriented interface
 * @export
 * @class TrackersApi
 * @extends {BaseAPI}
 */
export class TrackersApi extends BaseAPI {
    /**
     * Given a list of flaws, generates a list of suggested trackers to file.
     * @param {FlawUUIDList} flawUUIDList 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackersApi
     */
    public trackersApiV1FileCreate(flawUUIDList: FlawUUIDList, options?: AxiosRequestConfig) {
        return TrackersApiFp(this.configuration).trackersApiV1FileCreate(flawUUIDList, options).then((request) => request(this.axios, this.basePath));
    }
}


