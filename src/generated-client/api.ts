/* tslint:disable */
/* eslint-disable */
/**
 * OSIDB API
 * REST API autogenerated docs for the OSIDB and its components
 *
 * The version of the OpenAPI document: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * Affect serializer
 * @export
 * @interface Affect
 */
export interface Affect {
    /**
     * 
     * @type {string}
     * @memberof Affect
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof Affect
     */
    'flaw': string | null;
    /**
     * 
     * @type {AffectAffectedness}
     * @memberof Affect
     */
    'affectedness'?: AffectAffectedness;
    /**
     * 
     * @type {AffectResolution}
     * @memberof Affect
     */
    'resolution'?: AffectResolution;
    /**
     * 
     * @type {string}
     * @memberof Affect
     */
    'ps_module': string;
    /**
     * 
     * @type {string}
     * @memberof Affect
     */
    'ps_product': string;
    /**
     * 
     * @type {string}
     * @memberof Affect
     */
    'ps_component': string;
    /**
     * 
     * @type {AffectImpact}
     * @memberof Affect
     */
    'impact'?: AffectImpact;
    /**
     * 
     * @type {Array<Tracker>}
     * @memberof Affect
     */
    'trackers': Array<Tracker>;
    /**
     * 
     * @type {AffectMetaAttr}
     * @memberof Affect
     */
    'meta_attr': AffectMetaAttr;
    /**
     * 
     * @type {string}
     * @memberof Affect
     */
    'delegated_resolution': string;
    /**
     * 
     * @type {Array<AffectCVSS>}
     * @memberof Affect
     */
    'cvss_scores': Array<AffectCVSS>;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof Affect
     */
    'embargoed': boolean;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof Affect
     */
    'alerts': Array<Alert>;
    /**
     * 
     * @type {string}
     * @memberof Affect
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof Affect
     */
    'updated_dt': string;
}
/**
 * @type AffectAffectedness
 * @export
 */
export type AffectAffectedness = AffectednessEnum | BlankEnum;

/**
 * 
 * @export
 * @interface AffectBulkPostPutResponse
 */
export interface AffectBulkPostPutResponse {
    /**
     * 
     * @type {Array<Affect>}
     * @memberof AffectBulkPostPutResponse
     */
    'results': Array<Affect>;
}
/**
 * Affect serializer
 * @export
 * @interface AffectBulkPut
 */
export interface AffectBulkPut {
    /**
     * 
     * @type {string}
     * @memberof AffectBulkPut
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof AffectBulkPut
     */
    'flaw': string | null;
    /**
     * 
     * @type {AffectAffectedness}
     * @memberof AffectBulkPut
     */
    'affectedness'?: AffectAffectedness;
    /**
     * 
     * @type {AffectResolution}
     * @memberof AffectBulkPut
     */
    'resolution'?: AffectResolution;
    /**
     * 
     * @type {string}
     * @memberof AffectBulkPut
     */
    'ps_module': string;
    /**
     * 
     * @type {string}
     * @memberof AffectBulkPut
     */
    'ps_product': string;
    /**
     * 
     * @type {string}
     * @memberof AffectBulkPut
     */
    'ps_component': string;
    /**
     * 
     * @type {AffectImpact}
     * @memberof AffectBulkPut
     */
    'impact'?: AffectImpact;
    /**
     * 
     * @type {Array<Tracker>}
     * @memberof AffectBulkPut
     */
    'trackers': Array<Tracker>;
    /**
     * 
     * @type {AffectMetaAttr}
     * @memberof AffectBulkPut
     */
    'meta_attr': AffectMetaAttr;
    /**
     * 
     * @type {string}
     * @memberof AffectBulkPut
     */
    'delegated_resolution': string;
    /**
     * 
     * @type {Array<AffectCVSS>}
     * @memberof AffectBulkPut
     */
    'cvss_scores': Array<AffectCVSS>;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof AffectBulkPut
     */
    'embargoed': boolean;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof AffectBulkPut
     */
    'alerts': Array<Alert>;
    /**
     * 
     * @type {string}
     * @memberof AffectBulkPut
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof AffectBulkPut
     */
    'updated_dt': string;
}
/**
 * AffectCVSS serializer
 * @export
 * @interface AffectCVSS
 */
export interface AffectCVSS {
    /**
     * 
     * @type {string}
     * @memberof AffectCVSS
     */
    'affect'?: string;
    /**
     * 
     * @type {string}
     * @memberof AffectCVSS
     */
    'comment'?: string | null;
    /**
     * 
     * @type {CvssVersionEnum}
     * @memberof AffectCVSS
     */
    'cvss_version': CvssVersionEnum;
    /**
     * 
     * @type {IssuerEnum}
     * @memberof AffectCVSS
     */
    'issuer': IssuerEnum;
    /**
     * 
     * @type {number}
     * @memberof AffectCVSS
     */
    'score': number;
    /**
     * 
     * @type {string}
     * @memberof AffectCVSS
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof AffectCVSS
     */
    'vector': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof AffectCVSS
     */
    'embargoed': boolean;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof AffectCVSS
     */
    'alerts': Array<Alert>;
    /**
     * 
     * @type {string}
     * @memberof AffectCVSS
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof AffectCVSS
     */
    'updated_dt': string;
}


/**
 * AffectCVSS serializer
 * @export
 * @interface AffectCVSSPost
 */
export interface AffectCVSSPost {
    /**
     * 
     * @type {string}
     * @memberof AffectCVSSPost
     */
    'comment'?: string | null;
    /**
     * 
     * @type {CvssVersionEnum}
     * @memberof AffectCVSSPost
     */
    'cvss_version': CvssVersionEnum;
    /**
     * 
     * @type {IssuerEnum}
     * @memberof AffectCVSSPost
     */
    'issuer': IssuerEnum;
    /**
     * 
     * @type {number}
     * @memberof AffectCVSSPost
     */
    'score': number;
    /**
     * 
     * @type {string}
     * @memberof AffectCVSSPost
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof AffectCVSSPost
     */
    'vector': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof AffectCVSSPost
     */
    'embargoed': boolean;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof AffectCVSSPost
     */
    'alerts': Array<Alert>;
    /**
     * 
     * @type {string}
     * @memberof AffectCVSSPost
     */
    'created_dt': string;
}


/**
 * AffectCVSS serializer
 * @export
 * @interface AffectCVSSPut
 */
export interface AffectCVSSPut {
    /**
     * 
     * @type {string}
     * @memberof AffectCVSSPut
     */
    'comment'?: string | null;
    /**
     * 
     * @type {CvssVersionEnum}
     * @memberof AffectCVSSPut
     */
    'cvss_version': CvssVersionEnum;
    /**
     * 
     * @type {IssuerEnum}
     * @memberof AffectCVSSPut
     */
    'issuer': IssuerEnum;
    /**
     * 
     * @type {number}
     * @memberof AffectCVSSPut
     */
    'score': number;
    /**
     * 
     * @type {string}
     * @memberof AffectCVSSPut
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof AffectCVSSPut
     */
    'vector': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof AffectCVSSPut
     */
    'embargoed': boolean;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof AffectCVSSPut
     */
    'alerts': Array<Alert>;
    /**
     * 
     * @type {string}
     * @memberof AffectCVSSPut
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof AffectCVSSPut
     */
    'updated_dt': string;
}


/**
 * @type AffectImpact
 * @export
 */
export type AffectImpact = BlankEnum | ImpactEnum;

/**
 * 
 * @export
 * @interface AffectMetaAttr
 */
export interface AffectMetaAttr {
    /**
     * 
     * @type {string}
     * @memberof AffectMetaAttr
     */
    'affectedness'?: string;
    /**
     * 
     * @type {string}
     * @memberof AffectMetaAttr
     */
    'component'?: string;
    /**
     * 
     * @type {string}
     * @memberof AffectMetaAttr
     */
    'impact'?: string;
    /**
     * 
     * @type {string}
     * @memberof AffectMetaAttr
     */
    'module_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AffectMetaAttr
     */
    'module_stream'?: string;
    /**
     * 
     * @type {string}
     * @memberof AffectMetaAttr
     */
    'ps_component'?: string;
    /**
     * 
     * @type {string}
     * @memberof AffectMetaAttr
     */
    'ps_module'?: string;
    /**
     * 
     * @type {string}
     * @memberof AffectMetaAttr
     */
    'ps_product'?: string;
    /**
     * 
     * @type {string}
     * @memberof AffectMetaAttr
     */
    'resolution'?: string;
}
/**
 * Affect serializer
 * @export
 * @interface AffectPost
 */
export interface AffectPost {
    /**
     * 
     * @type {string}
     * @memberof AffectPost
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof AffectPost
     */
    'flaw': string | null;
    /**
     * 
     * @type {AffectAffectedness}
     * @memberof AffectPost
     */
    'affectedness'?: AffectAffectedness;
    /**
     * 
     * @type {AffectResolution}
     * @memberof AffectPost
     */
    'resolution'?: AffectResolution;
    /**
     * 
     * @type {string}
     * @memberof AffectPost
     */
    'ps_module': string;
    /**
     * 
     * @type {string}
     * @memberof AffectPost
     */
    'ps_product': string;
    /**
     * 
     * @type {string}
     * @memberof AffectPost
     */
    'ps_component': string;
    /**
     * 
     * @type {AffectImpact}
     * @memberof AffectPost
     */
    'impact'?: AffectImpact;
    /**
     * 
     * @type {Array<Tracker>}
     * @memberof AffectPost
     */
    'trackers': Array<Tracker>;
    /**
     * 
     * @type {AffectMetaAttr}
     * @memberof AffectPost
     */
    'meta_attr': AffectMetaAttr;
    /**
     * 
     * @type {string}
     * @memberof AffectPost
     */
    'delegated_resolution': string;
    /**
     * 
     * @type {Array<AffectCVSS>}
     * @memberof AffectPost
     */
    'cvss_scores': Array<AffectCVSS>;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof AffectPost
     */
    'embargoed': boolean;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof AffectPost
     */
    'alerts': Array<Alert>;
    /**
     * 
     * @type {string}
     * @memberof AffectPost
     */
    'created_dt': string;
}
/**
 * 
 * @export
 * @interface AffectReportData
 */
export interface AffectReportData {
    /**
     * 
     * @type {string}
     * @memberof AffectReportData
     */
    'ps_module': string;
    /**
     * 
     * @type {string}
     * @memberof AffectReportData
     */
    'ps_component': string;
    /**
     * 
     * @type {AffectAffectedness}
     * @memberof AffectReportData
     */
    'affectedness'?: AffectAffectedness;
    /**
     * 
     * @type {AffectResolution}
     * @memberof AffectReportData
     */
    'resolution'?: AffectResolution;
    /**
     * 
     * @type {Array<TrackerReportData>}
     * @memberof AffectReportData
     */
    'trackers'?: Array<TrackerReportData>;
}
/**
 * @type AffectResolution
 * @export
 */
export type AffectResolution = BlankEnum | ResolutionEnum;

/**
 * 
 * @export
 * @enum {string}
 */

export const AffectednessEnum = {
    New: 'NEW',
    Affected: 'AFFECTED',
    Notaffected: 'NOTAFFECTED'
} as const;

export type AffectednessEnum = typeof AffectednessEnum[keyof typeof AffectednessEnum];


/**
 * Alerts indicate some inconsistency in a linked flaw, affect, tracker or other models.
 * @export
 * @interface Alert
 */
export interface Alert {
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    'description': string;
    /**
     * 
     * @type {AlertTypeEnum}
     * @memberof Alert
     */
    'alert_type'?: AlertTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    'resolution_steps'?: string;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    'parent_uuid': string;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    'parent_model': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const AlertTypeEnum = {
    Warning: 'WARNING',
    Error: 'ERROR'
} as const;

export type AlertTypeEnum = typeof AlertTypeEnum[keyof typeof AlertTypeEnum];


/**
 * 
 * @export
 * @interface Audit
 */
export interface Audit {
    /**
     * When the event was created.
     * @type {string}
     * @memberof Audit
     */
    'pgh_created_at': string;
    /**
     * The unique identifier across all event tables.
     * @type {string}
     * @memberof Audit
     */
    'pgh_slug': string;
    /**
     * The object model.
     * @type {string}
     * @memberof Audit
     */
    'pgh_obj_model': string;
    /**
     * The primary key of the object.
     * @type {string}
     * @memberof Audit
     */
    'pgh_obj_id'?: string | null;
    /**
     * The event label.
     * @type {string}
     * @memberof Audit
     */
    'pgh_label': string;
    /**
     * The context associated with the event.
     * @type {{ [key: string]: any; }}
     * @memberof Audit
     */
    'pgh_context'?: { [key: string]: any; } | null;
    /**
     * The diff between the previous event of the same label.
     * @type {{ [key: string]: any; }}
     * @memberof Audit
     */
    'pgh_diff': { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof Audit
     */
    'pgh_data': string;
}
/**
 * 
 * @export
 * @interface AuthTokenCreate200Response
 */
export interface AuthTokenCreate200Response {
    /**
     * 
     * @type {string}
     * @memberof AuthTokenCreate200Response
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenCreate200Response
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenCreate200Response
     */
    'access': string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenCreate200Response
     */
    'refresh': string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenCreate200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenCreate200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenCreate200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenCreate200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface AuthTokenCreate200ResponseAllOf
 */
export interface AuthTokenCreate200ResponseAllOf {
    /**
     * 
     * @type {string}
     * @memberof AuthTokenCreate200ResponseAllOf
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenCreate200ResponseAllOf
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenCreate200ResponseAllOf
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenCreate200ResponseAllOf
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface AuthTokenRefreshCreate200Response
 */
export interface AuthTokenRefreshCreate200Response {
    /**
     * 
     * @type {string}
     * @memberof AuthTokenRefreshCreate200Response
     */
    'access': string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenRefreshCreate200Response
     */
    'refresh': string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenRefreshCreate200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenRefreshCreate200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenRefreshCreate200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenRefreshCreate200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface AuthTokenRetrieve200Response
 */
export interface AuthTokenRetrieve200Response {
    /**
     * 
     * @type {string}
     * @memberof AuthTokenRetrieve200Response
     */
    'access'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenRetrieve200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenRetrieve200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenRetrieve200Response
     */
    'refresh'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenRetrieve200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenRetrieve200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface AuthTokenVerifyCreate200Response
 */
export interface AuthTokenVerifyCreate200Response {
    /**
     * 
     * @type {string}
     * @memberof AuthTokenVerifyCreate200Response
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenVerifyCreate200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenVerifyCreate200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenVerifyCreate200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenVerifyCreate200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const BlankEnum = {
    Empty: ''
} as const;

export type BlankEnum = typeof BlankEnum[keyof typeof BlankEnum];


/**
 * 
 * @export
 * @interface CollectorsApiV1StatusRetrieve200Response
 */
export interface CollectorsApiV1StatusRetrieve200Response {
    /**
     * 
     * @type {Array<CollectorsApiV1StatusRetrieve200ResponseCollectorsInner>}
     * @memberof CollectorsApiV1StatusRetrieve200Response
     */
    'collectors'?: Array<CollectorsApiV1StatusRetrieve200ResponseCollectorsInner>;
    /**
     * 
     * @type {string}
     * @memberof CollectorsApiV1StatusRetrieve200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof CollectorsApiV1StatusRetrieve200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof CollectorsApiV1StatusRetrieve200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof CollectorsApiV1StatusRetrieve200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface CollectorsApiV1StatusRetrieve200ResponseCollectorsInner
 */
export interface CollectorsApiV1StatusRetrieve200ResponseCollectorsInner {
    /**
     * 
     * @type {string}
     * @memberof CollectorsApiV1StatusRetrieve200ResponseCollectorsInner
     */
    'data'?: CollectorsApiV1StatusRetrieve200ResponseCollectorsInnerDataEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof CollectorsApiV1StatusRetrieve200ResponseCollectorsInner
     */
    'depends_on'?: Array<string>;
    /**
     * 
     * @type {object}
     * @memberof CollectorsApiV1StatusRetrieve200ResponseCollectorsInner
     */
    'error'?: object | null;
    /**
     * 
     * @type {boolean}
     * @memberof CollectorsApiV1StatusRetrieve200ResponseCollectorsInner
     */
    'is_complete'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CollectorsApiV1StatusRetrieve200ResponseCollectorsInner
     */
    'is_up2date'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof CollectorsApiV1StatusRetrieve200ResponseCollectorsInner
     */
    'data_models'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CollectorsApiV1StatusRetrieve200ResponseCollectorsInner
     */
    'state'?: CollectorsApiV1StatusRetrieve200ResponseCollectorsInnerStateEnum;
    /**
     * 
     * @type {string}
     * @memberof CollectorsApiV1StatusRetrieve200ResponseCollectorsInner
     */
    'updated_until'?: string;
}

export const CollectorsApiV1StatusRetrieve200ResponseCollectorsInnerDataEnum = {
    Empty: 'EMPTY',
    Partial: 'PARTIAL',
    Complete: 'COMPLETE'
} as const;

export type CollectorsApiV1StatusRetrieve200ResponseCollectorsInnerDataEnum = typeof CollectorsApiV1StatusRetrieve200ResponseCollectorsInnerDataEnum[keyof typeof CollectorsApiV1StatusRetrieve200ResponseCollectorsInnerDataEnum];
export const CollectorsApiV1StatusRetrieve200ResponseCollectorsInnerStateEnum = {
    Pending: 'PENDING',
    Blocked: 'BLOCKED',
    Ready: 'READY',
    Running: 'RUNNING'
} as const;

export type CollectorsApiV1StatusRetrieve200ResponseCollectorsInnerStateEnum = typeof CollectorsApiV1StatusRetrieve200ResponseCollectorsInnerStateEnum[keyof typeof CollectorsApiV1StatusRetrieve200ResponseCollectorsInnerStateEnum];

/**
 * 
 * @export
 * @interface CollectorsRetrieve200Response
 */
export interface CollectorsRetrieve200Response {
    /**
     * 
     * @type {string}
     * @memberof CollectorsRetrieve200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof CollectorsRetrieve200Response
     */
    'env'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CollectorsRetrieve200Response
     */
    'index'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CollectorsRetrieve200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof CollectorsRetrieve200Response
     */
    'version'?: string;
}
/**
 * FlawComment serializer for use by FlawSerializer
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'external_system_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof Comment
     */
    'order'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'creator'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Comment
     */
    'is_private'?: boolean;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof Comment
     */
    'alerts': Array<Alert>;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof Comment
     */
    'updated_dt': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CvssVersionEnum = {
    V2: 'V2',
    V3: 'V3',
    V4: 'V4'
} as const;

export type CvssVersionEnum = typeof CvssVersionEnum[keyof typeof CvssVersionEnum];


/**
 * 
 * @export
 * @interface EPSS
 */
export interface EPSS {
    /**
     * 
     * @type {string}
     * @memberof EPSS
     */
    'cve': string;
    /**
     * 
     * @type {number}
     * @memberof EPSS
     */
    'epss': number;
}
/**
 * Erratum serializer
 * @export
 * @interface Erratum
 */
export interface Erratum {
    /**
     * 
     * @type {number}
     * @memberof Erratum
     */
    'et_id': number;
    /**
     * 
     * @type {string}
     * @memberof Erratum
     */
    'advisory_name': string;
    /**
     * 
     * @type {string}
     * @memberof Erratum
     */
    'shipped_dt': string | null;
    /**
     * 
     * @type {string}
     * @memberof Erratum
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof Erratum
     */
    'updated_dt': string;
}
/**
 * 
 * @export
 * @interface ExploitOnlyReportData
 */
export interface ExploitOnlyReportData {
    /**
     * 
     * @type {string}
     * @memberof ExploitOnlyReportData
     */
    'cve': string;
    /**
     * 
     * @type {string}
     * @memberof ExploitOnlyReportData
     */
    'date'?: string | null;
    /**
     * 
     * @type {ExploitOnlyReportDataSourceEnum}
     * @memberof ExploitOnlyReportData
     */
    'source': ExploitOnlyReportDataSourceEnum;
    /**
     * 
     * @type {string}
     * @memberof ExploitOnlyReportData
     */
    'reference'?: string;
    /**
     * 
     * @type {MaturityPreliminaryEnum}
     * @memberof ExploitOnlyReportData
     */
    'maturity_preliminary': MaturityPreliminaryEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ExploitOnlyReportData
     */
    'flaw': boolean;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ExploitOnlyReportDataSourceEnum = {
    Cisa: 'CISA',
    Metasploit: 'Metasploit',
    ExploitDb: 'Exploit-DB'
} as const;

export type ExploitOnlyReportDataSourceEnum = typeof ExploitOnlyReportDataSourceEnum[keyof typeof ExploitOnlyReportDataSourceEnum];


/**
 * 
 * @export
 * @interface ExploitsApiV1CollectUpdate200Response
 */
export interface ExploitsApiV1CollectUpdate200Response {
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1CollectUpdate200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1CollectUpdate200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1CollectUpdate200Response
     */
    'result_cisa'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1CollectUpdate200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1CollectUpdate200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface ExploitsApiV1CveMapRetrieve200Response
 */
export interface ExploitsApiV1CveMapRetrieve200Response {
    /**
     * 
     * @type {object}
     * @memberof ExploitsApiV1CveMapRetrieve200Response
     */
    'cves'?: object;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1CveMapRetrieve200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1CveMapRetrieve200Response
     */
    'env'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExploitsApiV1CveMapRetrieve200Response
     */
    'page_size'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1CveMapRetrieve200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1CveMapRetrieve200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface ExploitsApiV1EpssList200Response
 */
export interface ExploitsApiV1EpssList200Response {
    /**
     * 
     * @type {number}
     * @memberof ExploitsApiV1EpssList200Response
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1EpssList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1EpssList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<EPSS>}
     * @memberof ExploitsApiV1EpssList200Response
     */
    'results'?: Array<EPSS>;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1EpssList200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1EpssList200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1EpssList200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1EpssList200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface ExploitsApiV1FlawDataList200Response
 */
export interface ExploitsApiV1FlawDataList200Response {
    /**
     * 
     * @type {number}
     * @memberof ExploitsApiV1FlawDataList200Response
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1FlawDataList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1FlawDataList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<FlawReportData>}
     * @memberof ExploitsApiV1FlawDataList200Response
     */
    'results'?: Array<FlawReportData>;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1FlawDataList200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1FlawDataList200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1FlawDataList200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1FlawDataList200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface ExploitsApiV1ReportDataList200Response
 */
export interface ExploitsApiV1ReportDataList200Response {
    /**
     * 
     * @type {number}
     * @memberof ExploitsApiV1ReportDataList200Response
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportDataList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportDataList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<ExploitOnlyReportData>}
     * @memberof ExploitsApiV1ReportDataList200Response
     */
    'results'?: Array<ExploitOnlyReportData>;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportDataList200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportDataList200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportDataList200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportDataList200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface ExploitsApiV1ReportDateRetrieve200Response
 */
export interface ExploitsApiV1ReportDateRetrieve200Response {
    /**
     * 
     * @type {Array<object>}
     * @memberof ExploitsApiV1ReportDateRetrieve200Response
     */
    'action_required'?: Array<object>;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportDateRetrieve200Response
     */
    'cutoff_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportDateRetrieve200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportDateRetrieve200Response
     */
    'env'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExploitsApiV1ReportDateRetrieve200Response
     */
    'evaluated_cves'?: number;
    /**
     * 
     * @type {Array<object>}
     * @memberof ExploitsApiV1ReportDateRetrieve200Response
     */
    'no_action'?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof ExploitsApiV1ReportDateRetrieve200Response
     */
    'not_relevant'?: Array<object>;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportDateRetrieve200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportDateRetrieve200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface ExploitsApiV1ReportExplanationsRetrieve200Response
 */
export interface ExploitsApiV1ReportExplanationsRetrieve200Response {
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportExplanationsRetrieve200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportExplanationsRetrieve200Response
     */
    'env'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof ExploitsApiV1ReportExplanationsRetrieve200Response
     */
    'explanations'?: Array<object>;
    /**
     * 
     * @type {number}
     * @memberof ExploitsApiV1ReportExplanationsRetrieve200Response
     */
    'page_size'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportExplanationsRetrieve200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportExplanationsRetrieve200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface ExploitsApiV1ReportPendingRetrieve200Response
 */
export interface ExploitsApiV1ReportPendingRetrieve200Response {
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportPendingRetrieve200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportPendingRetrieve200Response
     */
    'env'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof ExploitsApiV1ReportPendingRetrieve200Response
     */
    'pending_actions'?: Array<object>;
    /**
     * 
     * @type {number}
     * @memberof ExploitsApiV1ReportPendingRetrieve200Response
     */
    'pending_actions_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportPendingRetrieve200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1ReportPendingRetrieve200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface ExploitsApiV1StatusRetrieve200Response
 */
export interface ExploitsApiV1StatusRetrieve200Response {
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1StatusRetrieve200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1StatusRetrieve200Response
     */
    'env'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExploitsApiV1StatusRetrieve200Response
     */
    'exploits_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExploitsApiV1StatusRetrieve200Response
     */
    'exploits_count_relevant'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExploitsApiV1StatusRetrieve200Response
     */
    'last_exploit'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1StatusRetrieve200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1StatusRetrieve200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface ExploitsApiV1SupportedProductsList200Response
 */
export interface ExploitsApiV1SupportedProductsList200Response {
    /**
     * 
     * @type {number}
     * @memberof ExploitsApiV1SupportedProductsList200Response
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1SupportedProductsList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1SupportedProductsList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<SupportedProducts>}
     * @memberof ExploitsApiV1SupportedProductsList200Response
     */
    'results'?: Array<SupportedProducts>;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1SupportedProductsList200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1SupportedProductsList200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1SupportedProductsList200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitsApiV1SupportedProductsList200Response
     */
    'version'?: string;
}
/**
 * serialize flaw model
 * @export
 * @interface Flaw
 */
export interface Flaw {
    /**
     * 
     * @type {string}
     * @memberof Flaw
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof Flaw
     */
    'cve_id'?: string | null;
    /**
     * 
     * @type {AffectImpact}
     * @memberof Flaw
     */
    'impact'?: AffectImpact;
    /**
     * 
     * @type {Array<string>}
     * @memberof Flaw
     */
    'components'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Flaw
     */
    'title': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Flaw
     */
    'trackers': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Flaw
     */
    'comment_zero': string;
    /**
     * 
     * @type {string}
     * @memberof Flaw
     */
    'cve_description'?: string;
    /**
     * 
     * @type {FlawRequiresCveDescription}
     * @memberof Flaw
     */
    'requires_cve_description'?: FlawRequiresCveDescription;
    /**
     * 
     * @type {string}
     * @memberof Flaw
     */
    'statement'?: string;
    /**
     * 
     * @type {string}
     * @memberof Flaw
     */
    'cwe_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Flaw
     */
    'unembargo_dt'?: string | null;
    /**
     * 
     * @type {FlawSource}
     * @memberof Flaw
     */
    'source'?: FlawSource;
    /**
     * 
     * @type {string}
     * @memberof Flaw
     */
    'reported_dt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Flaw
     */
    'mitigation'?: string;
    /**
     * 
     * @type {FlawMajorIncidentState}
     * @memberof Flaw
     */
    'major_incident_state'?: FlawMajorIncidentState;
    /**
     * 
     * @type {string}
     * @memberof Flaw
     */
    'major_incident_start_dt'?: string | null;
    /**
     * 
     * @type {FlawNistCvssValidation}
     * @memberof Flaw
     */
    'nist_cvss_validation'?: FlawNistCvssValidation;
    /**
     * 
     * @type {Array<Affect>}
     * @memberof Flaw
     */
    'affects': Array<Affect>;
    /**
     * 
     * @type {Array<Comment>}
     * @memberof Flaw
     */
    'comments': Array<Comment>;
    /**
     * 
     * @type {FlawMetaAttr}
     * @memberof Flaw
     */
    'meta_attr': FlawMetaAttr;
    /**
     * 
     * @type {Array<Package>}
     * @memberof Flaw
     */
    'package_versions': Array<Package>;
    /**
     * 
     * @type {Array<FlawAcknowledgment>}
     * @memberof Flaw
     */
    'acknowledgments': Array<FlawAcknowledgment>;
    /**
     * 
     * @type {Array<FlawReference>}
     * @memberof Flaw
     */
    'references': Array<FlawReference>;
    /**
     * 
     * @type {Array<FlawCVSS>}
     * @memberof Flaw
     */
    'cvss_scores': Array<FlawCVSS>;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof Flaw
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof Flaw
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof Flaw
     */
    'updated_dt': string;
    /**
     * 
     * @type {FlawClassification}
     * @memberof Flaw
     */
    'classification': FlawClassification;
    /**
     * 
     * @type {string}
     * @memberof Flaw
     */
    'group_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof Flaw
     */
    'owner'?: string;
    /**
     * 
     * @type {string}
     * @memberof Flaw
     */
    'task_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof Flaw
     */
    'team_id'?: string;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof Flaw
     */
    'alerts': Array<Alert>;
}
/**
 * FlawAcknowledgment serializer
 * @export
 * @interface FlawAcknowledgment
 */
export interface FlawAcknowledgment {
    /**
     * 
     * @type {string}
     * @memberof FlawAcknowledgment
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof FlawAcknowledgment
     */
    'affiliation': string;
    /**
     * 
     * @type {boolean}
     * @memberof FlawAcknowledgment
     */
    'from_upstream': boolean;
    /**
     * 
     * @type {string}
     * @memberof FlawAcknowledgment
     */
    'flaw': string;
    /**
     * 
     * @type {string}
     * @memberof FlawAcknowledgment
     */
    'uuid': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof FlawAcknowledgment
     */
    'embargoed': boolean;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof FlawAcknowledgment
     */
    'alerts': Array<Alert>;
    /**
     * 
     * @type {string}
     * @memberof FlawAcknowledgment
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof FlawAcknowledgment
     */
    'updated_dt': string;
}
/**
 * FlawAcknowledgment serializer
 * @export
 * @interface FlawAcknowledgmentPost
 */
export interface FlawAcknowledgmentPost {
    /**
     * 
     * @type {string}
     * @memberof FlawAcknowledgmentPost
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof FlawAcknowledgmentPost
     */
    'affiliation': string;
    /**
     * 
     * @type {boolean}
     * @memberof FlawAcknowledgmentPost
     */
    'from_upstream': boolean;
    /**
     * 
     * @type {string}
     * @memberof FlawAcknowledgmentPost
     */
    'uuid': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof FlawAcknowledgmentPost
     */
    'embargoed': boolean;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof FlawAcknowledgmentPost
     */
    'alerts': Array<Alert>;
    /**
     * 
     * @type {string}
     * @memberof FlawAcknowledgmentPost
     */
    'created_dt': string;
}
/**
 * FlawAcknowledgment serializer
 * @export
 * @interface FlawAcknowledgmentPut
 */
export interface FlawAcknowledgmentPut {
    /**
     * 
     * @type {string}
     * @memberof FlawAcknowledgmentPut
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof FlawAcknowledgmentPut
     */
    'affiliation': string;
    /**
     * 
     * @type {boolean}
     * @memberof FlawAcknowledgmentPut
     */
    'from_upstream': boolean;
    /**
     * 
     * @type {string}
     * @memberof FlawAcknowledgmentPut
     */
    'uuid': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof FlawAcknowledgmentPut
     */
    'embargoed': boolean;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof FlawAcknowledgmentPut
     */
    'alerts': Array<Alert>;
    /**
     * 
     * @type {string}
     * @memberof FlawAcknowledgmentPut
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof FlawAcknowledgmentPut
     */
    'updated_dt': string;
}
/**
 * FlawCVSS serializer
 * @export
 * @interface FlawCVSS
 */
export interface FlawCVSS {
    /**
     * 
     * @type {string}
     * @memberof FlawCVSS
     */
    'flaw'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawCVSS
     */
    'comment'?: string | null;
    /**
     * 
     * @type {CvssVersionEnum}
     * @memberof FlawCVSS
     */
    'cvss_version': CvssVersionEnum;
    /**
     * 
     * @type {IssuerEnum}
     * @memberof FlawCVSS
     */
    'issuer': IssuerEnum;
    /**
     * 
     * @type {number}
     * @memberof FlawCVSS
     */
    'score': number;
    /**
     * 
     * @type {string}
     * @memberof FlawCVSS
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof FlawCVSS
     */
    'vector': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof FlawCVSS
     */
    'embargoed': boolean;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof FlawCVSS
     */
    'alerts': Array<Alert>;
    /**
     * 
     * @type {string}
     * @memberof FlawCVSS
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof FlawCVSS
     */
    'updated_dt': string;
}


/**
 * FlawCVSS serializer
 * @export
 * @interface FlawCVSSPost
 */
export interface FlawCVSSPost {
    /**
     * 
     * @type {string}
     * @memberof FlawCVSSPost
     */
    'comment'?: string | null;
    /**
     * 
     * @type {CvssVersionEnum}
     * @memberof FlawCVSSPost
     */
    'cvss_version': CvssVersionEnum;
    /**
     * 
     * @type {IssuerEnum}
     * @memberof FlawCVSSPost
     */
    'issuer': IssuerEnum;
    /**
     * 
     * @type {number}
     * @memberof FlawCVSSPost
     */
    'score': number;
    /**
     * 
     * @type {string}
     * @memberof FlawCVSSPost
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof FlawCVSSPost
     */
    'vector': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof FlawCVSSPost
     */
    'embargoed': boolean;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof FlawCVSSPost
     */
    'alerts': Array<Alert>;
    /**
     * 
     * @type {string}
     * @memberof FlawCVSSPost
     */
    'created_dt': string;
}


/**
 * FlawCVSS serializer
 * @export
 * @interface FlawCVSSPut
 */
export interface FlawCVSSPut {
    /**
     * 
     * @type {string}
     * @memberof FlawCVSSPut
     */
    'comment'?: string | null;
    /**
     * 
     * @type {CvssVersionEnum}
     * @memberof FlawCVSSPut
     */
    'cvss_version': CvssVersionEnum;
    /**
     * 
     * @type {IssuerEnum}
     * @memberof FlawCVSSPut
     */
    'issuer': IssuerEnum;
    /**
     * 
     * @type {number}
     * @memberof FlawCVSSPut
     */
    'score': number;
    /**
     * 
     * @type {string}
     * @memberof FlawCVSSPut
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof FlawCVSSPut
     */
    'vector': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof FlawCVSSPut
     */
    'embargoed': boolean;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof FlawCVSSPut
     */
    'alerts': Array<Alert>;
    /**
     * 
     * @type {string}
     * @memberof FlawCVSSPut
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof FlawCVSSPut
     */
    'updated_dt': string;
}


/**
 * 
 * @export
 * @interface FlawClassification
 */
export interface FlawClassification {
    /**
     * 
     * @type {string}
     * @memberof FlawClassification
     */
    'workflow'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawClassification
     */
    'state'?: FlawClassificationStateEnum;
}

export const FlawClassificationStateEnum = {
    Empty: '',
    New: 'NEW',
    Triage: 'TRIAGE',
    PreSecondaryAssessment: 'PRE_SECONDARY_ASSESSMENT',
    SecondaryAssessment: 'SECONDARY_ASSESSMENT',
    Done: 'DONE',
    Rejected: 'REJECTED'
} as const;

export type FlawClassificationStateEnum = typeof FlawClassificationStateEnum[keyof typeof FlawClassificationStateEnum];

/**
 * FlawComment serializer for use by flaw_comments endpoint
 * @export
 * @interface FlawComment
 */
export interface FlawComment {
    /**
     * 
     * @type {string}
     * @memberof FlawComment
     */
    'flaw': string;
    /**
     * 
     * @type {string}
     * @memberof FlawComment
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof FlawComment
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof FlawComment
     */
    'external_system_id': string;
    /**
     * 
     * @type {number}
     * @memberof FlawComment
     */
    'order'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FlawComment
     */
    'creator'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FlawComment
     */
    'is_private'?: boolean;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof FlawComment
     */
    'alerts': Array<Alert>;
    /**
     * 
     * @type {string}
     * @memberof FlawComment
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof FlawComment
     */
    'updated_dt': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof FlawComment
     */
    'embargoed': boolean;
}
/**
 * FlawComment serializer for use by flaw_comments endpoint
 * @export
 * @interface FlawCommentPost
 */
export interface FlawCommentPost {
    /**
     * 
     * @type {string}
     * @memberof FlawCommentPost
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof FlawCommentPost
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof FlawCommentPost
     */
    'creator'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FlawCommentPost
     */
    'is_private'?: boolean;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof FlawCommentPost
     */
    'alerts': Array<Alert>;
    /**
     * 
     * @type {string}
     * @memberof FlawCommentPost
     */
    'created_dt': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof FlawCommentPost
     */
    'embargoed': boolean;
}
/**
 * @type FlawMajorIncidentState
 * @export
 */
export type FlawMajorIncidentState = BlankEnum | MajorIncidentStateEnum;

/**
 * 
 * @export
 * @interface FlawMetaAttr
 */
export interface FlawMetaAttr {
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'acknowledgments'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'acks_not_needed'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'affects'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'alias'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'bz_datascore'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'bz_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'checklists'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'classification'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'cwe'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'depends_on'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'impact'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'jira_trackers'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'mitigate'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'mitigation'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'public'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'references'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'related_cves'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'reported'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'source'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'statement'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawMetaAttr
     */
    'task_owner'?: string;
}
/**
 * @type FlawNistCvssValidation
 * @export
 */
export type FlawNistCvssValidation = BlankEnum | NistCvssValidationEnum;

/**
 * Package model serializer
 * @export
 * @interface FlawPackageVersion
 */
export interface FlawPackageVersion {
    /**
     * 
     * @type {string}
     * @memberof FlawPackageVersion
     */
    'package': string;
    /**
     * 
     * @type {Array<FlawVersion>}
     * @memberof FlawPackageVersion
     */
    'versions': Array<FlawVersion>;
    /**
     * 
     * @type {string}
     * @memberof FlawPackageVersion
     */
    'flaw': string;
    /**
     * 
     * @type {string}
     * @memberof FlawPackageVersion
     */
    'uuid': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof FlawPackageVersion
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof FlawPackageVersion
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof FlawPackageVersion
     */
    'updated_dt': string;
}
/**
 * Package model serializer
 * @export
 * @interface FlawPackageVersionPost
 */
export interface FlawPackageVersionPost {
    /**
     * 
     * @type {string}
     * @memberof FlawPackageVersionPost
     */
    'package': string;
    /**
     * 
     * @type {Array<FlawVersion>}
     * @memberof FlawPackageVersionPost
     */
    'versions': Array<FlawVersion>;
    /**
     * 
     * @type {string}
     * @memberof FlawPackageVersionPost
     */
    'uuid': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof FlawPackageVersionPost
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof FlawPackageVersionPost
     */
    'created_dt': string;
}
/**
 * Package model serializer
 * @export
 * @interface FlawPackageVersionPut
 */
export interface FlawPackageVersionPut {
    /**
     * 
     * @type {string}
     * @memberof FlawPackageVersionPut
     */
    'package': string;
    /**
     * 
     * @type {Array<FlawVersion>}
     * @memberof FlawPackageVersionPut
     */
    'versions': Array<FlawVersion>;
    /**
     * 
     * @type {string}
     * @memberof FlawPackageVersionPut
     */
    'uuid': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof FlawPackageVersionPut
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof FlawPackageVersionPut
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof FlawPackageVersionPut
     */
    'updated_dt': string;
}
/**
 * serialize flaw model
 * @export
 * @interface FlawPost
 */
export interface FlawPost {
    /**
     * 
     * @type {string}
     * @memberof FlawPost
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof FlawPost
     */
    'cve_id'?: string | null;
    /**
     * 
     * @type {AffectImpact}
     * @memberof FlawPost
     */
    'impact'?: AffectImpact;
    /**
     * 
     * @type {Array<string>}
     * @memberof FlawPost
     */
    'components'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof FlawPost
     */
    'title': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof FlawPost
     */
    'trackers': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof FlawPost
     */
    'comment_zero': string;
    /**
     * 
     * @type {string}
     * @memberof FlawPost
     */
    'cve_description'?: string;
    /**
     * 
     * @type {FlawRequiresCveDescription}
     * @memberof FlawPost
     */
    'requires_cve_description'?: FlawRequiresCveDescription;
    /**
     * 
     * @type {string}
     * @memberof FlawPost
     */
    'statement'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawPost
     */
    'cwe_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawPost
     */
    'unembargo_dt'?: string | null;
    /**
     * 
     * @type {FlawSource}
     * @memberof FlawPost
     */
    'source'?: FlawSource;
    /**
     * 
     * @type {string}
     * @memberof FlawPost
     */
    'reported_dt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlawPost
     */
    'mitigation'?: string;
    /**
     * 
     * @type {FlawMajorIncidentState}
     * @memberof FlawPost
     */
    'major_incident_state'?: FlawMajorIncidentState;
    /**
     * 
     * @type {string}
     * @memberof FlawPost
     */
    'major_incident_start_dt'?: string | null;
    /**
     * 
     * @type {FlawNistCvssValidation}
     * @memberof FlawPost
     */
    'nist_cvss_validation'?: FlawNistCvssValidation;
    /**
     * 
     * @type {Array<Affect>}
     * @memberof FlawPost
     */
    'affects': Array<Affect>;
    /**
     * 
     * @type {Array<Comment>}
     * @memberof FlawPost
     */
    'comments': Array<Comment>;
    /**
     * 
     * @type {FlawMetaAttr}
     * @memberof FlawPost
     */
    'meta_attr': FlawMetaAttr;
    /**
     * 
     * @type {Array<Package>}
     * @memberof FlawPost
     */
    'package_versions': Array<Package>;
    /**
     * 
     * @type {Array<FlawAcknowledgment>}
     * @memberof FlawPost
     */
    'acknowledgments': Array<FlawAcknowledgment>;
    /**
     * 
     * @type {Array<FlawReference>}
     * @memberof FlawPost
     */
    'references': Array<FlawReference>;
    /**
     * 
     * @type {Array<FlawCVSS>}
     * @memberof FlawPost
     */
    'cvss_scores': Array<FlawCVSS>;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof FlawPost
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof FlawPost
     */
    'created_dt': string;
    /**
     * 
     * @type {FlawClassification}
     * @memberof FlawPost
     */
    'classification': FlawClassification;
    /**
     * 
     * @type {string}
     * @memberof FlawPost
     */
    'group_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawPost
     */
    'owner'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawPost
     */
    'task_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawPost
     */
    'team_id'?: string;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof FlawPost
     */
    'alerts': Array<Alert>;
}
/**
 * FlawReference serializer
 * @export
 * @interface FlawReference
 */
export interface FlawReference {
    /**
     * 
     * @type {string}
     * @memberof FlawReference
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlawReference
     */
    'flaw': string;
    /**
     * 
     * @type {FlawReferenceType}
     * @memberof FlawReference
     */
    'type'?: FlawReferenceType;
    /**
     * 
     * @type {string}
     * @memberof FlawReference
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof FlawReference
     */
    'uuid': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof FlawReference
     */
    'embargoed': boolean;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof FlawReference
     */
    'alerts': Array<Alert>;
    /**
     * 
     * @type {string}
     * @memberof FlawReference
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof FlawReference
     */
    'updated_dt': string;
}


/**
 * FlawReference serializer
 * @export
 * @interface FlawReferencePost
 */
export interface FlawReferencePost {
    /**
     * 
     * @type {string}
     * @memberof FlawReferencePost
     */
    'description'?: string;
    /**
     * 
     * @type {FlawReferenceType}
     * @memberof FlawReferencePost
     */
    'type'?: FlawReferenceType;
    /**
     * 
     * @type {string}
     * @memberof FlawReferencePost
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof FlawReferencePost
     */
    'uuid': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof FlawReferencePost
     */
    'embargoed': boolean;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof FlawReferencePost
     */
    'alerts': Array<Alert>;
    /**
     * 
     * @type {string}
     * @memberof FlawReferencePost
     */
    'created_dt': string;
}


/**
 * FlawReference serializer
 * @export
 * @interface FlawReferencePut
 */
export interface FlawReferencePut {
    /**
     * 
     * @type {string}
     * @memberof FlawReferencePut
     */
    'description'?: string;
    /**
     * 
     * @type {FlawReferenceType}
     * @memberof FlawReferencePut
     */
    'type'?: FlawReferenceType;
    /**
     * 
     * @type {string}
     * @memberof FlawReferencePut
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof FlawReferencePut
     */
    'uuid': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof FlawReferencePut
     */
    'embargoed': boolean;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof FlawReferencePut
     */
    'alerts': Array<Alert>;
    /**
     * 
     * @type {string}
     * @memberof FlawReferencePut
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof FlawReferencePut
     */
    'updated_dt': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const FlawReferenceType = {
    Article: 'ARTICLE',
    External: 'EXTERNAL',
    Source: 'SOURCE'
} as const;

export type FlawReferenceType = typeof FlawReferenceType[keyof typeof FlawReferenceType];


/**
 * 
 * @export
 * @interface FlawReportData
 */
export interface FlawReportData {
    /**
     * 
     * @type {string}
     * @memberof FlawReportData
     */
    'cve_id'?: string | null;
    /**
     * 
     * @type {Array<AffectReportData>}
     * @memberof FlawReportData
     */
    'affects'?: Array<AffectReportData>;
}
/**
 * @type FlawRequiresCveDescription
 * @export
 */
export type FlawRequiresCveDescription = BlankEnum | RequiresCveDescriptionEnum;

/**
 * @type FlawSource
 * @export
 */
export type FlawSource = BlankEnum | Source642Enum;

/**
 * 
 * @export
 * @interface FlawUUIDList
 */
export interface FlawUUIDList {
    /**
     * 
     * @type {Array<string>}
     * @memberof FlawUUIDList
     */
    'flaw_uuids': Array<string>;
}
/**
 * PackageVer serializer used by FlawPackageVersionSerializer.
 * @export
 * @interface FlawVersion
 */
export interface FlawVersion {
    /**
     * 
     * @type {string}
     * @memberof FlawVersion
     */
    'version': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ImpactEnum = {
    Low: 'LOW',
    Moderate: 'MODERATE',
    Important: 'IMPORTANT',
    Critical: 'CRITICAL'
} as const;

export type ImpactEnum = typeof ImpactEnum[keyof typeof ImpactEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const IssuerEnum = {
    Rh: 'RH',
    Nist: 'NIST',
    Osv: 'OSV'
} as const;

export type IssuerEnum = typeof IssuerEnum[keyof typeof IssuerEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const MajorIncidentStateEnum = {
    Requested: 'REQUESTED',
    Rejected: 'REJECTED',
    Approved: 'APPROVED',
    CisaApproved: 'CISA_APPROVED',
    Invalid: 'INVALID'
} as const;

export type MajorIncidentStateEnum = typeof MajorIncidentStateEnum[keyof typeof MajorIncidentStateEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const MaturityPreliminaryEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;

export type MaturityPreliminaryEnum = typeof MaturityPreliminaryEnum[keyof typeof MaturityPreliminaryEnum];


/**
 * 
 * @export
 * @interface ModuleComponent
 */
export interface ModuleComponent {
    /**
     * 
     * @type {string}
     * @memberof ModuleComponent
     */
    'ps_module': string;
    /**
     * 
     * @type {string}
     * @memberof ModuleComponent
     */
    'ps_component': string;
    /**
     * 
     * @type {Array<PsStreamSelection>}
     * @memberof ModuleComponent
     */
    'streams': Array<PsStreamSelection>;
    /**
     * 
     * @type {boolean}
     * @memberof ModuleComponent
     */
    'selected': boolean;
    /**
     * 
     * @type {Affect}
     * @memberof ModuleComponent
     */
    'affect': Affect;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const NistCvssValidationEnum = {
    Requested: 'REQUESTED',
    Approved: 'APPROVED',
    Rejected: 'REJECTED'
} as const;

export type NistCvssValidationEnum = typeof NistCvssValidationEnum[keyof typeof NistCvssValidationEnum];


/**
 * 
 * @export
 * @interface OsidbApiV1AffectsBulkUpdate200Response
 */
export interface OsidbApiV1AffectsBulkUpdate200Response {
    /**
     * 
     * @type {Array<Affect>}
     * @memberof OsidbApiV1AffectsBulkUpdate200Response
     */
    'results': Array<Affect>;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsBulkUpdate200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsBulkUpdate200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsBulkUpdate200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsBulkUpdate200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface OsidbApiV1AffectsCreate201Response
 */
export interface OsidbApiV1AffectsCreate201Response {
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'flaw': string | null;
    /**
     * 
     * @type {AffectAffectedness}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'affectedness'?: AffectAffectedness;
    /**
     * 
     * @type {AffectResolution}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'resolution'?: AffectResolution;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'ps_module': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'ps_product': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'ps_component': string;
    /**
     * 
     * @type {AffectImpact}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'impact'?: AffectImpact;
    /**
     * 
     * @type {Array<Tracker>}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'trackers': Array<Tracker>;
    /**
     * 
     * @type {AffectMetaAttr}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'meta_attr': AffectMetaAttr;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'delegated_resolution': string;
    /**
     * 
     * @type {Array<AffectCVSS>}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'cvss_scores': Array<AffectCVSS>;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'embargoed': boolean;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'alerts': Array<Alert>;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'updated_dt': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCreate201Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface OsidbApiV1AffectsCvssScoresCreate201Response
 */
export interface OsidbApiV1AffectsCvssScoresCreate201Response {
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCvssScoresCreate201Response
     */
    'affect'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCvssScoresCreate201Response
     */
    'comment'?: string | null;
    /**
     * 
     * @type {CvssVersionEnum}
     * @memberof OsidbApiV1AffectsCvssScoresCreate201Response
     */
    'cvss_version': CvssVersionEnum;
    /**
     * 
     * @type {IssuerEnum}
     * @memberof OsidbApiV1AffectsCvssScoresCreate201Response
     */
    'issuer': IssuerEnum;
    /**
     * 
     * @type {number}
     * @memberof OsidbApiV1AffectsCvssScoresCreate201Response
     */
    'score': number;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCvssScoresCreate201Response
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCvssScoresCreate201Response
     */
    'vector': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof OsidbApiV1AffectsCvssScoresCreate201Response
     */
    'embargoed': boolean;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof OsidbApiV1AffectsCvssScoresCreate201Response
     */
    'alerts': Array<Alert>;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCvssScoresCreate201Response
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof OsidbApiV1AffectsCvssScoresCreate201Response
     */
    'updated_dt': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCvssScoresCreate201Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCvssScoresCreate201Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCvssScoresCreate201Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCvssScoresCreate201Response
     */
    'version'?: string;
}


/**
 * 
 * @export
 * @interface OsidbApiV1AffectsCvssScoresList200Response
 */
export interface OsidbApiV1AffectsCvssScoresList200Response {
    /**
     * 
     * @type {number}
     * @memberof OsidbApiV1AffectsCvssScoresList200Response
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCvssScoresList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCvssScoresList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<AffectCVSS>}
     * @memberof OsidbApiV1AffectsCvssScoresList200Response
     */
    'results'?: Array<AffectCVSS>;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCvssScoresList200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCvssScoresList200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCvssScoresList200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsCvssScoresList200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface OsidbApiV1AffectsList200Response
 */
export interface OsidbApiV1AffectsList200Response {
    /**
     * 
     * @type {number}
     * @memberof OsidbApiV1AffectsList200Response
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Affect>}
     * @memberof OsidbApiV1AffectsList200Response
     */
    'results'?: Array<Affect>;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsList200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsList200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsList200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AffectsList200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface OsidbApiV1AlertsList200Response
 */
export interface OsidbApiV1AlertsList200Response {
    /**
     * 
     * @type {number}
     * @memberof OsidbApiV1AlertsList200Response
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AlertsList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AlertsList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof OsidbApiV1AlertsList200Response
     */
    'results'?: Array<Alert>;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AlertsList200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AlertsList200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AlertsList200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AlertsList200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface OsidbApiV1AlertsRetrieve200Response
 */
export interface OsidbApiV1AlertsRetrieve200Response {
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AlertsRetrieve200Response
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AlertsRetrieve200Response
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AlertsRetrieve200Response
     */
    'description': string;
    /**
     * 
     * @type {AlertTypeEnum}
     * @memberof OsidbApiV1AlertsRetrieve200Response
     */
    'alert_type'?: AlertTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AlertsRetrieve200Response
     */
    'resolution_steps'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AlertsRetrieve200Response
     */
    'parent_uuid': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AlertsRetrieve200Response
     */
    'parent_model': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AlertsRetrieve200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AlertsRetrieve200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AlertsRetrieve200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AlertsRetrieve200Response
     */
    'version'?: string;
}


/**
 * 
 * @export
 * @interface OsidbApiV1AuditList200Response
 */
export interface OsidbApiV1AuditList200Response {
    /**
     * 
     * @type {number}
     * @memberof OsidbApiV1AuditList200Response
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AuditList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AuditList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Audit>}
     * @memberof OsidbApiV1AuditList200Response
     */
    'results'?: Array<Audit>;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AuditList200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AuditList200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AuditList200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AuditList200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface OsidbApiV1AuditRetrieve200Response
 */
export interface OsidbApiV1AuditRetrieve200Response {
    /**
     * When the event was created.
     * @type {string}
     * @memberof OsidbApiV1AuditRetrieve200Response
     */
    'pgh_created_at': string;
    /**
     * The unique identifier across all event tables.
     * @type {string}
     * @memberof OsidbApiV1AuditRetrieve200Response
     */
    'pgh_slug': string;
    /**
     * The object model.
     * @type {string}
     * @memberof OsidbApiV1AuditRetrieve200Response
     */
    'pgh_obj_model': string;
    /**
     * The primary key of the object.
     * @type {string}
     * @memberof OsidbApiV1AuditRetrieve200Response
     */
    'pgh_obj_id'?: string | null;
    /**
     * The event label.
     * @type {string}
     * @memberof OsidbApiV1AuditRetrieve200Response
     */
    'pgh_label': string;
    /**
     * The context associated with the event.
     * @type {{ [key: string]: any; }}
     * @memberof OsidbApiV1AuditRetrieve200Response
     */
    'pgh_context'?: { [key: string]: any; } | null;
    /**
     * The diff between the previous event of the same label.
     * @type {{ [key: string]: any; }}
     * @memberof OsidbApiV1AuditRetrieve200Response
     */
    'pgh_diff': { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AuditRetrieve200Response
     */
    'pgh_data': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AuditRetrieve200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AuditRetrieve200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AuditRetrieve200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1AuditRetrieve200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface OsidbApiV1FlawsAcknowledgmentsCreate201Response
 */
export interface OsidbApiV1FlawsAcknowledgmentsCreate201Response {
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsAcknowledgmentsCreate201Response
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsAcknowledgmentsCreate201Response
     */
    'affiliation': string;
    /**
     * 
     * @type {boolean}
     * @memberof OsidbApiV1FlawsAcknowledgmentsCreate201Response
     */
    'from_upstream': boolean;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsAcknowledgmentsCreate201Response
     */
    'flaw': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsAcknowledgmentsCreate201Response
     */
    'uuid': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof OsidbApiV1FlawsAcknowledgmentsCreate201Response
     */
    'embargoed': boolean;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof OsidbApiV1FlawsAcknowledgmentsCreate201Response
     */
    'alerts': Array<Alert>;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsAcknowledgmentsCreate201Response
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof OsidbApiV1FlawsAcknowledgmentsCreate201Response
     */
    'updated_dt': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsAcknowledgmentsCreate201Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsAcknowledgmentsCreate201Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsAcknowledgmentsCreate201Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsAcknowledgmentsCreate201Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface OsidbApiV1FlawsAcknowledgmentsList200Response
 */
export interface OsidbApiV1FlawsAcknowledgmentsList200Response {
    /**
     * 
     * @type {number}
     * @memberof OsidbApiV1FlawsAcknowledgmentsList200Response
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsAcknowledgmentsList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsAcknowledgmentsList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<FlawAcknowledgment>}
     * @memberof OsidbApiV1FlawsAcknowledgmentsList200Response
     */
    'results'?: Array<FlawAcknowledgment>;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsAcknowledgmentsList200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsAcknowledgmentsList200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsAcknowledgmentsList200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsAcknowledgmentsList200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface OsidbApiV1FlawsCommentsCreate201Response
 */
export interface OsidbApiV1FlawsCommentsCreate201Response {
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCommentsCreate201Response
     */
    'flaw': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCommentsCreate201Response
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCommentsCreate201Response
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCommentsCreate201Response
     */
    'external_system_id': string;
    /**
     * 
     * @type {number}
     * @memberof OsidbApiV1FlawsCommentsCreate201Response
     */
    'order'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCommentsCreate201Response
     */
    'creator'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OsidbApiV1FlawsCommentsCreate201Response
     */
    'is_private'?: boolean;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof OsidbApiV1FlawsCommentsCreate201Response
     */
    'alerts': Array<Alert>;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCommentsCreate201Response
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof OsidbApiV1FlawsCommentsCreate201Response
     */
    'updated_dt': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof OsidbApiV1FlawsCommentsCreate201Response
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCommentsCreate201Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCommentsCreate201Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCommentsCreate201Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCommentsCreate201Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface OsidbApiV1FlawsCommentsList200Response
 */
export interface OsidbApiV1FlawsCommentsList200Response {
    /**
     * 
     * @type {number}
     * @memberof OsidbApiV1FlawsCommentsList200Response
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCommentsList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCommentsList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<FlawComment>}
     * @memberof OsidbApiV1FlawsCommentsList200Response
     */
    'results'?: Array<FlawComment>;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCommentsList200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCommentsList200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCommentsList200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCommentsList200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface OsidbApiV1FlawsCreate201Response
 */
export interface OsidbApiV1FlawsCreate201Response {
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'cve_id'?: string | null;
    /**
     * 
     * @type {AffectImpact}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'impact'?: AffectImpact;
    /**
     * 
     * @type {Array<string>}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'components'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'title': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'trackers': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'comment_zero': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'cve_description'?: string;
    /**
     * 
     * @type {FlawRequiresCveDescription}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'requires_cve_description'?: FlawRequiresCveDescription;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'statement'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'cwe_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'unembargo_dt'?: string | null;
    /**
     * 
     * @type {FlawSource}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'source'?: FlawSource;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'reported_dt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'mitigation'?: string;
    /**
     * 
     * @type {FlawMajorIncidentState}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'major_incident_state'?: FlawMajorIncidentState;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'major_incident_start_dt'?: string | null;
    /**
     * 
     * @type {FlawNistCvssValidation}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'nist_cvss_validation'?: FlawNistCvssValidation;
    /**
     * 
     * @type {Array<Affect>}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'affects': Array<Affect>;
    /**
     * 
     * @type {Array<Comment>}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'comments': Array<Comment>;
    /**
     * 
     * @type {FlawMetaAttr}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'meta_attr': FlawMetaAttr;
    /**
     * 
     * @type {Array<Package>}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'package_versions': Array<Package>;
    /**
     * 
     * @type {Array<FlawAcknowledgment>}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'acknowledgments': Array<FlawAcknowledgment>;
    /**
     * 
     * @type {Array<FlawReference>}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'references': Array<FlawReference>;
    /**
     * 
     * @type {Array<FlawCVSS>}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'cvss_scores': Array<FlawCVSS>;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'updated_dt': string;
    /**
     * 
     * @type {FlawClassification}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'classification': FlawClassification;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'group_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'owner'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'task_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'team_id'?: string;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'alerts': Array<Alert>;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCreate201Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface OsidbApiV1FlawsCvssScoresCreate201Response
 */
export interface OsidbApiV1FlawsCvssScoresCreate201Response {
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCvssScoresCreate201Response
     */
    'flaw'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCvssScoresCreate201Response
     */
    'comment'?: string | null;
    /**
     * 
     * @type {CvssVersionEnum}
     * @memberof OsidbApiV1FlawsCvssScoresCreate201Response
     */
    'cvss_version': CvssVersionEnum;
    /**
     * 
     * @type {IssuerEnum}
     * @memberof OsidbApiV1FlawsCvssScoresCreate201Response
     */
    'issuer': IssuerEnum;
    /**
     * 
     * @type {number}
     * @memberof OsidbApiV1FlawsCvssScoresCreate201Response
     */
    'score': number;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCvssScoresCreate201Response
     */
    'uuid': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCvssScoresCreate201Response
     */
    'vector': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof OsidbApiV1FlawsCvssScoresCreate201Response
     */
    'embargoed': boolean;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof OsidbApiV1FlawsCvssScoresCreate201Response
     */
    'alerts': Array<Alert>;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCvssScoresCreate201Response
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof OsidbApiV1FlawsCvssScoresCreate201Response
     */
    'updated_dt': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCvssScoresCreate201Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCvssScoresCreate201Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCvssScoresCreate201Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCvssScoresCreate201Response
     */
    'version'?: string;
}


/**
 * 
 * @export
 * @interface OsidbApiV1FlawsCvssScoresList200Response
 */
export interface OsidbApiV1FlawsCvssScoresList200Response {
    /**
     * 
     * @type {number}
     * @memberof OsidbApiV1FlawsCvssScoresList200Response
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCvssScoresList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCvssScoresList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<FlawCVSS>}
     * @memberof OsidbApiV1FlawsCvssScoresList200Response
     */
    'results'?: Array<FlawCVSS>;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCvssScoresList200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCvssScoresList200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCvssScoresList200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsCvssScoresList200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface OsidbApiV1FlawsList200Response
 */
export interface OsidbApiV1FlawsList200Response {
    /**
     * 
     * @type {number}
     * @memberof OsidbApiV1FlawsList200Response
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Flaw>}
     * @memberof OsidbApiV1FlawsList200Response
     */
    'results'?: Array<Flaw>;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsList200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsList200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsList200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsList200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface OsidbApiV1FlawsPackageVersionsCreate201Response
 */
export interface OsidbApiV1FlawsPackageVersionsCreate201Response {
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsPackageVersionsCreate201Response
     */
    'package': string;
    /**
     * 
     * @type {Array<FlawVersion>}
     * @memberof OsidbApiV1FlawsPackageVersionsCreate201Response
     */
    'versions': Array<FlawVersion>;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsPackageVersionsCreate201Response
     */
    'flaw': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsPackageVersionsCreate201Response
     */
    'uuid': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof OsidbApiV1FlawsPackageVersionsCreate201Response
     */
    'embargoed': boolean;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsPackageVersionsCreate201Response
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof OsidbApiV1FlawsPackageVersionsCreate201Response
     */
    'updated_dt': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsPackageVersionsCreate201Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsPackageVersionsCreate201Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsPackageVersionsCreate201Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsPackageVersionsCreate201Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface OsidbApiV1FlawsPackageVersionsList200Response
 */
export interface OsidbApiV1FlawsPackageVersionsList200Response {
    /**
     * 
     * @type {number}
     * @memberof OsidbApiV1FlawsPackageVersionsList200Response
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsPackageVersionsList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsPackageVersionsList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<FlawPackageVersion>}
     * @memberof OsidbApiV1FlawsPackageVersionsList200Response
     */
    'results'?: Array<FlawPackageVersion>;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsPackageVersionsList200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsPackageVersionsList200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsPackageVersionsList200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsPackageVersionsList200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface OsidbApiV1FlawsReferencesCreate201Response
 */
export interface OsidbApiV1FlawsReferencesCreate201Response {
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsReferencesCreate201Response
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsReferencesCreate201Response
     */
    'flaw': string;
    /**
     * 
     * @type {FlawReferenceType}
     * @memberof OsidbApiV1FlawsReferencesCreate201Response
     */
    'type'?: FlawReferenceType;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsReferencesCreate201Response
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsReferencesCreate201Response
     */
    'uuid': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof OsidbApiV1FlawsReferencesCreate201Response
     */
    'embargoed': boolean;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof OsidbApiV1FlawsReferencesCreate201Response
     */
    'alerts': Array<Alert>;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsReferencesCreate201Response
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof OsidbApiV1FlawsReferencesCreate201Response
     */
    'updated_dt': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsReferencesCreate201Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsReferencesCreate201Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsReferencesCreate201Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsReferencesCreate201Response
     */
    'version'?: string;
}


/**
 * 
 * @export
 * @interface OsidbApiV1FlawsReferencesList200Response
 */
export interface OsidbApiV1FlawsReferencesList200Response {
    /**
     * 
     * @type {number}
     * @memberof OsidbApiV1FlawsReferencesList200Response
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsReferencesList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsReferencesList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<FlawReference>}
     * @memberof OsidbApiV1FlawsReferencesList200Response
     */
    'results'?: Array<FlawReference>;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsReferencesList200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsReferencesList200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsReferencesList200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1FlawsReferencesList200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface OsidbApiV1SchemaRetrieve200Response
 */
export interface OsidbApiV1SchemaRetrieve200Response {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1SchemaRetrieve200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1SchemaRetrieve200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1SchemaRetrieve200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1SchemaRetrieve200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface OsidbApiV1StatusRetrieve200Response
 */
export interface OsidbApiV1StatusRetrieve200Response {
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1StatusRetrieve200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1StatusRetrieve200Response
     */
    'env'?: string;
    /**
     * 
     * @type {OsidbApiV1StatusRetrieve200ResponseOsidbData}
     * @memberof OsidbApiV1StatusRetrieve200Response
     */
    'osidb_data'?: OsidbApiV1StatusRetrieve200ResponseOsidbData;
    /**
     * 
     * @type {object}
     * @memberof OsidbApiV1StatusRetrieve200Response
     */
    'osidb_service'?: object;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1StatusRetrieve200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1StatusRetrieve200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface OsidbApiV1StatusRetrieve200ResponseOsidbData
 */
export interface OsidbApiV1StatusRetrieve200ResponseOsidbData {
    /**
     * 
     * @type {number}
     * @memberof OsidbApiV1StatusRetrieve200ResponseOsidbData
     */
    'flaw_count'?: number;
}
/**
 * 
 * @export
 * @interface OsidbApiV1TrackersCreate201Response
 */
export interface OsidbApiV1TrackersCreate201Response {
    /**
     * 
     * @type {Array<string>}
     * @memberof OsidbApiV1TrackersCreate201Response
     */
    'affects'?: Array<string>;
    /**
     * 
     * @type {Array<Erratum>}
     * @memberof OsidbApiV1TrackersCreate201Response
     */
    'errata': Array<Erratum>;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1TrackersCreate201Response
     */
    'external_system_id': string;
    /**
     * 
     * @type {TrackerMetaAttr}
     * @memberof OsidbApiV1TrackersCreate201Response
     */
    'meta_attr': TrackerMetaAttr;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1TrackersCreate201Response
     */
    'ps_update_stream'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1TrackersCreate201Response
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1TrackersCreate201Response
     */
    'resolution': string;
    /**
     * 
     * @type {TrackerType}
     * @memberof OsidbApiV1TrackersCreate201Response
     */
    'type': TrackerType;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1TrackersCreate201Response
     */
    'uuid': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof OsidbApiV1TrackersCreate201Response
     */
    'embargoed': boolean;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof OsidbApiV1TrackersCreate201Response
     */
    'alerts': Array<Alert>;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1TrackersCreate201Response
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof OsidbApiV1TrackersCreate201Response
     */
    'updated_dt': string;
    /**
     * Setting sync_to_bz to false disables flaw sync with Bugzilla after this operation. Use only as part of bulk actions and trigger a flaw bugzilla sync afterwards. Does nothing if BZ is disabled.
     * @type {boolean}
     * @memberof OsidbApiV1TrackersCreate201Response
     */
    'sync_to_bz'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1TrackersCreate201Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1TrackersCreate201Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1TrackersCreate201Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1TrackersCreate201Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface OsidbApiV1TrackersList200Response
 */
export interface OsidbApiV1TrackersList200Response {
    /**
     * 
     * @type {number}
     * @memberof OsidbApiV1TrackersList200Response
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1TrackersList200Response
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1TrackersList200Response
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Tracker>}
     * @memberof OsidbApiV1TrackersList200Response
     */
    'results'?: Array<Tracker>;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1TrackersList200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1TrackersList200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1TrackersList200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbApiV1TrackersList200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface OsidbWhoamiRetrieve200Response
 */
export interface OsidbWhoamiRetrieve200Response {
    /**
     * 
     * @type {string}
     * @memberof OsidbWhoamiRetrieve200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbWhoamiRetrieve200Response
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbWhoamiRetrieve200Response
     */
    'env'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof OsidbWhoamiRetrieve200Response
     */
    'groups'?: Array<string>;
    /**
     * 
     * @type {OsidbWhoamiRetrieve200ResponseProfile}
     * @memberof OsidbWhoamiRetrieve200Response
     */
    'profile'?: OsidbWhoamiRetrieve200ResponseProfile;
    /**
     * 
     * @type {string}
     * @memberof OsidbWhoamiRetrieve200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbWhoamiRetrieve200Response
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbWhoamiRetrieve200Response
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface OsidbWhoamiRetrieve200ResponseProfile
 */
export interface OsidbWhoamiRetrieve200ResponseProfile {
    /**
     * 
     * @type {string}
     * @memberof OsidbWhoamiRetrieve200ResponseProfile
     */
    'bz_user_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsidbWhoamiRetrieve200ResponseProfile
     */
    'jira_user_id'?: string;
}
/**
 * package_versions (Package model) serializer for read-only use in FlawSerializer.
 * @export
 * @interface Package
 */
export interface Package {
    /**
     * 
     * @type {string}
     * @memberof Package
     */
    'package': string;
    /**
     * 
     * @type {Array<PackageVer>}
     * @memberof Package
     */
    'versions': Array<PackageVer>;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof Package
     */
    'alerts': Array<Alert>;
}
/**
 * PackageVer model serializer for read-only use in FlawSerializer via PackageVerSerializer.
 * @export
 * @interface PackageVer
 */
export interface PackageVer {
    /**
     * 
     * @type {string}
     * @memberof PackageVer
     */
    'version': string;
    /**
     * 
     * @type {string}
     * @memberof PackageVer
     * @deprecated
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface PaginatedAffectCVSSList
 */
export interface PaginatedAffectCVSSList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedAffectCVSSList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAffectCVSSList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAffectCVSSList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<AffectCVSS>}
     * @memberof PaginatedAffectCVSSList
     */
    'results'?: Array<AffectCVSS>;
}
/**
 * 
 * @export
 * @interface PaginatedAffectList
 */
export interface PaginatedAffectList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedAffectList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAffectList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAffectList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Affect>}
     * @memberof PaginatedAffectList
     */
    'results'?: Array<Affect>;
}
/**
 * 
 * @export
 * @interface PaginatedAlertList
 */
export interface PaginatedAlertList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedAlertList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAlertList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAlertList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof PaginatedAlertList
     */
    'results'?: Array<Alert>;
}
/**
 * 
 * @export
 * @interface PaginatedAuditList
 */
export interface PaginatedAuditList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedAuditList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAuditList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAuditList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Audit>}
     * @memberof PaginatedAuditList
     */
    'results'?: Array<Audit>;
}
/**
 * 
 * @export
 * @interface PaginatedEPSSList
 */
export interface PaginatedEPSSList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedEPSSList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedEPSSList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedEPSSList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<EPSS>}
     * @memberof PaginatedEPSSList
     */
    'results'?: Array<EPSS>;
}
/**
 * 
 * @export
 * @interface PaginatedExploitOnlyReportDataList
 */
export interface PaginatedExploitOnlyReportDataList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedExploitOnlyReportDataList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedExploitOnlyReportDataList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedExploitOnlyReportDataList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<ExploitOnlyReportData>}
     * @memberof PaginatedExploitOnlyReportDataList
     */
    'results'?: Array<ExploitOnlyReportData>;
}
/**
 * 
 * @export
 * @interface PaginatedFlawAcknowledgmentList
 */
export interface PaginatedFlawAcknowledgmentList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedFlawAcknowledgmentList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFlawAcknowledgmentList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFlawAcknowledgmentList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<FlawAcknowledgment>}
     * @memberof PaginatedFlawAcknowledgmentList
     */
    'results'?: Array<FlawAcknowledgment>;
}
/**
 * 
 * @export
 * @interface PaginatedFlawCVSSList
 */
export interface PaginatedFlawCVSSList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedFlawCVSSList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFlawCVSSList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFlawCVSSList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<FlawCVSS>}
     * @memberof PaginatedFlawCVSSList
     */
    'results'?: Array<FlawCVSS>;
}
/**
 * 
 * @export
 * @interface PaginatedFlawCommentList
 */
export interface PaginatedFlawCommentList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedFlawCommentList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFlawCommentList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFlawCommentList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<FlawComment>}
     * @memberof PaginatedFlawCommentList
     */
    'results'?: Array<FlawComment>;
}
/**
 * 
 * @export
 * @interface PaginatedFlawList
 */
export interface PaginatedFlawList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedFlawList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFlawList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFlawList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Flaw>}
     * @memberof PaginatedFlawList
     */
    'results'?: Array<Flaw>;
}
/**
 * 
 * @export
 * @interface PaginatedFlawPackageVersionList
 */
export interface PaginatedFlawPackageVersionList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedFlawPackageVersionList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFlawPackageVersionList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFlawPackageVersionList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<FlawPackageVersion>}
     * @memberof PaginatedFlawPackageVersionList
     */
    'results'?: Array<FlawPackageVersion>;
}
/**
 * 
 * @export
 * @interface PaginatedFlawReferenceList
 */
export interface PaginatedFlawReferenceList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedFlawReferenceList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFlawReferenceList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFlawReferenceList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<FlawReference>}
     * @memberof PaginatedFlawReferenceList
     */
    'results'?: Array<FlawReference>;
}
/**
 * 
 * @export
 * @interface PaginatedFlawReportDataList
 */
export interface PaginatedFlawReportDataList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedFlawReportDataList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFlawReportDataList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFlawReportDataList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<FlawReportData>}
     * @memberof PaginatedFlawReportDataList
     */
    'results'?: Array<FlawReportData>;
}
/**
 * 
 * @export
 * @interface PaginatedSupportedProductsList
 */
export interface PaginatedSupportedProductsList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSupportedProductsList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSupportedProductsList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSupportedProductsList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<SupportedProducts>}
     * @memberof PaginatedSupportedProductsList
     */
    'results'?: Array<SupportedProducts>;
}
/**
 * 
 * @export
 * @interface PaginatedTrackerList
 */
export interface PaginatedTrackerList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedTrackerList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedTrackerList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedTrackerList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Tracker>}
     * @memberof PaginatedTrackerList
     */
    'results'?: Array<Tracker>;
}
/**
 * 
 * @export
 * @interface PsStreamSelection
 */
export interface PsStreamSelection {
    /**
     * 
     * @type {string}
     * @memberof PsStreamSelection
     */
    'ps_update_stream': string;
    /**
     * 
     * @type {boolean}
     * @memberof PsStreamSelection
     */
    'selected': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PsStreamSelection
     */
    'acked': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PsStreamSelection
     */
    'eus': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PsStreamSelection
     */
    'aus': boolean;
}
/**
 * Task rejection serializer
 * @export
 * @interface Reject
 */
export interface Reject {
    /**
     * 
     * @type {string}
     * @memberof Reject
     */
    'reason': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const RequiresCveDescriptionEnum = {
    Requested: 'REQUESTED',
    Approved: 'APPROVED',
    Rejected: 'REJECTED'
} as const;

export type RequiresCveDescriptionEnum = typeof RequiresCveDescriptionEnum[keyof typeof RequiresCveDescriptionEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const ResolutionEnum = {
    Fix: 'FIX',
    Defer: 'DEFER',
    Wontfix: 'WONTFIX',
    Ooss: 'OOSS',
    Delegated: 'DELEGATED',
    Wontreport: 'WONTREPORT'
} as const;

export type ResolutionEnum = typeof ResolutionEnum[keyof typeof ResolutionEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const Source642Enum = {
    Adobe: 'ADOBE',
    Apple: 'APPLE',
    Asf: 'ASF',
    Bind: 'BIND',
    Bk: 'BK',
    Bugtraq: 'BUGTRAQ',
    Bugzilla: 'BUGZILLA',
    Cert: 'CERT',
    Certifi: 'CERTIFI',
    Corelabs: 'CORELABS',
    Customer: 'CUSTOMER',
    Cve: 'CVE',
    Dailydave: 'DAILYDAVE',
    Debian: 'DEBIAN',
    Distros: 'DISTROS',
    Fedora: 'FEDORA',
    Fetchmail: 'FETCHMAIL',
    Freedesktop: 'FREEDESKTOP',
    Freeradius: 'FREERADIUS',
    Frsirt: 'FRSIRT',
    Fulldisclosure: 'FULLDISCLOSURE',
    Gaim: 'GAIM',
    Gentoo: 'GENTOO',
    Gentoobz: 'GENTOOBZ',
    Git: 'GIT',
    Gnome: 'GNOME',
    Gnupg: 'GNUPG',
    Google: 'GOOGLE',
    Hp: 'HP',
    HwVendor: 'HW_VENDOR',
    Ibm: 'IBM',
    Idefense: 'IDEFENSE',
    Internet: 'INTERNET',
    Isc: 'ISC',
    Isec: 'ISEC',
    It: 'IT',
    Jboss: 'JBOSS',
    Jpcert: 'JPCERT',
    Kernelbugzilla: 'KERNELBUGZILLA',
    Kernelsec: 'KERNELSEC',
    Lkml: 'LKML',
    Lwn: 'LWN',
    Macromedia: 'MACROMEDIA',
    Mageia: 'MAGEIA',
    Mailinglist: 'MAILINGLIST',
    Milw0Rm: 'MILW0RM',
    Mit: 'MIT',
    Mitre: 'MITRE',
    Mozilla: 'MOZILLA',
    Muttdev: 'MUTTDEV',
    Netdev: 'NETDEV',
    Niscc: 'NISCC',
    Nvd: 'NVD',
    Ocert: 'OCERT',
    Openoffice: 'OPENOFFICE',
    Openssl: 'OPENSSL',
    Opensuse: 'OPENSUSE',
    Oracle: 'ORACLE',
    Oss: 'OSS',
    Osssecurity: 'OSSSECURITY',
    Osv: 'OSV',
    Php: 'PHP',
    Pidgin: 'PIDGIN',
    Postgresql: 'POSTGRESQL',
    Press: 'PRESS',
    Real: 'REAL',
    Redhat: 'REDHAT',
    Researcher: 'RESEARCHER',
    Rt: 'RT',
    Samba: 'SAMBA',
    Secalert: 'SECALERT',
    Secunia: 'SECUNIA',
    Securityfocus: 'SECURITYFOCUS',
    Sko: 'SKO',
    Squid: 'SQUID',
    Squirrelmail: 'SQUIRRELMAIL',
    Sun: 'SUN',
    Sunsolve: 'SUNSOLVE',
    Suse: 'SUSE',
    Twitter: 'TWITTER',
    Ubuntu: 'UBUNTU',
    Upstream: 'UPSTREAM',
    Vendorsec: 'VENDORSEC',
    Vulnwatch: 'VULNWATCH',
    Wireshark: 'WIRESHARK',
    Xchat: 'XCHAT',
    Xen: 'XEN',
    Xpdf: 'XPDF'
} as const;

export type Source642Enum = typeof Source642Enum[keyof typeof Source642Enum];


/**
 * 
 * @export
 * @interface SupportedProducts
 */
export interface SupportedProducts {
    /**
     * 
     * @type {string}
     * @memberof SupportedProducts
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface TokenObtainPair
 */
export interface TokenObtainPair {
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    'access': string;
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    'refresh': string;
}
/**
 * 
 * @export
 * @interface TokenRefresh
 */
export interface TokenRefresh {
    /**
     * 
     * @type {string}
     * @memberof TokenRefresh
     */
    'access': string;
    /**
     * 
     * @type {string}
     * @memberof TokenRefresh
     */
    'refresh': string;
}
/**
 * 
 * @export
 * @interface TokenVerify
 */
export interface TokenVerify {
    /**
     * 
     * @type {string}
     * @memberof TokenVerify
     */
    'token': string;
}
/**
 * Tracker serializer
 * @export
 * @interface Tracker
 */
export interface Tracker {
    /**
     * 
     * @type {Array<string>}
     * @memberof Tracker
     */
    'affects'?: Array<string>;
    /**
     * 
     * @type {Array<Erratum>}
     * @memberof Tracker
     */
    'errata': Array<Erratum>;
    /**
     * 
     * @type {string}
     * @memberof Tracker
     */
    'external_system_id': string;
    /**
     * 
     * @type {TrackerMetaAttr}
     * @memberof Tracker
     */
    'meta_attr': TrackerMetaAttr;
    /**
     * 
     * @type {string}
     * @memberof Tracker
     */
    'ps_update_stream'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tracker
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof Tracker
     */
    'resolution': string;
    /**
     * 
     * @type {TrackerType}
     * @memberof Tracker
     */
    'type': TrackerType;
    /**
     * 
     * @type {string}
     * @memberof Tracker
     */
    'uuid': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof Tracker
     */
    'embargoed': boolean;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof Tracker
     */
    'alerts': Array<Alert>;
    /**
     * 
     * @type {string}
     * @memberof Tracker
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof Tracker
     */
    'updated_dt': string;
    /**
     * Setting sync_to_bz to false disables flaw sync with Bugzilla after this operation. Use only as part of bulk actions and trigger a flaw bugzilla sync afterwards. Does nothing if BZ is disabled.
     * @type {boolean}
     * @memberof Tracker
     */
    'sync_to_bz'?: boolean;
}
/**
 * 
 * @export
 * @interface TrackerMetaAttr
 */
export interface TrackerMetaAttr {
    /**
     * 
     * @type {string}
     * @memberof TrackerMetaAttr
     */
    'bz_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrackerMetaAttr
     */
    'owner'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrackerMetaAttr
     */
    'qe_owner'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrackerMetaAttr
     */
    'ps_component'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrackerMetaAttr
     */
    'ps_module'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrackerMetaAttr
     */
    'ps_update_stream'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrackerMetaAttr
     */
    'resolution'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrackerMetaAttr
     */
    'status'?: string;
}
/**
 * Tracker serializer
 * @export
 * @interface TrackerPost
 */
export interface TrackerPost {
    /**
     * 
     * @type {Array<string>}
     * @memberof TrackerPost
     */
    'affects'?: Array<string>;
    /**
     * 
     * @type {Array<Erratum>}
     * @memberof TrackerPost
     */
    'errata': Array<Erratum>;
    /**
     * 
     * @type {TrackerMetaAttr}
     * @memberof TrackerPost
     */
    'meta_attr': TrackerMetaAttr;
    /**
     * 
     * @type {string}
     * @memberof TrackerPost
     */
    'ps_update_stream'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrackerPost
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof TrackerPost
     */
    'resolution': string;
    /**
     * 
     * @type {TrackerType}
     * @memberof TrackerPost
     */
    'type': TrackerType;
    /**
     * 
     * @type {string}
     * @memberof TrackerPost
     */
    'uuid': string;
    /**
     * The embargoed boolean attribute is technically read-only as it just indirectly modifies the ACLs but is mandatory as it controls the access to the resource.
     * @type {boolean}
     * @memberof TrackerPost
     */
    'embargoed': boolean;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof TrackerPost
     */
    'alerts': Array<Alert>;
    /**
     * 
     * @type {string}
     * @memberof TrackerPost
     */
    'created_dt': string;
    /**
     * The updated_dt timestamp attribute is mandatory on update as it is used to detect mit-air collisions.
     * @type {string}
     * @memberof TrackerPost
     */
    'updated_dt': string;
    /**
     * Setting sync_to_bz to false disables flaw sync with Bugzilla after this operation. Use only as part of bulk actions and trigger a flaw bugzilla sync afterwards. Does nothing if BZ is disabled.
     * @type {boolean}
     * @memberof TrackerPost
     */
    'sync_to_bz'?: boolean;
}
/**
 * 
 * @export
 * @interface TrackerReportData
 */
export interface TrackerReportData {
    /**
     * 
     * @type {TrackerType}
     * @memberof TrackerReportData
     */
    'type': TrackerType;
    /**
     * 
     * @type {string}
     * @memberof TrackerReportData
     */
    'external_system_id': string;
    /**
     * 
     * @type {string}
     * @memberof TrackerReportData
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrackerReportData
     */
    'resolution'?: string;
}


/**
 * 
 * @export
 * @interface TrackerSuggestion
 */
export interface TrackerSuggestion {
    /**
     * 
     * @type {Array<ModuleComponent>}
     * @memberof TrackerSuggestion
     */
    'modules_components': Array<ModuleComponent>;
    /**
     * 
     * @type {Array<Affect>}
     * @memberof TrackerSuggestion
     */
    'not_applicable': Array<Affect>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TrackerType = {
    Jira: 'JIRA',
    Bugzilla: 'BUGZILLA'
} as const;

export type TrackerType = typeof TrackerType[keyof typeof TrackerType];


/**
 * 
 * @export
 * @interface TrackersApiV1FileCreate200Response
 */
export interface TrackersApiV1FileCreate200Response {
    /**
     * 
     * @type {Array<ModuleComponent>}
     * @memberof TrackersApiV1FileCreate200Response
     */
    'modules_components': Array<ModuleComponent>;
    /**
     * 
     * @type {Array<Affect>}
     * @memberof TrackersApiV1FileCreate200Response
     */
    'not_applicable': Array<Affect>;
    /**
     * 
     * @type {string}
     * @memberof TrackersApiV1FileCreate200Response
     */
    'dt'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrackersApiV1FileCreate200Response
     */
    'env'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrackersApiV1FileCreate200Response
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrackersApiV1FileCreate200Response
     */
    'version'?: string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPair} tokenObtainPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenCreate: async (tokenObtainPair: TokenObtainPair, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenObtainPair' is not null or undefined
            assertParamExists('authTokenCreate', 'tokenObtainPair', tokenObtainPair)
            const localVarPath = `/auth/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenObtainPair, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefresh} tokenRefresh 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenRefreshCreate: async (tokenRefresh: TokenRefresh, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenRefresh' is not null or undefined
            assertParamExists('authTokenRefreshCreate', 'tokenRefresh', tokenRefresh)
            const localVarPath = `/auth/token/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRefresh, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a kerberos ticket and returns an access and refresh JWT pair.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication KerberosAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
         * @param {TokenVerify} tokenVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenVerifyCreate: async (tokenVerify: TokenVerify, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenVerify' is not null or undefined
            assertParamExists('authTokenVerifyCreate', 'tokenVerify', tokenVerify)
            const localVarPath = `/auth/token/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenVerify, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPair} tokenObtainPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTokenCreate(tokenObtainPair: TokenObtainPair, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authTokenCreate(tokenObtainPair, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefresh} tokenRefresh 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTokenRefreshCreate(tokenRefresh: TokenRefresh, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenRefreshCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authTokenRefreshCreate(tokenRefresh, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Takes a kerberos ticket and returns an access and refresh JWT pair.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTokenRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenRetrieve200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authTokenRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
         * @param {TokenVerify} tokenVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTokenVerifyCreate(tokenVerify: TokenVerify, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenVerifyCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authTokenVerifyCreate(tokenVerify, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPair} tokenObtainPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenCreate(tokenObtainPair: TokenObtainPair, options?: any): AxiosPromise<AuthTokenCreate200Response> {
            return localVarFp.authTokenCreate(tokenObtainPair, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefresh} tokenRefresh 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenRefreshCreate(tokenRefresh: TokenRefresh, options?: any): AxiosPromise<AuthTokenRefreshCreate200Response> {
            return localVarFp.authTokenRefreshCreate(tokenRefresh, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a kerberos ticket and returns an access and refresh JWT pair.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenRetrieve(options?: any): AxiosPromise<AuthTokenRetrieve200Response> {
            return localVarFp.authTokenRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
         * @param {TokenVerify} tokenVerify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenVerifyCreate(tokenVerify: TokenVerify, options?: any): AxiosPromise<AuthTokenVerifyCreate200Response> {
            return localVarFp.authTokenVerifyCreate(tokenVerify, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
     * @param {TokenObtainPair} tokenObtainPair 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authTokenCreate(tokenObtainPair: TokenObtainPair, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authTokenCreate(tokenObtainPair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
     * @param {TokenRefresh} tokenRefresh 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authTokenRefreshCreate(tokenRefresh: TokenRefresh, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authTokenRefreshCreate(tokenRefresh, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a kerberos ticket and returns an access and refresh JWT pair.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authTokenRetrieve(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authTokenRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
     * @param {TokenVerify} tokenVerify 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authTokenVerifyCreate(tokenVerify: TokenVerify, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authTokenVerifyCreate(tokenVerify, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CollectorsApi - axios parameter creator
 * @export
 */
export const CollectorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * get the overall status of all collectors and the collected data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectorsApiV1StatusRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/collectors/api/v1/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * unauthenticated health check API endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectorsHealthyRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/collectors/healthy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * index API endpoint listing available collector API endpoints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectorsRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/collectors/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectorsApi - functional programming interface
 * @export
 */
export const CollectorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CollectorsApiAxiosParamCreator(configuration)
    return {
        /**
         * get the overall status of all collectors and the collected data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectorsApiV1StatusRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectorsApiV1StatusRetrieve200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectorsApiV1StatusRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * unauthenticated health check API endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectorsHealthyRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200ResponseAllOf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectorsHealthyRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * index API endpoint listing available collector API endpoints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectorsRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectorsRetrieve200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectorsRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CollectorsApi - factory interface
 * @export
 */
export const CollectorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CollectorsApiFp(configuration)
    return {
        /**
         * get the overall status of all collectors and the collected data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectorsApiV1StatusRetrieve(options?: any): AxiosPromise<CollectorsApiV1StatusRetrieve200Response> {
            return localVarFp.collectorsApiV1StatusRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * unauthenticated health check API endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectorsHealthyRetrieve(options?: any): AxiosPromise<AuthTokenCreate200ResponseAllOf> {
            return localVarFp.collectorsHealthyRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * index API endpoint listing available collector API endpoints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectorsRetrieve(options?: any): AxiosPromise<CollectorsRetrieve200Response> {
            return localVarFp.collectorsRetrieve(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CollectorsApi - object-oriented interface
 * @export
 * @class CollectorsApi
 * @extends {BaseAPI}
 */
export class CollectorsApi extends BaseAPI {
    /**
     * get the overall status of all collectors and the collected data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectorsApi
     */
    public collectorsApiV1StatusRetrieve(options?: AxiosRequestConfig) {
        return CollectorsApiFp(this.configuration).collectorsApiV1StatusRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * unauthenticated health check API endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectorsApi
     */
    public collectorsHealthyRetrieve(options?: AxiosRequestConfig) {
        return CollectorsApiFp(this.configuration).collectorsHealthyRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * index API endpoint listing available collector API endpoints
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectorsApi
     */
    public collectorsRetrieve(options?: AxiosRequestConfig) {
        return CollectorsApiFp(this.configuration).collectorsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ExploitsApi - axios parameter creator
 * @export
 */
export const ExploitsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * API endpoint for re-collecting exploit data.  **NOTE:** Currently for CISA data only, which is very small and collection is fast.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1CollectUpdate: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/exploits/api/v1/collect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint for getting simple exploits information mapped to impacted CVEs.  The Insights Vulnerability application needs this format.  Format of results: ``` {   \"page_size\": <Number of CVEs on the page>,   \"cves\": {     \"CVE-2222-0001\": [<List of exploits>],     \"CVE-2222-0002\": [<List of exploits>],     ...   }, } ```
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1CveMapRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/exploits/api/v1/cve_map`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint for getting list of Red Hat relevant CVEs with their EPSS score.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1EpssList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/exploits/api/v1/epss`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Flaw, affect, and tracker data for Exploits
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1FlawDataList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/exploits/api/v1/flaw_data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export only the data required to generate the exploits report
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1ReportDataList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/exploits/api/v1/report_data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint for getting date based report for Incident Response.  Format of results: ``` {   \"cutoff_date\": <Date>,   \"evaluated_cves\": <Number of new CVEs with exploits>,   \"action_required\": [<List of affects requiring action>],   \"no_action\": [<List of CVEs not requiring action with reason>],   \"not_relevant\": [<List of CVEs which are not in the database with reason>], } ```  **NOTE:** No pagination is performed on this endpoint as data is limited by date and is expected           to be fairly small. Also, because data is broken into three categories it is not           exactly obvious how to create pages.
         * @param {string} date Date format: YYYY-MM-DD
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1ReportDateRetrieve: async (date: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'date' is not null or undefined
            assertParamExists('exploitsApiV1ReportDateRetrieve', 'date', date)
            const localVarPath = `/exploits/api/v1/report/date/{date}`
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint for getting a report of all CVEs with exploit and their status for Incident Response.  Format of results: ``` {    \"page_size\": <Number of CVEs on the page>,    \"explanations\": [<List of CVEs with exploit together with current status explanation>], } ```
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1ReportExplanationsRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/exploits/api/v1/report/explanations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint for getting a report of pending actions for Incident Response.  Format of results: ``` {   \"pending_actions\": [<List of affects requiring action>],   \"pending_actions_count\": <Number of affects requiring action>, } ```  **NOTE:** No pagination is performed on this endpoint as it is expected that the size of           the list of pending actions will be mostly stable. Also, the paging cannot be done on           the query level, as additional analysis of every exploit is required before a decision           to include it in this report is done.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1ReportPendingRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/exploits/api/v1/report/pending`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint for getting basic information about exploits in the database.  **NOTE:** Everyone is allowed to see basic information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1StatusRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/exploits/api/v1/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API endpoint for getting a list of all supported products.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1SupportedProductsList: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/exploits/api/v1/supported-products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExploitsApi - functional programming interface
 * @export
 */
export const ExploitsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExploitsApiAxiosParamCreator(configuration)
    return {
        /**
         * API endpoint for re-collecting exploit data.  **NOTE:** Currently for CISA data only, which is very small and collection is fast.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exploitsApiV1CollectUpdate(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExploitsApiV1CollectUpdate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exploitsApiV1CollectUpdate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API endpoint for getting simple exploits information mapped to impacted CVEs.  The Insights Vulnerability application needs this format.  Format of results: ``` {   \"page_size\": <Number of CVEs on the page>,   \"cves\": {     \"CVE-2222-0001\": [<List of exploits>],     \"CVE-2222-0002\": [<List of exploits>],     ...   }, } ```
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exploitsApiV1CveMapRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExploitsApiV1CveMapRetrieve200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exploitsApiV1CveMapRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API endpoint for getting list of Red Hat relevant CVEs with their EPSS score.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exploitsApiV1EpssList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExploitsApiV1EpssList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exploitsApiV1EpssList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Flaw, affect, and tracker data for Exploits
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exploitsApiV1FlawDataList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExploitsApiV1FlawDataList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exploitsApiV1FlawDataList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Export only the data required to generate the exploits report
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exploitsApiV1ReportDataList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExploitsApiV1ReportDataList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exploitsApiV1ReportDataList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API endpoint for getting date based report for Incident Response.  Format of results: ``` {   \"cutoff_date\": <Date>,   \"evaluated_cves\": <Number of new CVEs with exploits>,   \"action_required\": [<List of affects requiring action>],   \"no_action\": [<List of CVEs not requiring action with reason>],   \"not_relevant\": [<List of CVEs which are not in the database with reason>], } ```  **NOTE:** No pagination is performed on this endpoint as data is limited by date and is expected           to be fairly small. Also, because data is broken into three categories it is not           exactly obvious how to create pages.
         * @param {string} date Date format: YYYY-MM-DD
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exploitsApiV1ReportDateRetrieve(date: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExploitsApiV1ReportDateRetrieve200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exploitsApiV1ReportDateRetrieve(date, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API endpoint for getting a report of all CVEs with exploit and their status for Incident Response.  Format of results: ``` {    \"page_size\": <Number of CVEs on the page>,    \"explanations\": [<List of CVEs with exploit together with current status explanation>], } ```
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exploitsApiV1ReportExplanationsRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExploitsApiV1ReportExplanationsRetrieve200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exploitsApiV1ReportExplanationsRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API endpoint for getting a report of pending actions for Incident Response.  Format of results: ``` {   \"pending_actions\": [<List of affects requiring action>],   \"pending_actions_count\": <Number of affects requiring action>, } ```  **NOTE:** No pagination is performed on this endpoint as it is expected that the size of           the list of pending actions will be mostly stable. Also, the paging cannot be done on           the query level, as additional analysis of every exploit is required before a decision           to include it in this report is done.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exploitsApiV1ReportPendingRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExploitsApiV1ReportPendingRetrieve200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exploitsApiV1ReportPendingRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API endpoint for getting basic information about exploits in the database.  **NOTE:** Everyone is allowed to see basic information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exploitsApiV1StatusRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExploitsApiV1StatusRetrieve200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exploitsApiV1StatusRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API endpoint for getting a list of all supported products.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exploitsApiV1SupportedProductsList(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExploitsApiV1SupportedProductsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exploitsApiV1SupportedProductsList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExploitsApi - factory interface
 * @export
 */
export const ExploitsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExploitsApiFp(configuration)
    return {
        /**
         * API endpoint for re-collecting exploit data.  **NOTE:** Currently for CISA data only, which is very small and collection is fast.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1CollectUpdate(options?: any): AxiosPromise<ExploitsApiV1CollectUpdate200Response> {
            return localVarFp.exploitsApiV1CollectUpdate(options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint for getting simple exploits information mapped to impacted CVEs.  The Insights Vulnerability application needs this format.  Format of results: ``` {   \"page_size\": <Number of CVEs on the page>,   \"cves\": {     \"CVE-2222-0001\": [<List of exploits>],     \"CVE-2222-0002\": [<List of exploits>],     ...   }, } ```
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1CveMapRetrieve(options?: any): AxiosPromise<ExploitsApiV1CveMapRetrieve200Response> {
            return localVarFp.exploitsApiV1CveMapRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint for getting list of Red Hat relevant CVEs with their EPSS score.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1EpssList(limit?: number, offset?: number, options?: any): AxiosPromise<ExploitsApiV1EpssList200Response> {
            return localVarFp.exploitsApiV1EpssList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Flaw, affect, and tracker data for Exploits
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1FlawDataList(limit?: number, offset?: number, options?: any): AxiosPromise<ExploitsApiV1FlawDataList200Response> {
            return localVarFp.exploitsApiV1FlawDataList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Export only the data required to generate the exploits report
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1ReportDataList(limit?: number, offset?: number, options?: any): AxiosPromise<ExploitsApiV1ReportDataList200Response> {
            return localVarFp.exploitsApiV1ReportDataList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint for getting date based report for Incident Response.  Format of results: ``` {   \"cutoff_date\": <Date>,   \"evaluated_cves\": <Number of new CVEs with exploits>,   \"action_required\": [<List of affects requiring action>],   \"no_action\": [<List of CVEs not requiring action with reason>],   \"not_relevant\": [<List of CVEs which are not in the database with reason>], } ```  **NOTE:** No pagination is performed on this endpoint as data is limited by date and is expected           to be fairly small. Also, because data is broken into three categories it is not           exactly obvious how to create pages.
         * @param {string} date Date format: YYYY-MM-DD
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1ReportDateRetrieve(date: string, options?: any): AxiosPromise<ExploitsApiV1ReportDateRetrieve200Response> {
            return localVarFp.exploitsApiV1ReportDateRetrieve(date, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint for getting a report of all CVEs with exploit and their status for Incident Response.  Format of results: ``` {    \"page_size\": <Number of CVEs on the page>,    \"explanations\": [<List of CVEs with exploit together with current status explanation>], } ```
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1ReportExplanationsRetrieve(options?: any): AxiosPromise<ExploitsApiV1ReportExplanationsRetrieve200Response> {
            return localVarFp.exploitsApiV1ReportExplanationsRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint for getting a report of pending actions for Incident Response.  Format of results: ``` {   \"pending_actions\": [<List of affects requiring action>],   \"pending_actions_count\": <Number of affects requiring action>, } ```  **NOTE:** No pagination is performed on this endpoint as it is expected that the size of           the list of pending actions will be mostly stable. Also, the paging cannot be done on           the query level, as additional analysis of every exploit is required before a decision           to include it in this report is done.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1ReportPendingRetrieve(options?: any): AxiosPromise<ExploitsApiV1ReportPendingRetrieve200Response> {
            return localVarFp.exploitsApiV1ReportPendingRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint for getting basic information about exploits in the database.  **NOTE:** Everyone is allowed to see basic information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1StatusRetrieve(options?: any): AxiosPromise<ExploitsApiV1StatusRetrieve200Response> {
            return localVarFp.exploitsApiV1StatusRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint for getting a list of all supported products.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploitsApiV1SupportedProductsList(limit?: number, offset?: number, options?: any): AxiosPromise<ExploitsApiV1SupportedProductsList200Response> {
            return localVarFp.exploitsApiV1SupportedProductsList(limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExploitsApi - object-oriented interface
 * @export
 * @class ExploitsApi
 * @extends {BaseAPI}
 */
export class ExploitsApi extends BaseAPI {
    /**
     * API endpoint for re-collecting exploit data.  **NOTE:** Currently for CISA data only, which is very small and collection is fast.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExploitsApi
     */
    public exploitsApiV1CollectUpdate(options?: AxiosRequestConfig) {
        return ExploitsApiFp(this.configuration).exploitsApiV1CollectUpdate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint for getting simple exploits information mapped to impacted CVEs.  The Insights Vulnerability application needs this format.  Format of results: ``` {   \"page_size\": <Number of CVEs on the page>,   \"cves\": {     \"CVE-2222-0001\": [<List of exploits>],     \"CVE-2222-0002\": [<List of exploits>],     ...   }, } ```
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExploitsApi
     */
    public exploitsApiV1CveMapRetrieve(options?: AxiosRequestConfig) {
        return ExploitsApiFp(this.configuration).exploitsApiV1CveMapRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint for getting list of Red Hat relevant CVEs with their EPSS score.
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExploitsApi
     */
    public exploitsApiV1EpssList(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return ExploitsApiFp(this.configuration).exploitsApiV1EpssList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Flaw, affect, and tracker data for Exploits
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExploitsApi
     */
    public exploitsApiV1FlawDataList(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return ExploitsApiFp(this.configuration).exploitsApiV1FlawDataList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export only the data required to generate the exploits report
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExploitsApi
     */
    public exploitsApiV1ReportDataList(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return ExploitsApiFp(this.configuration).exploitsApiV1ReportDataList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint for getting date based report for Incident Response.  Format of results: ``` {   \"cutoff_date\": <Date>,   \"evaluated_cves\": <Number of new CVEs with exploits>,   \"action_required\": [<List of affects requiring action>],   \"no_action\": [<List of CVEs not requiring action with reason>],   \"not_relevant\": [<List of CVEs which are not in the database with reason>], } ```  **NOTE:** No pagination is performed on this endpoint as data is limited by date and is expected           to be fairly small. Also, because data is broken into three categories it is not           exactly obvious how to create pages.
     * @param {string} date Date format: YYYY-MM-DD
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExploitsApi
     */
    public exploitsApiV1ReportDateRetrieve(date: string, options?: AxiosRequestConfig) {
        return ExploitsApiFp(this.configuration).exploitsApiV1ReportDateRetrieve(date, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint for getting a report of all CVEs with exploit and their status for Incident Response.  Format of results: ``` {    \"page_size\": <Number of CVEs on the page>,    \"explanations\": [<List of CVEs with exploit together with current status explanation>], } ```
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExploitsApi
     */
    public exploitsApiV1ReportExplanationsRetrieve(options?: AxiosRequestConfig) {
        return ExploitsApiFp(this.configuration).exploitsApiV1ReportExplanationsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint for getting a report of pending actions for Incident Response.  Format of results: ``` {   \"pending_actions\": [<List of affects requiring action>],   \"pending_actions_count\": <Number of affects requiring action>, } ```  **NOTE:** No pagination is performed on this endpoint as it is expected that the size of           the list of pending actions will be mostly stable. Also, the paging cannot be done on           the query level, as additional analysis of every exploit is required before a decision           to include it in this report is done.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExploitsApi
     */
    public exploitsApiV1ReportPendingRetrieve(options?: AxiosRequestConfig) {
        return ExploitsApiFp(this.configuration).exploitsApiV1ReportPendingRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint for getting basic information about exploits in the database.  **NOTE:** Everyone is allowed to see basic information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExploitsApi
     */
    public exploitsApiV1StatusRetrieve(options?: AxiosRequestConfig) {
        return ExploitsApiFp(this.configuration).exploitsApiV1StatusRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API endpoint for getting a list of all supported products.
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExploitsApi
     */
    public exploitsApiV1SupportedProductsList(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return ExploitsApiFp(this.configuration).exploitsApiV1SupportedProductsList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OsidbApi - axios parameter creator
 * @export
 */
export const OsidbApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Bulk create endpoint. Expects a list of dict Affect objects.
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {Array<AffectPost>} affectPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsBulkCreate: async (bugzillaApiKey: string, affectPost: Array<AffectPost>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bugzillaApiKey' is not null or undefined
            assertParamExists('osidbApiV1AffectsBulkCreate', 'bugzillaApiKey', bugzillaApiKey)
            // verify required parameter 'affectPost' is not null or undefined
            assertParamExists('osidbApiV1AffectsBulkCreate', 'affectPost', affectPost)
            const localVarPath = `/osidb/api/v1/affects/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (bugzillaApiKey != null) {
                localVarHeaderParameter['Bugzilla-Api-Key'] = String(bugzillaApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(affectPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bulk delete endpoint. Expects a list of Affect uuids.
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsBulkDestroy: async (bugzillaApiKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bugzillaApiKey' is not null or undefined
            assertParamExists('osidbApiV1AffectsBulkDestroy', 'bugzillaApiKey', bugzillaApiKey)
            const localVarPath = `/osidb/api/v1/affects/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (bugzillaApiKey != null) {
                localVarHeaderParameter['Bugzilla-Api-Key'] = String(bugzillaApiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bulk update endpoint. Expects a list of dict Affect objects.
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {Array<AffectBulkPut>} affectBulkPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsBulkUpdate: async (bugzillaApiKey: string, jiraApiKey: string, affectBulkPut: Array<AffectBulkPut>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bugzillaApiKey' is not null or undefined
            assertParamExists('osidbApiV1AffectsBulkUpdate', 'bugzillaApiKey', bugzillaApiKey)
            // verify required parameter 'jiraApiKey' is not null or undefined
            assertParamExists('osidbApiV1AffectsBulkUpdate', 'jiraApiKey', jiraApiKey)
            // verify required parameter 'affectBulkPut' is not null or undefined
            assertParamExists('osidbApiV1AffectsBulkUpdate', 'affectBulkPut', affectBulkPut)
            const localVarPath = `/osidb/api/v1/affects/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (bugzillaApiKey != null) {
                localVarHeaderParameter['Bugzilla-Api-Key'] = String(bugzillaApiKey);
            }

            if (jiraApiKey != null) {
                localVarHeaderParameter['Jira-Api-Key'] = String(jiraApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(affectBulkPut, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {AffectPost} affectPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsCreate: async (bugzillaApiKey: string, jiraApiKey: string, affectPost: AffectPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bugzillaApiKey' is not null or undefined
            assertParamExists('osidbApiV1AffectsCreate', 'bugzillaApiKey', bugzillaApiKey)
            // verify required parameter 'jiraApiKey' is not null or undefined
            assertParamExists('osidbApiV1AffectsCreate', 'jiraApiKey', jiraApiKey)
            // verify required parameter 'affectPost' is not null or undefined
            assertParamExists('osidbApiV1AffectsCreate', 'affectPost', affectPost)
            const localVarPath = `/osidb/api/v1/affects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (bugzillaApiKey != null) {
                localVarHeaderParameter['Bugzilla-Api-Key'] = String(bugzillaApiKey);
            }

            if (jiraApiKey != null) {
                localVarHeaderParameter['Jira-Api-Key'] = String(jiraApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(affectPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} affectId 
         * @param {AffectCVSSPost} affectCVSSPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsCvssScoresCreate: async (bugzillaApiKey: string, affectId: string, affectCVSSPost: AffectCVSSPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bugzillaApiKey' is not null or undefined
            assertParamExists('osidbApiV1AffectsCvssScoresCreate', 'bugzillaApiKey', bugzillaApiKey)
            // verify required parameter 'affectId' is not null or undefined
            assertParamExists('osidbApiV1AffectsCvssScoresCreate', 'affectId', affectId)
            // verify required parameter 'affectCVSSPost' is not null or undefined
            assertParamExists('osidbApiV1AffectsCvssScoresCreate', 'affectCVSSPost', affectCVSSPost)
            const localVarPath = `/osidb/api/v1/affects/{affect_id}/cvss_scores`
                .replace(`{${"affect_id"}}`, encodeURIComponent(String(affectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (bugzillaApiKey != null) {
                localVarHeaderParameter['Bugzilla-Api-Key'] = String(bugzillaApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(affectCVSSPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Destroy the instance and proxy the delete to Bugzilla.
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} affectId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsCvssScoresDestroy: async (bugzillaApiKey: string, affectId: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bugzillaApiKey' is not null or undefined
            assertParamExists('osidbApiV1AffectsCvssScoresDestroy', 'bugzillaApiKey', bugzillaApiKey)
            // verify required parameter 'affectId' is not null or undefined
            assertParamExists('osidbApiV1AffectsCvssScoresDestroy', 'affectId', affectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osidbApiV1AffectsCvssScoresDestroy', 'id', id)
            const localVarPath = `/osidb/api/v1/affects/{affect_id}/cvss_scores/{id}`
                .replace(`{${"affect_id"}}`, encodeURIComponent(String(affectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (bugzillaApiKey != null) {
                localVarHeaderParameter['Bugzilla-Api-Key'] = String(bugzillaApiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affectId 
         * @param {string} [comment] 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {string} [cvssVersion] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {'NIST' | 'OSV' | 'RH'} [issuer] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {number} [score] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {string} [vector] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsCvssScoresList: async (affectId: string, comment?: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, cvssVersion?: string, excludeFields?: Array<string>, includeFields?: Array<string>, issuer?: 'NIST' | 'OSV' | 'RH', limit?: number, offset?: number, score?: number, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, vector?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affectId' is not null or undefined
            assertParamExists('osidbApiV1AffectsCvssScoresList', 'affectId', affectId)
            const localVarPath = `/osidb/api/v1/affects/{affect_id}/cvss_scores`
                .replace(`{${"affect_id"}}`, encodeURIComponent(String(affectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (comment !== undefined) {
                localVarQueryParameter['comment'] = comment;
            }

            if (createdDt !== undefined) {
                localVarQueryParameter['created_dt'] = (createdDt as any instanceof Date) ?
                    (createdDt as any).toISOString() :
                    createdDt;
            }

            if (createdDtDate !== undefined) {
                localVarQueryParameter['created_dt__date'] = (createdDtDate as any instanceof Date) ?
                    (createdDtDate as any).toISOString().substr(0,10) :
                    createdDtDate;
            }

            if (createdDtDateGte !== undefined) {
                localVarQueryParameter['created_dt__date__gte'] = (createdDtDateGte as any instanceof Date) ?
                    (createdDtDateGte as any).toISOString().substr(0,10) :
                    createdDtDateGte;
            }

            if (createdDtDateLte !== undefined) {
                localVarQueryParameter['created_dt__date__lte'] = (createdDtDateLte as any instanceof Date) ?
                    (createdDtDateLte as any).toISOString().substr(0,10) :
                    createdDtDateLte;
            }

            if (createdDtGt !== undefined) {
                localVarQueryParameter['created_dt__gt'] = (createdDtGt as any instanceof Date) ?
                    (createdDtGt as any).toISOString() :
                    createdDtGt;
            }

            if (createdDtGte !== undefined) {
                localVarQueryParameter['created_dt__gte'] = (createdDtGte as any instanceof Date) ?
                    (createdDtGte as any).toISOString() :
                    createdDtGte;
            }

            if (createdDtLt !== undefined) {
                localVarQueryParameter['created_dt__lt'] = (createdDtLt as any instanceof Date) ?
                    (createdDtLt as any).toISOString() :
                    createdDtLt;
            }

            if (createdDtLte !== undefined) {
                localVarQueryParameter['created_dt__lte'] = (createdDtLte as any instanceof Date) ?
                    (createdDtLte as any).toISOString() :
                    createdDtLte;
            }

            if (cvssVersion !== undefined) {
                localVarQueryParameter['cvss_version'] = cvssVersion;
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }

            if (issuer !== undefined) {
                localVarQueryParameter['issuer'] = issuer;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (score !== undefined) {
                localVarQueryParameter['score'] = score;
            }

            if (updatedDt !== undefined) {
                localVarQueryParameter['updated_dt'] = (updatedDt as any instanceof Date) ?
                    (updatedDt as any).toISOString() :
                    updatedDt;
            }

            if (updatedDtDate !== undefined) {
                localVarQueryParameter['updated_dt__date'] = (updatedDtDate as any instanceof Date) ?
                    (updatedDtDate as any).toISOString().substr(0,10) :
                    updatedDtDate;
            }

            if (updatedDtDateGte !== undefined) {
                localVarQueryParameter['updated_dt__date__gte'] = (updatedDtDateGte as any instanceof Date) ?
                    (updatedDtDateGte as any).toISOString().substr(0,10) :
                    updatedDtDateGte;
            }

            if (updatedDtDateLte !== undefined) {
                localVarQueryParameter['updated_dt__date__lte'] = (updatedDtDateLte as any instanceof Date) ?
                    (updatedDtDateLte as any).toISOString().substr(0,10) :
                    updatedDtDateLte;
            }

            if (updatedDtGt !== undefined) {
                localVarQueryParameter['updated_dt__gt'] = (updatedDtGt as any instanceof Date) ?
                    (updatedDtGt as any).toISOString() :
                    updatedDtGt;
            }

            if (updatedDtGte !== undefined) {
                localVarQueryParameter['updated_dt__gte'] = (updatedDtGte as any instanceof Date) ?
                    (updatedDtGte as any).toISOString() :
                    updatedDtGte;
            }

            if (updatedDtLt !== undefined) {
                localVarQueryParameter['updated_dt__lt'] = (updatedDtLt as any instanceof Date) ?
                    (updatedDtLt as any).toISOString() :
                    updatedDtLt;
            }

            if (updatedDtLte !== undefined) {
                localVarQueryParameter['updated_dt__lte'] = (updatedDtLte as any instanceof Date) ?
                    (updatedDtLte as any).toISOString() :
                    updatedDtLte;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (vector !== undefined) {
                localVarQueryParameter['vector'] = vector;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affectId 
         * @param {string} id 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsCvssScoresRetrieve: async (affectId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affectId' is not null or undefined
            assertParamExists('osidbApiV1AffectsCvssScoresRetrieve', 'affectId', affectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osidbApiV1AffectsCvssScoresRetrieve', 'id', id)
            const localVarPath = `/osidb/api/v1/affects/{affect_id}/cvss_scores/{id}`
                .replace(`{${"affect_id"}}`, encodeURIComponent(String(affectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} affectId 
         * @param {string} id 
         * @param {AffectCVSSPut} affectCVSSPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsCvssScoresUpdate: async (bugzillaApiKey: string, affectId: string, id: string, affectCVSSPut: AffectCVSSPut, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bugzillaApiKey' is not null or undefined
            assertParamExists('osidbApiV1AffectsCvssScoresUpdate', 'bugzillaApiKey', bugzillaApiKey)
            // verify required parameter 'affectId' is not null or undefined
            assertParamExists('osidbApiV1AffectsCvssScoresUpdate', 'affectId', affectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osidbApiV1AffectsCvssScoresUpdate', 'id', id)
            // verify required parameter 'affectCVSSPut' is not null or undefined
            assertParamExists('osidbApiV1AffectsCvssScoresUpdate', 'affectCVSSPut', affectCVSSPut)
            const localVarPath = `/osidb/api/v1/affects/{affect_id}/cvss_scores/{id}`
                .replace(`{${"affect_id"}}`, encodeURIComponent(String(affectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (bugzillaApiKey != null) {
                localVarHeaderParameter['Bugzilla-Api-Key'] = String(bugzillaApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(affectCVSSPut, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Destroy the instance and proxy the delete to Bugzilla
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} uuid A UUID string identifying this Affect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsDestroy: async (bugzillaApiKey: string, uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bugzillaApiKey' is not null or undefined
            assertParamExists('osidbApiV1AffectsDestroy', 'bugzillaApiKey', bugzillaApiKey)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('osidbApiV1AffectsDestroy', 'uuid', uuid)
            const localVarPath = `/osidb/api/v1/affects/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (bugzillaApiKey != null) {
                localVarHeaderParameter['Bugzilla-Api-Key'] = String(bugzillaApiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {'' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED'} [affectedness] 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {string} [cvssScoresComment] 
         * @param {string} [cvssScoresCreatedDt] 
         * @param {string} [cvssScoresCreatedDtDate] 
         * @param {string} [cvssScoresCreatedDtDateGte] 
         * @param {string} [cvssScoresCreatedDtDateLte] 
         * @param {string} [cvssScoresCreatedDtGt] 
         * @param {string} [cvssScoresCreatedDtGte] 
         * @param {string} [cvssScoresCreatedDtLt] 
         * @param {string} [cvssScoresCreatedDtLte] 
         * @param {string} [cvssScoresCvssVersion] 
         * @param {'NIST' | 'OSV' | 'RH'} [cvssScoresIssuer] 
         * @param {number} [cvssScoresScore] 
         * @param {string} [cvssScoresUpdatedDt] 
         * @param {string} [cvssScoresUpdatedDtDate] 
         * @param {string} [cvssScoresUpdatedDtDateGte] 
         * @param {string} [cvssScoresUpdatedDtDateLte] 
         * @param {string} [cvssScoresUpdatedDtGt] 
         * @param {string} [cvssScoresUpdatedDtGte] 
         * @param {string} [cvssScoresUpdatedDtLt] 
         * @param {string} [cvssScoresUpdatedDtLte] 
         * @param {string} [cvssScoresUuid] 
         * @param {string} [cvssScoresVector] 
         * @param {boolean} [embargoed] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [flawComponents] Multiple values may be separated by commas.
         * @param {string} [flawCreatedDt] 
         * @param {string} [flawCreatedDtDate] 
         * @param {string} [flawCreatedDtDateGte] 
         * @param {string} [flawCreatedDtDateLte] 
         * @param {string} [flawCreatedDtGt] 
         * @param {string} [flawCreatedDtGte] 
         * @param {string} [flawCreatedDtLt] 
         * @param {string} [flawCreatedDtLte] 
         * @param {string} [flawCveId] 
         * @param {string} [flawCweId] 
         * @param {boolean} [flawEmbargoed] 
         * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [flawImpact] 
         * @param {string} [flawReportedDt] 
         * @param {string} [flawReportedDtDate] 
         * @param {string} [flawReportedDtDateGte] 
         * @param {string} [flawReportedDtDateLte] 
         * @param {string} [flawReportedDtGt] 
         * @param {string} [flawReportedDtGte] 
         * @param {string} [flawReportedDtLt] 
         * @param {string} [flawReportedDtLte] 
         * @param {'' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'NVD' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'OSV' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF'} [flawSource] 
         * @param {string} [flawUnembargoDt] 
         * @param {string} [flawUpdatedDt] 
         * @param {string} [flawUpdatedDtDate] 
         * @param {string} [flawUpdatedDtDateGte] 
         * @param {string} [flawUpdatedDtDateLte] 
         * @param {string} [flawUpdatedDtGt] 
         * @param {string} [flawUpdatedDtGte] 
         * @param {string} [flawUpdatedDtLt] 
         * @param {string} [flawUpdatedDtLte] 
         * @param {string} [flawUuid] 
         * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [impact] 
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {Array<'-affectedness' | '-created_dt' | '-cvss_scores__comment' | '-cvss_scores__created_dt' | '-cvss_scores__cvss_version' | '-cvss_scores__issuer' | '-cvss_scores__score' | '-cvss_scores__updated_dt' | '-cvss_scores__uuid' | '-cvss_scores__vector' | '-embargoed' | '-flaw__components' | '-flaw__created_dt' | '-flaw__cve_id' | '-flaw__cwe_id' | '-flaw__embargoed' | '-flaw__impact' | '-flaw__reported_dt' | '-flaw__source' | '-flaw__unembargo_dt' | '-flaw__updated_dt' | '-flaw__uuid' | '-impact' | '-ps_component' | '-ps_module' | '-resolution' | '-trackers__created_dt' | '-trackers__embargoed' | '-trackers__external_system_id' | '-trackers__ps_update_stream' | '-trackers__resolution' | '-trackers__status' | '-trackers__type' | '-trackers__updated_dt' | '-trackers__uuid' | '-updated_dt' | '-uuid' | 'affectedness' | 'created_dt' | 'cvss_scores__comment' | 'cvss_scores__created_dt' | 'cvss_scores__cvss_version' | 'cvss_scores__issuer' | 'cvss_scores__score' | 'cvss_scores__updated_dt' | 'cvss_scores__uuid' | 'cvss_scores__vector' | 'embargoed' | 'flaw__components' | 'flaw__created_dt' | 'flaw__cve_id' | 'flaw__cwe_id' | 'flaw__embargoed' | 'flaw__impact' | 'flaw__reported_dt' | 'flaw__source' | 'flaw__unembargo_dt' | 'flaw__updated_dt' | 'flaw__uuid' | 'impact' | 'ps_component' | 'ps_module' | 'resolution' | 'trackers__created_dt' | 'trackers__embargoed' | 'trackers__external_system_id' | 'trackers__ps_update_stream' | 'trackers__resolution' | 'trackers__status' | 'trackers__type' | 'trackers__updated_dt' | 'trackers__uuid' | 'updated_dt' | 'uuid'>} [order] Ordering
         * @param {string} [psComponent] 
         * @param {string} [psModule] 
         * @param {'' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT'} [resolution] 
         * @param {string} [trackersCreatedDt] 
         * @param {string} [trackersCreatedDtDate] 
         * @param {string} [trackersCreatedDtDateGte] 
         * @param {string} [trackersCreatedDtDateLte] 
         * @param {string} [trackersCreatedDtGt] 
         * @param {string} [trackersCreatedDtGte] 
         * @param {string} [trackersCreatedDtLt] 
         * @param {string} [trackersCreatedDtLte] 
         * @param {boolean} [trackersEmbargoed] 
         * @param {string} [trackersExternalSystemId] 
         * @param {string} [trackersPsUpdateStream] 
         * @param {string} [trackersResolution] 
         * @param {string} [trackersStatus] 
         * @param {'BUGZILLA' | 'JIRA'} [trackersType] 
         * @param {string} [trackersUpdatedDt] 
         * @param {string} [trackersUpdatedDtDate] 
         * @param {string} [trackersUpdatedDtDateGte] 
         * @param {string} [trackersUpdatedDtDateLte] 
         * @param {string} [trackersUpdatedDtGt] 
         * @param {string} [trackersUpdatedDtGte] 
         * @param {string} [trackersUpdatedDtLt] 
         * @param {string} [trackersUpdatedDtLte] 
         * @param {string} [trackersUuid] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsList: async (affectedness?: '' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED', createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, cvssScoresComment?: string, cvssScoresCreatedDt?: string, cvssScoresCreatedDtDate?: string, cvssScoresCreatedDtDateGte?: string, cvssScoresCreatedDtDateLte?: string, cvssScoresCreatedDtGt?: string, cvssScoresCreatedDtGte?: string, cvssScoresCreatedDtLt?: string, cvssScoresCreatedDtLte?: string, cvssScoresCvssVersion?: string, cvssScoresIssuer?: 'NIST' | 'OSV' | 'RH', cvssScoresScore?: number, cvssScoresUpdatedDt?: string, cvssScoresUpdatedDtDate?: string, cvssScoresUpdatedDtDateGte?: string, cvssScoresUpdatedDtDateLte?: string, cvssScoresUpdatedDtGt?: string, cvssScoresUpdatedDtGte?: string, cvssScoresUpdatedDtLt?: string, cvssScoresUpdatedDtLte?: string, cvssScoresUuid?: string, cvssScoresVector?: string, embargoed?: boolean, excludeFields?: Array<string>, flawComponents?: Array<string>, flawCreatedDt?: string, flawCreatedDtDate?: string, flawCreatedDtDateGte?: string, flawCreatedDtDateLte?: string, flawCreatedDtGt?: string, flawCreatedDtGte?: string, flawCreatedDtLt?: string, flawCreatedDtLte?: string, flawCveId?: string, flawCweId?: string, flawEmbargoed?: boolean, flawImpact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', flawReportedDt?: string, flawReportedDtDate?: string, flawReportedDtDateGte?: string, flawReportedDtDateLte?: string, flawReportedDtGt?: string, flawReportedDtGte?: string, flawReportedDtLt?: string, flawReportedDtLte?: string, flawSource?: '' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'NVD' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'OSV' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF', flawUnembargoDt?: string, flawUpdatedDt?: string, flawUpdatedDtDate?: string, flawUpdatedDtDateGte?: string, flawUpdatedDtDateLte?: string, flawUpdatedDtGt?: string, flawUpdatedDtGte?: string, flawUpdatedDtLt?: string, flawUpdatedDtLte?: string, flawUuid?: string, impact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', includeFields?: Array<string>, includeMetaAttr?: Array<string>, limit?: number, offset?: number, order?: Array<'-affectedness' | '-created_dt' | '-cvss_scores__comment' | '-cvss_scores__created_dt' | '-cvss_scores__cvss_version' | '-cvss_scores__issuer' | '-cvss_scores__score' | '-cvss_scores__updated_dt' | '-cvss_scores__uuid' | '-cvss_scores__vector' | '-embargoed' | '-flaw__components' | '-flaw__created_dt' | '-flaw__cve_id' | '-flaw__cwe_id' | '-flaw__embargoed' | '-flaw__impact' | '-flaw__reported_dt' | '-flaw__source' | '-flaw__unembargo_dt' | '-flaw__updated_dt' | '-flaw__uuid' | '-impact' | '-ps_component' | '-ps_module' | '-resolution' | '-trackers__created_dt' | '-trackers__embargoed' | '-trackers__external_system_id' | '-trackers__ps_update_stream' | '-trackers__resolution' | '-trackers__status' | '-trackers__type' | '-trackers__updated_dt' | '-trackers__uuid' | '-updated_dt' | '-uuid' | 'affectedness' | 'created_dt' | 'cvss_scores__comment' | 'cvss_scores__created_dt' | 'cvss_scores__cvss_version' | 'cvss_scores__issuer' | 'cvss_scores__score' | 'cvss_scores__updated_dt' | 'cvss_scores__uuid' | 'cvss_scores__vector' | 'embargoed' | 'flaw__components' | 'flaw__created_dt' | 'flaw__cve_id' | 'flaw__cwe_id' | 'flaw__embargoed' | 'flaw__impact' | 'flaw__reported_dt' | 'flaw__source' | 'flaw__unembargo_dt' | 'flaw__updated_dt' | 'flaw__uuid' | 'impact' | 'ps_component' | 'ps_module' | 'resolution' | 'trackers__created_dt' | 'trackers__embargoed' | 'trackers__external_system_id' | 'trackers__ps_update_stream' | 'trackers__resolution' | 'trackers__status' | 'trackers__type' | 'trackers__updated_dt' | 'trackers__uuid' | 'updated_dt' | 'uuid'>, psComponent?: string, psModule?: string, resolution?: '' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT', trackersCreatedDt?: string, trackersCreatedDtDate?: string, trackersCreatedDtDateGte?: string, trackersCreatedDtDateLte?: string, trackersCreatedDtGt?: string, trackersCreatedDtGte?: string, trackersCreatedDtLt?: string, trackersCreatedDtLte?: string, trackersEmbargoed?: boolean, trackersExternalSystemId?: string, trackersPsUpdateStream?: string, trackersResolution?: string, trackersStatus?: string, trackersType?: 'BUGZILLA' | 'JIRA', trackersUpdatedDt?: string, trackersUpdatedDtDate?: string, trackersUpdatedDtDateGte?: string, trackersUpdatedDtDateLte?: string, trackersUpdatedDtGt?: string, trackersUpdatedDtGte?: string, trackersUpdatedDtLt?: string, trackersUpdatedDtLte?: string, trackersUuid?: string, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/osidb/api/v1/affects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (affectedness !== undefined) {
                localVarQueryParameter['affectedness'] = affectedness;
            }

            if (createdDt !== undefined) {
                localVarQueryParameter['created_dt'] = (createdDt as any instanceof Date) ?
                    (createdDt as any).toISOString() :
                    createdDt;
            }

            if (createdDtDate !== undefined) {
                localVarQueryParameter['created_dt__date'] = (createdDtDate as any instanceof Date) ?
                    (createdDtDate as any).toISOString().substr(0,10) :
                    createdDtDate;
            }

            if (createdDtDateGte !== undefined) {
                localVarQueryParameter['created_dt__date__gte'] = (createdDtDateGte as any instanceof Date) ?
                    (createdDtDateGte as any).toISOString().substr(0,10) :
                    createdDtDateGte;
            }

            if (createdDtDateLte !== undefined) {
                localVarQueryParameter['created_dt__date__lte'] = (createdDtDateLte as any instanceof Date) ?
                    (createdDtDateLte as any).toISOString().substr(0,10) :
                    createdDtDateLte;
            }

            if (createdDtGt !== undefined) {
                localVarQueryParameter['created_dt__gt'] = (createdDtGt as any instanceof Date) ?
                    (createdDtGt as any).toISOString() :
                    createdDtGt;
            }

            if (createdDtGte !== undefined) {
                localVarQueryParameter['created_dt__gte'] = (createdDtGte as any instanceof Date) ?
                    (createdDtGte as any).toISOString() :
                    createdDtGte;
            }

            if (createdDtLt !== undefined) {
                localVarQueryParameter['created_dt__lt'] = (createdDtLt as any instanceof Date) ?
                    (createdDtLt as any).toISOString() :
                    createdDtLt;
            }

            if (createdDtLte !== undefined) {
                localVarQueryParameter['created_dt__lte'] = (createdDtLte as any instanceof Date) ?
                    (createdDtLte as any).toISOString() :
                    createdDtLte;
            }

            if (cvssScoresComment !== undefined) {
                localVarQueryParameter['cvss_scores__comment'] = cvssScoresComment;
            }

            if (cvssScoresCreatedDt !== undefined) {
                localVarQueryParameter['cvss_scores__created_dt'] = (cvssScoresCreatedDt as any instanceof Date) ?
                    (cvssScoresCreatedDt as any).toISOString() :
                    cvssScoresCreatedDt;
            }

            if (cvssScoresCreatedDtDate !== undefined) {
                localVarQueryParameter['cvss_scores__created_dt__date'] = (cvssScoresCreatedDtDate as any instanceof Date) ?
                    (cvssScoresCreatedDtDate as any).toISOString().substr(0,10) :
                    cvssScoresCreatedDtDate;
            }

            if (cvssScoresCreatedDtDateGte !== undefined) {
                localVarQueryParameter['cvss_scores__created_dt__date__gte'] = (cvssScoresCreatedDtDateGte as any instanceof Date) ?
                    (cvssScoresCreatedDtDateGte as any).toISOString().substr(0,10) :
                    cvssScoresCreatedDtDateGte;
            }

            if (cvssScoresCreatedDtDateLte !== undefined) {
                localVarQueryParameter['cvss_scores__created_dt__date__lte'] = (cvssScoresCreatedDtDateLte as any instanceof Date) ?
                    (cvssScoresCreatedDtDateLte as any).toISOString().substr(0,10) :
                    cvssScoresCreatedDtDateLte;
            }

            if (cvssScoresCreatedDtGt !== undefined) {
                localVarQueryParameter['cvss_scores__created_dt__gt'] = (cvssScoresCreatedDtGt as any instanceof Date) ?
                    (cvssScoresCreatedDtGt as any).toISOString() :
                    cvssScoresCreatedDtGt;
            }

            if (cvssScoresCreatedDtGte !== undefined) {
                localVarQueryParameter['cvss_scores__created_dt__gte'] = (cvssScoresCreatedDtGte as any instanceof Date) ?
                    (cvssScoresCreatedDtGte as any).toISOString() :
                    cvssScoresCreatedDtGte;
            }

            if (cvssScoresCreatedDtLt !== undefined) {
                localVarQueryParameter['cvss_scores__created_dt__lt'] = (cvssScoresCreatedDtLt as any instanceof Date) ?
                    (cvssScoresCreatedDtLt as any).toISOString() :
                    cvssScoresCreatedDtLt;
            }

            if (cvssScoresCreatedDtLte !== undefined) {
                localVarQueryParameter['cvss_scores__created_dt__lte'] = (cvssScoresCreatedDtLte as any instanceof Date) ?
                    (cvssScoresCreatedDtLte as any).toISOString() :
                    cvssScoresCreatedDtLte;
            }

            if (cvssScoresCvssVersion !== undefined) {
                localVarQueryParameter['cvss_scores__cvss_version'] = cvssScoresCvssVersion;
            }

            if (cvssScoresIssuer !== undefined) {
                localVarQueryParameter['cvss_scores__issuer'] = cvssScoresIssuer;
            }

            if (cvssScoresScore !== undefined) {
                localVarQueryParameter['cvss_scores__score'] = cvssScoresScore;
            }

            if (cvssScoresUpdatedDt !== undefined) {
                localVarQueryParameter['cvss_scores__updated_dt'] = (cvssScoresUpdatedDt as any instanceof Date) ?
                    (cvssScoresUpdatedDt as any).toISOString() :
                    cvssScoresUpdatedDt;
            }

            if (cvssScoresUpdatedDtDate !== undefined) {
                localVarQueryParameter['cvss_scores__updated_dt__date'] = (cvssScoresUpdatedDtDate as any instanceof Date) ?
                    (cvssScoresUpdatedDtDate as any).toISOString().substr(0,10) :
                    cvssScoresUpdatedDtDate;
            }

            if (cvssScoresUpdatedDtDateGte !== undefined) {
                localVarQueryParameter['cvss_scores__updated_dt__date__gte'] = (cvssScoresUpdatedDtDateGte as any instanceof Date) ?
                    (cvssScoresUpdatedDtDateGte as any).toISOString().substr(0,10) :
                    cvssScoresUpdatedDtDateGte;
            }

            if (cvssScoresUpdatedDtDateLte !== undefined) {
                localVarQueryParameter['cvss_scores__updated_dt__date__lte'] = (cvssScoresUpdatedDtDateLte as any instanceof Date) ?
                    (cvssScoresUpdatedDtDateLte as any).toISOString().substr(0,10) :
                    cvssScoresUpdatedDtDateLte;
            }

            if (cvssScoresUpdatedDtGt !== undefined) {
                localVarQueryParameter['cvss_scores__updated_dt__gt'] = (cvssScoresUpdatedDtGt as any instanceof Date) ?
                    (cvssScoresUpdatedDtGt as any).toISOString() :
                    cvssScoresUpdatedDtGt;
            }

            if (cvssScoresUpdatedDtGte !== undefined) {
                localVarQueryParameter['cvss_scores__updated_dt__gte'] = (cvssScoresUpdatedDtGte as any instanceof Date) ?
                    (cvssScoresUpdatedDtGte as any).toISOString() :
                    cvssScoresUpdatedDtGte;
            }

            if (cvssScoresUpdatedDtLt !== undefined) {
                localVarQueryParameter['cvss_scores__updated_dt__lt'] = (cvssScoresUpdatedDtLt as any instanceof Date) ?
                    (cvssScoresUpdatedDtLt as any).toISOString() :
                    cvssScoresUpdatedDtLt;
            }

            if (cvssScoresUpdatedDtLte !== undefined) {
                localVarQueryParameter['cvss_scores__updated_dt__lte'] = (cvssScoresUpdatedDtLte as any instanceof Date) ?
                    (cvssScoresUpdatedDtLte as any).toISOString() :
                    cvssScoresUpdatedDtLte;
            }

            if (cvssScoresUuid !== undefined) {
                localVarQueryParameter['cvss_scores__uuid'] = cvssScoresUuid;
            }

            if (cvssScoresVector !== undefined) {
                localVarQueryParameter['cvss_scores__vector'] = cvssScoresVector;
            }

            if (embargoed !== undefined) {
                localVarQueryParameter['embargoed'] = embargoed;
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (flawComponents) {
                localVarQueryParameter['flaw__components'] = flawComponents.join(COLLECTION_FORMATS.csv);
            }

            if (flawCreatedDt !== undefined) {
                localVarQueryParameter['flaw__created_dt'] = (flawCreatedDt as any instanceof Date) ?
                    (flawCreatedDt as any).toISOString() :
                    flawCreatedDt;
            }

            if (flawCreatedDtDate !== undefined) {
                localVarQueryParameter['flaw__created_dt__date'] = (flawCreatedDtDate as any instanceof Date) ?
                    (flawCreatedDtDate as any).toISOString().substr(0,10) :
                    flawCreatedDtDate;
            }

            if (flawCreatedDtDateGte !== undefined) {
                localVarQueryParameter['flaw__created_dt__date__gte'] = (flawCreatedDtDateGte as any instanceof Date) ?
                    (flawCreatedDtDateGte as any).toISOString().substr(0,10) :
                    flawCreatedDtDateGte;
            }

            if (flawCreatedDtDateLte !== undefined) {
                localVarQueryParameter['flaw__created_dt__date__lte'] = (flawCreatedDtDateLte as any instanceof Date) ?
                    (flawCreatedDtDateLte as any).toISOString().substr(0,10) :
                    flawCreatedDtDateLte;
            }

            if (flawCreatedDtGt !== undefined) {
                localVarQueryParameter['flaw__created_dt__gt'] = (flawCreatedDtGt as any instanceof Date) ?
                    (flawCreatedDtGt as any).toISOString() :
                    flawCreatedDtGt;
            }

            if (flawCreatedDtGte !== undefined) {
                localVarQueryParameter['flaw__created_dt__gte'] = (flawCreatedDtGte as any instanceof Date) ?
                    (flawCreatedDtGte as any).toISOString() :
                    flawCreatedDtGte;
            }

            if (flawCreatedDtLt !== undefined) {
                localVarQueryParameter['flaw__created_dt__lt'] = (flawCreatedDtLt as any instanceof Date) ?
                    (flawCreatedDtLt as any).toISOString() :
                    flawCreatedDtLt;
            }

            if (flawCreatedDtLte !== undefined) {
                localVarQueryParameter['flaw__created_dt__lte'] = (flawCreatedDtLte as any instanceof Date) ?
                    (flawCreatedDtLte as any).toISOString() :
                    flawCreatedDtLte;
            }

            if (flawCveId !== undefined) {
                localVarQueryParameter['flaw__cve_id'] = flawCveId;
            }

            if (flawCweId !== undefined) {
                localVarQueryParameter['flaw__cwe_id'] = flawCweId;
            }

            if (flawEmbargoed !== undefined) {
                localVarQueryParameter['flaw__embargoed'] = flawEmbargoed;
            }

            if (flawImpact !== undefined) {
                localVarQueryParameter['flaw__impact'] = flawImpact;
            }

            if (flawReportedDt !== undefined) {
                localVarQueryParameter['flaw__reported_dt'] = (flawReportedDt as any instanceof Date) ?
                    (flawReportedDt as any).toISOString() :
                    flawReportedDt;
            }

            if (flawReportedDtDate !== undefined) {
                localVarQueryParameter['flaw__reported_dt__date'] = (flawReportedDtDate as any instanceof Date) ?
                    (flawReportedDtDate as any).toISOString().substr(0,10) :
                    flawReportedDtDate;
            }

            if (flawReportedDtDateGte !== undefined) {
                localVarQueryParameter['flaw__reported_dt__date__gte'] = (flawReportedDtDateGte as any instanceof Date) ?
                    (flawReportedDtDateGte as any).toISOString().substr(0,10) :
                    flawReportedDtDateGte;
            }

            if (flawReportedDtDateLte !== undefined) {
                localVarQueryParameter['flaw__reported_dt__date__lte'] = (flawReportedDtDateLte as any instanceof Date) ?
                    (flawReportedDtDateLte as any).toISOString().substr(0,10) :
                    flawReportedDtDateLte;
            }

            if (flawReportedDtGt !== undefined) {
                localVarQueryParameter['flaw__reported_dt__gt'] = (flawReportedDtGt as any instanceof Date) ?
                    (flawReportedDtGt as any).toISOString() :
                    flawReportedDtGt;
            }

            if (flawReportedDtGte !== undefined) {
                localVarQueryParameter['flaw__reported_dt__gte'] = (flawReportedDtGte as any instanceof Date) ?
                    (flawReportedDtGte as any).toISOString() :
                    flawReportedDtGte;
            }

            if (flawReportedDtLt !== undefined) {
                localVarQueryParameter['flaw__reported_dt__lt'] = (flawReportedDtLt as any instanceof Date) ?
                    (flawReportedDtLt as any).toISOString() :
                    flawReportedDtLt;
            }

            if (flawReportedDtLte !== undefined) {
                localVarQueryParameter['flaw__reported_dt__lte'] = (flawReportedDtLte as any instanceof Date) ?
                    (flawReportedDtLte as any).toISOString() :
                    flawReportedDtLte;
            }

            if (flawSource !== undefined) {
                localVarQueryParameter['flaw__source'] = flawSource;
            }

            if (flawUnembargoDt !== undefined) {
                localVarQueryParameter['flaw__unembargo_dt'] = (flawUnembargoDt as any instanceof Date) ?
                    (flawUnembargoDt as any).toISOString() :
                    flawUnembargoDt;
            }

            if (flawUpdatedDt !== undefined) {
                localVarQueryParameter['flaw__updated_dt'] = (flawUpdatedDt as any instanceof Date) ?
                    (flawUpdatedDt as any).toISOString() :
                    flawUpdatedDt;
            }

            if (flawUpdatedDtDate !== undefined) {
                localVarQueryParameter['flaw__updated_dt__date'] = (flawUpdatedDtDate as any instanceof Date) ?
                    (flawUpdatedDtDate as any).toISOString().substr(0,10) :
                    flawUpdatedDtDate;
            }

            if (flawUpdatedDtDateGte !== undefined) {
                localVarQueryParameter['flaw__updated_dt__date__gte'] = (flawUpdatedDtDateGte as any instanceof Date) ?
                    (flawUpdatedDtDateGte as any).toISOString().substr(0,10) :
                    flawUpdatedDtDateGte;
            }

            if (flawUpdatedDtDateLte !== undefined) {
                localVarQueryParameter['flaw__updated_dt__date__lte'] = (flawUpdatedDtDateLte as any instanceof Date) ?
                    (flawUpdatedDtDateLte as any).toISOString().substr(0,10) :
                    flawUpdatedDtDateLte;
            }

            if (flawUpdatedDtGt !== undefined) {
                localVarQueryParameter['flaw__updated_dt__gt'] = (flawUpdatedDtGt as any instanceof Date) ?
                    (flawUpdatedDtGt as any).toISOString() :
                    flawUpdatedDtGt;
            }

            if (flawUpdatedDtGte !== undefined) {
                localVarQueryParameter['flaw__updated_dt__gte'] = (flawUpdatedDtGte as any instanceof Date) ?
                    (flawUpdatedDtGte as any).toISOString() :
                    flawUpdatedDtGte;
            }

            if (flawUpdatedDtLt !== undefined) {
                localVarQueryParameter['flaw__updated_dt__lt'] = (flawUpdatedDtLt as any instanceof Date) ?
                    (flawUpdatedDtLt as any).toISOString() :
                    flawUpdatedDtLt;
            }

            if (flawUpdatedDtLte !== undefined) {
                localVarQueryParameter['flaw__updated_dt__lte'] = (flawUpdatedDtLte as any instanceof Date) ?
                    (flawUpdatedDtLte as any).toISOString() :
                    flawUpdatedDtLte;
            }

            if (flawUuid !== undefined) {
                localVarQueryParameter['flaw__uuid'] = flawUuid;
            }

            if (impact !== undefined) {
                localVarQueryParameter['impact'] = impact;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }

            if (includeMetaAttr) {
                localVarQueryParameter['include_meta_attr'] = includeMetaAttr;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (order) {
                localVarQueryParameter['order'] = order.join(COLLECTION_FORMATS.csv);
            }

            if (psComponent !== undefined) {
                localVarQueryParameter['ps_component'] = psComponent;
            }

            if (psModule !== undefined) {
                localVarQueryParameter['ps_module'] = psModule;
            }

            if (resolution !== undefined) {
                localVarQueryParameter['resolution'] = resolution;
            }

            if (trackersCreatedDt !== undefined) {
                localVarQueryParameter['trackers__created_dt'] = (trackersCreatedDt as any instanceof Date) ?
                    (trackersCreatedDt as any).toISOString() :
                    trackersCreatedDt;
            }

            if (trackersCreatedDtDate !== undefined) {
                localVarQueryParameter['trackers__created_dt__date'] = (trackersCreatedDtDate as any instanceof Date) ?
                    (trackersCreatedDtDate as any).toISOString().substr(0,10) :
                    trackersCreatedDtDate;
            }

            if (trackersCreatedDtDateGte !== undefined) {
                localVarQueryParameter['trackers__created_dt__date__gte'] = (trackersCreatedDtDateGte as any instanceof Date) ?
                    (trackersCreatedDtDateGte as any).toISOString().substr(0,10) :
                    trackersCreatedDtDateGte;
            }

            if (trackersCreatedDtDateLte !== undefined) {
                localVarQueryParameter['trackers__created_dt__date__lte'] = (trackersCreatedDtDateLte as any instanceof Date) ?
                    (trackersCreatedDtDateLte as any).toISOString().substr(0,10) :
                    trackersCreatedDtDateLte;
            }

            if (trackersCreatedDtGt !== undefined) {
                localVarQueryParameter['trackers__created_dt__gt'] = (trackersCreatedDtGt as any instanceof Date) ?
                    (trackersCreatedDtGt as any).toISOString() :
                    trackersCreatedDtGt;
            }

            if (trackersCreatedDtGte !== undefined) {
                localVarQueryParameter['trackers__created_dt__gte'] = (trackersCreatedDtGte as any instanceof Date) ?
                    (trackersCreatedDtGte as any).toISOString() :
                    trackersCreatedDtGte;
            }

            if (trackersCreatedDtLt !== undefined) {
                localVarQueryParameter['trackers__created_dt__lt'] = (trackersCreatedDtLt as any instanceof Date) ?
                    (trackersCreatedDtLt as any).toISOString() :
                    trackersCreatedDtLt;
            }

            if (trackersCreatedDtLte !== undefined) {
                localVarQueryParameter['trackers__created_dt__lte'] = (trackersCreatedDtLte as any instanceof Date) ?
                    (trackersCreatedDtLte as any).toISOString() :
                    trackersCreatedDtLte;
            }

            if (trackersEmbargoed !== undefined) {
                localVarQueryParameter['trackers__embargoed'] = trackersEmbargoed;
            }

            if (trackersExternalSystemId !== undefined) {
                localVarQueryParameter['trackers__external_system_id'] = trackersExternalSystemId;
            }

            if (trackersPsUpdateStream !== undefined) {
                localVarQueryParameter['trackers__ps_update_stream'] = trackersPsUpdateStream;
            }

            if (trackersResolution !== undefined) {
                localVarQueryParameter['trackers__resolution'] = trackersResolution;
            }

            if (trackersStatus !== undefined) {
                localVarQueryParameter['trackers__status'] = trackersStatus;
            }

            if (trackersType !== undefined) {
                localVarQueryParameter['trackers__type'] = trackersType;
            }

            if (trackersUpdatedDt !== undefined) {
                localVarQueryParameter['trackers__updated_dt'] = (trackersUpdatedDt as any instanceof Date) ?
                    (trackersUpdatedDt as any).toISOString() :
                    trackersUpdatedDt;
            }

            if (trackersUpdatedDtDate !== undefined) {
                localVarQueryParameter['trackers__updated_dt__date'] = (trackersUpdatedDtDate as any instanceof Date) ?
                    (trackersUpdatedDtDate as any).toISOString().substr(0,10) :
                    trackersUpdatedDtDate;
            }

            if (trackersUpdatedDtDateGte !== undefined) {
                localVarQueryParameter['trackers__updated_dt__date__gte'] = (trackersUpdatedDtDateGte as any instanceof Date) ?
                    (trackersUpdatedDtDateGte as any).toISOString().substr(0,10) :
                    trackersUpdatedDtDateGte;
            }

            if (trackersUpdatedDtDateLte !== undefined) {
                localVarQueryParameter['trackers__updated_dt__date__lte'] = (trackersUpdatedDtDateLte as any instanceof Date) ?
                    (trackersUpdatedDtDateLte as any).toISOString().substr(0,10) :
                    trackersUpdatedDtDateLte;
            }

            if (trackersUpdatedDtGt !== undefined) {
                localVarQueryParameter['trackers__updated_dt__gt'] = (trackersUpdatedDtGt as any instanceof Date) ?
                    (trackersUpdatedDtGt as any).toISOString() :
                    trackersUpdatedDtGt;
            }

            if (trackersUpdatedDtGte !== undefined) {
                localVarQueryParameter['trackers__updated_dt__gte'] = (trackersUpdatedDtGte as any instanceof Date) ?
                    (trackersUpdatedDtGte as any).toISOString() :
                    trackersUpdatedDtGte;
            }

            if (trackersUpdatedDtLt !== undefined) {
                localVarQueryParameter['trackers__updated_dt__lt'] = (trackersUpdatedDtLt as any instanceof Date) ?
                    (trackersUpdatedDtLt as any).toISOString() :
                    trackersUpdatedDtLt;
            }

            if (trackersUpdatedDtLte !== undefined) {
                localVarQueryParameter['trackers__updated_dt__lte'] = (trackersUpdatedDtLte as any instanceof Date) ?
                    (trackersUpdatedDtLte as any).toISOString() :
                    trackersUpdatedDtLte;
            }

            if (trackersUuid !== undefined) {
                localVarQueryParameter['trackers__uuid'] = trackersUuid;
            }

            if (updatedDt !== undefined) {
                localVarQueryParameter['updated_dt'] = (updatedDt as any instanceof Date) ?
                    (updatedDt as any).toISOString() :
                    updatedDt;
            }

            if (updatedDtDate !== undefined) {
                localVarQueryParameter['updated_dt__date'] = (updatedDtDate as any instanceof Date) ?
                    (updatedDtDate as any).toISOString().substr(0,10) :
                    updatedDtDate;
            }

            if (updatedDtDateGte !== undefined) {
                localVarQueryParameter['updated_dt__date__gte'] = (updatedDtDateGte as any instanceof Date) ?
                    (updatedDtDateGte as any).toISOString().substr(0,10) :
                    updatedDtDateGte;
            }

            if (updatedDtDateLte !== undefined) {
                localVarQueryParameter['updated_dt__date__lte'] = (updatedDtDateLte as any instanceof Date) ?
                    (updatedDtDateLte as any).toISOString().substr(0,10) :
                    updatedDtDateLte;
            }

            if (updatedDtGt !== undefined) {
                localVarQueryParameter['updated_dt__gt'] = (updatedDtGt as any instanceof Date) ?
                    (updatedDtGt as any).toISOString() :
                    updatedDtGt;
            }

            if (updatedDtGte !== undefined) {
                localVarQueryParameter['updated_dt__gte'] = (updatedDtGte as any instanceof Date) ?
                    (updatedDtGte as any).toISOString() :
                    updatedDtGte;
            }

            if (updatedDtLt !== undefined) {
                localVarQueryParameter['updated_dt__lt'] = (updatedDtLt as any instanceof Date) ?
                    (updatedDtLt as any).toISOString() :
                    updatedDtLt;
            }

            if (updatedDtLte !== undefined) {
                localVarQueryParameter['updated_dt__lte'] = (updatedDtLte as any instanceof Date) ?
                    (updatedDtLte as any).toISOString() :
                    updatedDtLte;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid A UUID string identifying this Affect.
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsRetrieve: async (uuid: string, excludeFields?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('osidbApiV1AffectsRetrieve', 'uuid', uuid)
            const localVarPath = `/osidb/api/v1/affects/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }

            if (includeMetaAttr) {
                localVarQueryParameter['include_meta_attr'] = includeMetaAttr;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {string} uuid A UUID string identifying this Affect.
         * @param {Affect} affect 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsUpdate: async (bugzillaApiKey: string, jiraApiKey: string, uuid: string, affect: Affect, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bugzillaApiKey' is not null or undefined
            assertParamExists('osidbApiV1AffectsUpdate', 'bugzillaApiKey', bugzillaApiKey)
            // verify required parameter 'jiraApiKey' is not null or undefined
            assertParamExists('osidbApiV1AffectsUpdate', 'jiraApiKey', jiraApiKey)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('osidbApiV1AffectsUpdate', 'uuid', uuid)
            // verify required parameter 'affect' is not null or undefined
            assertParamExists('osidbApiV1AffectsUpdate', 'affect', affect)
            const localVarPath = `/osidb/api/v1/affects/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (bugzillaApiKey != null) {
                localVarHeaderParameter['Bugzilla-Api-Key'] = String(bugzillaApiKey);
            }

            if (jiraApiKey != null) {
                localVarHeaderParameter['Jira-Api-Key'] = String(jiraApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(affect, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List existing alerts for all models.
         * @param {'ERROR' | 'WARNING'} [alertType] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] Retrieve only Alerts with the specified name, which is given by the model\&#39;s validation process.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {'affect' | 'affectcvss' | 'flaw' | 'flawacknowledgment' | 'flawcomment' | 'flawcvss' | 'flawreference' | 'package' | 'snippet' | 'tracker'} [parentModel] Retrieve only Alerts related to the specified model, e.g. flaw or affect.
         * @param {string} [parentUuid] Retrieve only Alerts related to a model with the given UUID.
         * @param {string} [uuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AlertsList: async (alertType?: 'ERROR' | 'WARNING', excludeFields?: Array<string>, includeFields?: Array<string>, limit?: number, name?: string, offset?: number, parentModel?: 'affect' | 'affectcvss' | 'flaw' | 'flawacknowledgment' | 'flawcomment' | 'flawcvss' | 'flawreference' | 'package' | 'snippet' | 'tracker', parentUuid?: string, uuid?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/osidb/api/v1/alerts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (alertType !== undefined) {
                localVarQueryParameter['alert_type'] = alertType;
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (parentModel !== undefined) {
                localVarQueryParameter['parent_model'] = parentModel;
            }

            if (parentUuid !== undefined) {
                localVarQueryParameter['parent_uuid'] = parentUuid;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid A UUID string identifying this alert.
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AlertsRetrieve: async (uuid: string, excludeFields?: Array<string>, includeFields?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('osidbApiV1AlertsRetrieve', 'uuid', uuid)
            const localVarPath = `/osidb/api/v1/alerts/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * basic view of audit history events
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [pghCreatedAt] 
         * @param {string} [pghLabel] 
         * @param {string} [pghObjModel] 
         * @param {string} [pghSlug] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AuditList: async (limit?: number, offset?: number, pghCreatedAt?: string, pghLabel?: string, pghObjModel?: string, pghSlug?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/osidb/api/v1/audit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (pghCreatedAt !== undefined) {
                localVarQueryParameter['pgh_created_at'] = (pghCreatedAt as any instanceof Date) ?
                    (pghCreatedAt as any).toISOString() :
                    pghCreatedAt;
            }

            if (pghLabel !== undefined) {
                localVarQueryParameter['pgh_label'] = pghLabel;
            }

            if (pghObjModel !== undefined) {
                localVarQueryParameter['pgh_obj_model'] = pghObjModel;
            }

            if (pghSlug !== undefined) {
                localVarQueryParameter['pgh_slug'] = pghSlug;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * basic view of audit history events
         * @param {string} pghSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AuditRetrieve: async (pghSlug: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pghSlug' is not null or undefined
            assertParamExists('osidbApiV1AuditRetrieve', 'pghSlug', pghSlug)
            const localVarPath = `/osidb/api/v1/audit/{pgh_slug}`
                .replace(`{${"pgh_slug"}}`, encodeURIComponent(String(pghSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * basic view of audit history events
         * @param {string} pghSlug 
         * @param {Audit} audit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AuditUpdate: async (pghSlug: string, audit: Audit, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pghSlug' is not null or undefined
            assertParamExists('osidbApiV1AuditUpdate', 'pghSlug', pghSlug)
            // verify required parameter 'audit' is not null or undefined
            assertParamExists('osidbApiV1AuditUpdate', 'audit', audit)
            const localVarPath = `/osidb/api/v1/audit/{pgh_slug}`
                .replace(`{${"pgh_slug"}}`, encodeURIComponent(String(pghSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(audit, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId 
         * @param {FlawAcknowledgmentPost} flawAcknowledgmentPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsAcknowledgmentsCreate: async (bugzillaApiKey: string, flawId: string, flawAcknowledgmentPost: FlawAcknowledgmentPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bugzillaApiKey' is not null or undefined
            assertParamExists('osidbApiV1FlawsAcknowledgmentsCreate', 'bugzillaApiKey', bugzillaApiKey)
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsAcknowledgmentsCreate', 'flawId', flawId)
            // verify required parameter 'flawAcknowledgmentPost' is not null or undefined
            assertParamExists('osidbApiV1FlawsAcknowledgmentsCreate', 'flawAcknowledgmentPost', flawAcknowledgmentPost)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/acknowledgments`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (bugzillaApiKey != null) {
                localVarHeaderParameter['Bugzilla-Api-Key'] = String(bugzillaApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flawAcknowledgmentPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Destroy the instance and proxy the delete to Bugzilla
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsAcknowledgmentsDestroy: async (bugzillaApiKey: string, flawId: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bugzillaApiKey' is not null or undefined
            assertParamExists('osidbApiV1FlawsAcknowledgmentsDestroy', 'bugzillaApiKey', bugzillaApiKey)
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsAcknowledgmentsDestroy', 'flawId', flawId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osidbApiV1FlawsAcknowledgmentsDestroy', 'id', id)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/acknowledgments/{id}`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (bugzillaApiKey != null) {
                localVarHeaderParameter['Bugzilla-Api-Key'] = String(bugzillaApiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} [affiliation] 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {boolean} [fromUpstream] 
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsAcknowledgmentsList: async (flawId: string, affiliation?: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, excludeFields?: Array<string>, fromUpstream?: boolean, includeFields?: Array<string>, limit?: number, name?: string, offset?: number, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsAcknowledgmentsList', 'flawId', flawId)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/acknowledgments`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (affiliation !== undefined) {
                localVarQueryParameter['affiliation'] = affiliation;
            }

            if (createdDt !== undefined) {
                localVarQueryParameter['created_dt'] = (createdDt as any instanceof Date) ?
                    (createdDt as any).toISOString() :
                    createdDt;
            }

            if (createdDtDate !== undefined) {
                localVarQueryParameter['created_dt__date'] = (createdDtDate as any instanceof Date) ?
                    (createdDtDate as any).toISOString().substr(0,10) :
                    createdDtDate;
            }

            if (createdDtDateGte !== undefined) {
                localVarQueryParameter['created_dt__date__gte'] = (createdDtDateGte as any instanceof Date) ?
                    (createdDtDateGte as any).toISOString().substr(0,10) :
                    createdDtDateGte;
            }

            if (createdDtDateLte !== undefined) {
                localVarQueryParameter['created_dt__date__lte'] = (createdDtDateLte as any instanceof Date) ?
                    (createdDtDateLte as any).toISOString().substr(0,10) :
                    createdDtDateLte;
            }

            if (createdDtGt !== undefined) {
                localVarQueryParameter['created_dt__gt'] = (createdDtGt as any instanceof Date) ?
                    (createdDtGt as any).toISOString() :
                    createdDtGt;
            }

            if (createdDtGte !== undefined) {
                localVarQueryParameter['created_dt__gte'] = (createdDtGte as any instanceof Date) ?
                    (createdDtGte as any).toISOString() :
                    createdDtGte;
            }

            if (createdDtLt !== undefined) {
                localVarQueryParameter['created_dt__lt'] = (createdDtLt as any instanceof Date) ?
                    (createdDtLt as any).toISOString() :
                    createdDtLt;
            }

            if (createdDtLte !== undefined) {
                localVarQueryParameter['created_dt__lte'] = (createdDtLte as any instanceof Date) ?
                    (createdDtLte as any).toISOString() :
                    createdDtLte;
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (fromUpstream !== undefined) {
                localVarQueryParameter['from_upstream'] = fromUpstream;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (updatedDt !== undefined) {
                localVarQueryParameter['updated_dt'] = (updatedDt as any instanceof Date) ?
                    (updatedDt as any).toISOString() :
                    updatedDt;
            }

            if (updatedDtDate !== undefined) {
                localVarQueryParameter['updated_dt__date'] = (updatedDtDate as any instanceof Date) ?
                    (updatedDtDate as any).toISOString().substr(0,10) :
                    updatedDtDate;
            }

            if (updatedDtDateGte !== undefined) {
                localVarQueryParameter['updated_dt__date__gte'] = (updatedDtDateGte as any instanceof Date) ?
                    (updatedDtDateGte as any).toISOString().substr(0,10) :
                    updatedDtDateGte;
            }

            if (updatedDtDateLte !== undefined) {
                localVarQueryParameter['updated_dt__date__lte'] = (updatedDtDateLte as any instanceof Date) ?
                    (updatedDtDateLte as any).toISOString().substr(0,10) :
                    updatedDtDateLte;
            }

            if (updatedDtGt !== undefined) {
                localVarQueryParameter['updated_dt__gt'] = (updatedDtGt as any instanceof Date) ?
                    (updatedDtGt as any).toISOString() :
                    updatedDtGt;
            }

            if (updatedDtGte !== undefined) {
                localVarQueryParameter['updated_dt__gte'] = (updatedDtGte as any instanceof Date) ?
                    (updatedDtGte as any).toISOString() :
                    updatedDtGte;
            }

            if (updatedDtLt !== undefined) {
                localVarQueryParameter['updated_dt__lt'] = (updatedDtLt as any instanceof Date) ?
                    (updatedDtLt as any).toISOString() :
                    updatedDtLt;
            }

            if (updatedDtLte !== undefined) {
                localVarQueryParameter['updated_dt__lte'] = (updatedDtLte as any instanceof Date) ?
                    (updatedDtLte as any).toISOString() :
                    updatedDtLte;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} id 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsAcknowledgmentsRetrieve: async (flawId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsAcknowledgmentsRetrieve', 'flawId', flawId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osidbApiV1FlawsAcknowledgmentsRetrieve', 'id', id)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/acknowledgments/{id}`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId 
         * @param {string} id 
         * @param {FlawAcknowledgmentPut} flawAcknowledgmentPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsAcknowledgmentsUpdate: async (bugzillaApiKey: string, flawId: string, id: string, flawAcknowledgmentPut: FlawAcknowledgmentPut, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bugzillaApiKey' is not null or undefined
            assertParamExists('osidbApiV1FlawsAcknowledgmentsUpdate', 'bugzillaApiKey', bugzillaApiKey)
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsAcknowledgmentsUpdate', 'flawId', flawId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osidbApiV1FlawsAcknowledgmentsUpdate', 'id', id)
            // verify required parameter 'flawAcknowledgmentPut' is not null or undefined
            assertParamExists('osidbApiV1FlawsAcknowledgmentsUpdate', 'flawAcknowledgmentPut', flawAcknowledgmentPut)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/acknowledgments/{id}`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (bugzillaApiKey != null) {
                localVarHeaderParameter['Bugzilla-Api-Key'] = String(bugzillaApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flawAcknowledgmentPut, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new comment for a given flaw. Beware that freshly created comments are not guaranteed to keep their original UUIDs, especially if multiple comments are created simultaneously.
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
         * @param {FlawCommentPost} flawCommentPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsCommentsCreate: async (bugzillaApiKey: string, flawId: string, flawCommentPost: FlawCommentPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bugzillaApiKey' is not null or undefined
            assertParamExists('osidbApiV1FlawsCommentsCreate', 'bugzillaApiKey', bugzillaApiKey)
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsCommentsCreate', 'flawId', flawId)
            // verify required parameter 'flawCommentPost' is not null or undefined
            assertParamExists('osidbApiV1FlawsCommentsCreate', 'flawCommentPost', flawCommentPost)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/comments`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (bugzillaApiKey != null) {
                localVarHeaderParameter['Bugzilla-Api-Key'] = String(bugzillaApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flawCommentPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List existing comments for a given flaw. Beware that freshly created comments are not guaranteed to keep their original UUIDs, especially if multiple comments are created simultaneously.
         * @param {string} flawId A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
         * @param {string} [creator] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {string} [externalSystemId] 
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {number} [order] Retrieve only FlawComment resource with the specified order number. Regular flaw comments are numbered from 1 up.
         * @param {string} [uuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsCommentsList: async (flawId: string, creator?: string, excludeFields?: Array<string>, externalSystemId?: string, includeFields?: Array<string>, limit?: number, offset?: number, order?: number, uuid?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsCommentsList', 'flawId', flawId)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/comments`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (creator !== undefined) {
                localVarQueryParameter['creator'] = creator;
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (externalSystemId !== undefined) {
                localVarQueryParameter['external_system_id'] = externalSystemId;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single existing comments for a given flaw. Beware that freshly created comments are not guaranteed to keep their original UUIDs, especially if multiple comments are created simultaneously.
         * @param {string} commentId A string representing the internal OSIDB UUID of the FlawComment resource.
         * @param {string} flawId A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsCommentsRetrieve: async (commentId: string, flawId: string, excludeFields?: Array<string>, includeFields?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('osidbApiV1FlawsCommentsRetrieve', 'commentId', commentId)
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsCommentsRetrieve', 'flawId', flawId)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/comments/{comment_id}`
                .replace(`{${"comment_id"}}`, encodeURIComponent(String(commentId)))
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {FlawPost} flawPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsCreate: async (bugzillaApiKey: string, jiraApiKey: string, flawPost: FlawPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bugzillaApiKey' is not null or undefined
            assertParamExists('osidbApiV1FlawsCreate', 'bugzillaApiKey', bugzillaApiKey)
            // verify required parameter 'jiraApiKey' is not null or undefined
            assertParamExists('osidbApiV1FlawsCreate', 'jiraApiKey', jiraApiKey)
            // verify required parameter 'flawPost' is not null or undefined
            assertParamExists('osidbApiV1FlawsCreate', 'flawPost', flawPost)
            const localVarPath = `/osidb/api/v1/flaws`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (bugzillaApiKey != null) {
                localVarHeaderParameter['Bugzilla-Api-Key'] = String(bugzillaApiKey);
            }

            if (jiraApiKey != null) {
                localVarHeaderParameter['Jira-Api-Key'] = String(jiraApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flawPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId 
         * @param {FlawCVSSPost} flawCVSSPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsCvssScoresCreate: async (bugzillaApiKey: string, flawId: string, flawCVSSPost: FlawCVSSPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bugzillaApiKey' is not null or undefined
            assertParamExists('osidbApiV1FlawsCvssScoresCreate', 'bugzillaApiKey', bugzillaApiKey)
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsCvssScoresCreate', 'flawId', flawId)
            // verify required parameter 'flawCVSSPost' is not null or undefined
            assertParamExists('osidbApiV1FlawsCvssScoresCreate', 'flawCVSSPost', flawCVSSPost)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/cvss_scores`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (bugzillaApiKey != null) {
                localVarHeaderParameter['Bugzilla-Api-Key'] = String(bugzillaApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flawCVSSPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Destroy the instance and proxy the delete to Bugzilla
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsCvssScoresDestroy: async (bugzillaApiKey: string, flawId: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bugzillaApiKey' is not null or undefined
            assertParamExists('osidbApiV1FlawsCvssScoresDestroy', 'bugzillaApiKey', bugzillaApiKey)
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsCvssScoresDestroy', 'flawId', flawId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osidbApiV1FlawsCvssScoresDestroy', 'id', id)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/cvss_scores/{id}`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (bugzillaApiKey != null) {
                localVarHeaderParameter['Bugzilla-Api-Key'] = String(bugzillaApiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} [comment] 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {string} [cvssVersion] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {'NIST' | 'OSV' | 'RH'} [issuer] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {number} [score] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {string} [vector] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsCvssScoresList: async (flawId: string, comment?: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, cvssVersion?: string, excludeFields?: Array<string>, includeFields?: Array<string>, issuer?: 'NIST' | 'OSV' | 'RH', limit?: number, offset?: number, score?: number, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, vector?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsCvssScoresList', 'flawId', flawId)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/cvss_scores`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (comment !== undefined) {
                localVarQueryParameter['comment'] = comment;
            }

            if (createdDt !== undefined) {
                localVarQueryParameter['created_dt'] = (createdDt as any instanceof Date) ?
                    (createdDt as any).toISOString() :
                    createdDt;
            }

            if (createdDtDate !== undefined) {
                localVarQueryParameter['created_dt__date'] = (createdDtDate as any instanceof Date) ?
                    (createdDtDate as any).toISOString().substr(0,10) :
                    createdDtDate;
            }

            if (createdDtDateGte !== undefined) {
                localVarQueryParameter['created_dt__date__gte'] = (createdDtDateGte as any instanceof Date) ?
                    (createdDtDateGte as any).toISOString().substr(0,10) :
                    createdDtDateGte;
            }

            if (createdDtDateLte !== undefined) {
                localVarQueryParameter['created_dt__date__lte'] = (createdDtDateLte as any instanceof Date) ?
                    (createdDtDateLte as any).toISOString().substr(0,10) :
                    createdDtDateLte;
            }

            if (createdDtGt !== undefined) {
                localVarQueryParameter['created_dt__gt'] = (createdDtGt as any instanceof Date) ?
                    (createdDtGt as any).toISOString() :
                    createdDtGt;
            }

            if (createdDtGte !== undefined) {
                localVarQueryParameter['created_dt__gte'] = (createdDtGte as any instanceof Date) ?
                    (createdDtGte as any).toISOString() :
                    createdDtGte;
            }

            if (createdDtLt !== undefined) {
                localVarQueryParameter['created_dt__lt'] = (createdDtLt as any instanceof Date) ?
                    (createdDtLt as any).toISOString() :
                    createdDtLt;
            }

            if (createdDtLte !== undefined) {
                localVarQueryParameter['created_dt__lte'] = (createdDtLte as any instanceof Date) ?
                    (createdDtLte as any).toISOString() :
                    createdDtLte;
            }

            if (cvssVersion !== undefined) {
                localVarQueryParameter['cvss_version'] = cvssVersion;
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }

            if (issuer !== undefined) {
                localVarQueryParameter['issuer'] = issuer;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (score !== undefined) {
                localVarQueryParameter['score'] = score;
            }

            if (updatedDt !== undefined) {
                localVarQueryParameter['updated_dt'] = (updatedDt as any instanceof Date) ?
                    (updatedDt as any).toISOString() :
                    updatedDt;
            }

            if (updatedDtDate !== undefined) {
                localVarQueryParameter['updated_dt__date'] = (updatedDtDate as any instanceof Date) ?
                    (updatedDtDate as any).toISOString().substr(0,10) :
                    updatedDtDate;
            }

            if (updatedDtDateGte !== undefined) {
                localVarQueryParameter['updated_dt__date__gte'] = (updatedDtDateGte as any instanceof Date) ?
                    (updatedDtDateGte as any).toISOString().substr(0,10) :
                    updatedDtDateGte;
            }

            if (updatedDtDateLte !== undefined) {
                localVarQueryParameter['updated_dt__date__lte'] = (updatedDtDateLte as any instanceof Date) ?
                    (updatedDtDateLte as any).toISOString().substr(0,10) :
                    updatedDtDateLte;
            }

            if (updatedDtGt !== undefined) {
                localVarQueryParameter['updated_dt__gt'] = (updatedDtGt as any instanceof Date) ?
                    (updatedDtGt as any).toISOString() :
                    updatedDtGt;
            }

            if (updatedDtGte !== undefined) {
                localVarQueryParameter['updated_dt__gte'] = (updatedDtGte as any instanceof Date) ?
                    (updatedDtGte as any).toISOString() :
                    updatedDtGte;
            }

            if (updatedDtLt !== undefined) {
                localVarQueryParameter['updated_dt__lt'] = (updatedDtLt as any instanceof Date) ?
                    (updatedDtLt as any).toISOString() :
                    updatedDtLt;
            }

            if (updatedDtLte !== undefined) {
                localVarQueryParameter['updated_dt__lte'] = (updatedDtLte as any instanceof Date) ?
                    (updatedDtLte as any).toISOString() :
                    updatedDtLte;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (vector !== undefined) {
                localVarQueryParameter['vector'] = vector;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} id 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsCvssScoresRetrieve: async (flawId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsCvssScoresRetrieve', 'flawId', flawId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osidbApiV1FlawsCvssScoresRetrieve', 'id', id)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/cvss_scores/{id}`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId 
         * @param {string} id 
         * @param {FlawCVSSPut} flawCVSSPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsCvssScoresUpdate: async (bugzillaApiKey: string, flawId: string, id: string, flawCVSSPut: FlawCVSSPut, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bugzillaApiKey' is not null or undefined
            assertParamExists('osidbApiV1FlawsCvssScoresUpdate', 'bugzillaApiKey', bugzillaApiKey)
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsCvssScoresUpdate', 'flawId', flawId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osidbApiV1FlawsCvssScoresUpdate', 'id', id)
            // verify required parameter 'flawCVSSPut' is not null or undefined
            assertParamExists('osidbApiV1FlawsCvssScoresUpdate', 'flawCVSSPut', flawCVSSPut)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/cvss_scores/{id}`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (bugzillaApiKey != null) {
                localVarHeaderParameter['Bugzilla-Api-Key'] = String(bugzillaApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flawCVSSPut, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [acknowledgmentsAffiliation] 
         * @param {string} [acknowledgmentsCreatedDt] 
         * @param {string} [acknowledgmentsCreatedDtDate] 
         * @param {string} [acknowledgmentsCreatedDtDateGte] 
         * @param {string} [acknowledgmentsCreatedDtDateLte] 
         * @param {string} [acknowledgmentsCreatedDtGt] 
         * @param {string} [acknowledgmentsCreatedDtGte] 
         * @param {string} [acknowledgmentsCreatedDtLt] 
         * @param {string} [acknowledgmentsCreatedDtLte] 
         * @param {boolean} [acknowledgmentsFromUpstream] 
         * @param {string} [acknowledgmentsName] 
         * @param {string} [acknowledgmentsUpdatedDt] 
         * @param {string} [acknowledgmentsUpdatedDtDate] 
         * @param {string} [acknowledgmentsUpdatedDtDateGte] 
         * @param {string} [acknowledgmentsUpdatedDtDateLte] 
         * @param {string} [acknowledgmentsUpdatedDtGt] 
         * @param {string} [acknowledgmentsUpdatedDtGte] 
         * @param {string} [acknowledgmentsUpdatedDtLt] 
         * @param {string} [acknowledgmentsUpdatedDtLte] 
         * @param {string} [acknowledgmentsUuid] 
         * @param {'' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED'} [affectsAffectedness] 
         * @param {string} [affectsCreatedDt] 
         * @param {string} [affectsCreatedDtDate] 
         * @param {string} [affectsCreatedDtDateGte] 
         * @param {string} [affectsCreatedDtDateLte] 
         * @param {string} [affectsCreatedDtGt] 
         * @param {string} [affectsCreatedDtGte] 
         * @param {string} [affectsCreatedDtLt] 
         * @param {string} [affectsCreatedDtLte] 
         * @param {boolean} [affectsEmbargoed] 
         * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [affectsImpact] 
         * @param {string} [affectsPsComponent] 
         * @param {string} [affectsPsModule] 
         * @param {'' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT'} [affectsResolution] 
         * @param {string} [affectsTrackersCreatedDt] 
         * @param {string} [affectsTrackersCreatedDtDate] 
         * @param {string} [affectsTrackersCreatedDtDateGte] 
         * @param {string} [affectsTrackersCreatedDtDateLte] 
         * @param {string} [affectsTrackersCreatedDtGt] 
         * @param {string} [affectsTrackersCreatedDtGte] 
         * @param {string} [affectsTrackersCreatedDtLt] 
         * @param {string} [affectsTrackersCreatedDtLte] 
         * @param {boolean} [affectsTrackersEmbargoed] 
         * @param {string} [affectsTrackersErrataAdvisoryName] 
         * @param {number} [affectsTrackersErrataEtId] 
         * @param {string} [affectsTrackersErrataShippedDt] 
         * @param {string} [affectsTrackersErrataShippedDtDate] 
         * @param {string} [affectsTrackersErrataShippedDtDateGte] 
         * @param {string} [affectsTrackersErrataShippedDtDateLte] 
         * @param {string} [affectsTrackersErrataShippedDtGt] 
         * @param {string} [affectsTrackersErrataShippedDtGte] 
         * @param {string} [affectsTrackersErrataShippedDtLt] 
         * @param {string} [affectsTrackersErrataShippedDtLte] 
         * @param {string} [affectsTrackersExternalSystemId] 
         * @param {string} [affectsTrackersPsUpdateStream] 
         * @param {string} [affectsTrackersResolution] 
         * @param {string} [affectsTrackersStatus] 
         * @param {'BUGZILLA' | 'JIRA'} [affectsTrackersType] 
         * @param {string} [affectsTrackersUpdatedDt] 
         * @param {string} [affectsTrackersUpdatedDtDate] 
         * @param {string} [affectsTrackersUpdatedDtDateGte] 
         * @param {string} [affectsTrackersUpdatedDtDateLte] 
         * @param {string} [affectsTrackersUpdatedDtGt] 
         * @param {string} [affectsTrackersUpdatedDtGte] 
         * @param {string} [affectsTrackersUpdatedDtLt] 
         * @param {string} [affectsTrackersUpdatedDtLte] 
         * @param {string} [affectsTrackersUuid] 
         * @param {string} [affectsUpdatedDt] 
         * @param {string} [affectsUpdatedDtDate] 
         * @param {string} [affectsUpdatedDtDateGte] 
         * @param {string} [affectsUpdatedDtDateLte] 
         * @param {string} [affectsUpdatedDtGt] 
         * @param {string} [affectsUpdatedDtGte] 
         * @param {string} [affectsUpdatedDtLt] 
         * @param {string} [affectsUpdatedDtLte] 
         * @param {string} [affectsUuid] 
         * @param {number} [bzId] 
         * @param {string} [changedAfter] 
         * @param {string} [changedBefore] 
         * @param {string} [commentZero] 
         * @param {Array<string>} [components] Multiple values may be separated by commas.
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {string} [cveDescription] 
         * @param {boolean} [cveDescriptionIsempty] 
         * @param {Array<string>} [cveId] Multiple values may be separated by commas.
         * @param {boolean} [cveIdIsempty] 
         * @param {boolean} [cvss2NistIsempty] 
         * @param {boolean} [cvss2RhIsempty] 
         * @param {boolean} [cvss3NistIsempty] 
         * @param {boolean} [cvss3RhIsempty] 
         * @param {boolean} [cvss4NistIsempty] 
         * @param {boolean} [cvss4RhIsempty] 
         * @param {string} [cvssScoresComment] 
         * @param {string} [cvssScoresCreatedDt] 
         * @param {string} [cvssScoresCreatedDtDate] 
         * @param {string} [cvssScoresCreatedDtDateGte] 
         * @param {string} [cvssScoresCreatedDtDateLte] 
         * @param {string} [cvssScoresCreatedDtGt] 
         * @param {string} [cvssScoresCreatedDtGte] 
         * @param {string} [cvssScoresCreatedDtLt] 
         * @param {string} [cvssScoresCreatedDtLte] 
         * @param {string} [cvssScoresCvssVersion] 
         * @param {'NIST' | 'OSV' | 'RH'} [cvssScoresIssuer] 
         * @param {number} [cvssScoresScore] 
         * @param {string} [cvssScoresUpdatedDt] 
         * @param {string} [cvssScoresUpdatedDtDate] 
         * @param {string} [cvssScoresUpdatedDtDateGte] 
         * @param {string} [cvssScoresUpdatedDtDateLte] 
         * @param {string} [cvssScoresUpdatedDtGt] 
         * @param {string} [cvssScoresUpdatedDtGte] 
         * @param {string} [cvssScoresUpdatedDtLt] 
         * @param {string} [cvssScoresUpdatedDtLte] 
         * @param {string} [cvssScoresUuid] 
         * @param {string} [cvssScoresVector] 
         * @param {string} [cweId] 
         * @param {boolean} [cweIdIsempty] 
         * @param {boolean} [embargoed] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [impact] 
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [majorIncidentStartDt] 
         * @param {string} [majorIncidentStartDtDate] 
         * @param {string} [majorIncidentStartDtDateGte] 
         * @param {string} [majorIncidentStartDtDateLte] 
         * @param {string} [majorIncidentStartDtGt] 
         * @param {string} [majorIncidentStartDtGte] 
         * @param {string} [majorIncidentStartDtLt] 
         * @param {string} [majorIncidentStartDtLte] 
         * @param {'' | 'APPROVED' | 'CISA_APPROVED' | 'INVALID' | 'REJECTED' | 'REQUESTED'} [majorIncidentState] 
         * @param {boolean} [mitigationIsempty] 
         * @param {'' | 'APPROVED' | 'REJECTED' | 'REQUESTED'} [nistCvssValidation] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {Array<'-acknowledgments__affiliation' | '-acknowledgments__created_dt' | '-acknowledgments__from_upstream' | '-acknowledgments__name' | '-acknowledgments__updated_dt' | '-acknowledgments__uuid' | '-affects__affectedness' | '-affects__created_dt' | '-affects__impact' | '-affects__ps_component' | '-affects__ps_module' | '-affects__resolution' | '-affects__trackers__created_dt' | '-affects__trackers__errata__advisory_name' | '-affects__trackers__errata__et_id' | '-affects__trackers__errata__shipped_dt' | '-affects__trackers__external_system_id' | '-affects__trackers__ps_update_stream' | '-affects__trackers__resolution' | '-affects__trackers__status' | '-affects__trackers__type' | '-affects__trackers__updated_dt' | '-affects__trackers__uuid' | '-affects__updated_dt' | '-affects__uuid' | '-bz_id' | '-comment_zero' | '-components' | '-created_dt' | '-cve_description' | '-cve_id' | '-cvss_scores__comment' | '-cvss_scores__created_dt' | '-cvss_scores__issuer' | '-cvss_scores__score' | '-cvss_scores__updated_dt' | '-cvss_scores__uuid' | '-cvss_scores__vector' | '-cwe_id' | '-embargoed' | '-impact' | '-major_incident_start_dt' | '-major_incident_state' | '-nist_cvss_validation' | '-owner' | '-references__created_dt' | '-references__description' | '-references__type' | '-references__updated_dt' | '-references__url' | '-references__uuid' | '-reported_dt' | '-requires_cve_description' | '-source' | '-statement' | '-team_id' | '-title' | '-unembargo_dt' | '-updated_dt' | '-uuid' | '-workflow_state' | 'acknowledgments__affiliation' | 'acknowledgments__created_dt' | 'acknowledgments__from_upstream' | 'acknowledgments__name' | 'acknowledgments__updated_dt' | 'acknowledgments__uuid' | 'affects__affectedness' | 'affects__created_dt' | 'affects__impact' | 'affects__ps_component' | 'affects__ps_module' | 'affects__resolution' | 'affects__trackers__created_dt' | 'affects__trackers__errata__advisory_name' | 'affects__trackers__errata__et_id' | 'affects__trackers__errata__shipped_dt' | 'affects__trackers__external_system_id' | 'affects__trackers__ps_update_stream' | 'affects__trackers__resolution' | 'affects__trackers__status' | 'affects__trackers__type' | 'affects__trackers__updated_dt' | 'affects__trackers__uuid' | 'affects__updated_dt' | 'affects__uuid' | 'bz_id' | 'comment_zero' | 'components' | 'created_dt' | 'cve_description' | 'cve_id' | 'cvss_scores__comment' | 'cvss_scores__created_dt' | 'cvss_scores__issuer' | 'cvss_scores__score' | 'cvss_scores__updated_dt' | 'cvss_scores__uuid' | 'cvss_scores__vector' | 'cwe_id' | 'embargoed' | 'impact' | 'major_incident_start_dt' | 'major_incident_state' | 'nist_cvss_validation' | 'owner' | 'references__created_dt' | 'references__description' | 'references__type' | 'references__updated_dt' | 'references__url' | 'references__uuid' | 'reported_dt' | 'requires_cve_description' | 'source' | 'statement' | 'team_id' | 'title' | 'unembargo_dt' | 'updated_dt' | 'uuid' | 'workflow_state'>} [order] Ordering
         * @param {string} [owner] 
         * @param {boolean} [ownerIsempty] 
         * @param {string} [referencesCreatedDt] 
         * @param {string} [referencesCreatedDtDate] 
         * @param {string} [referencesCreatedDtDateGte] 
         * @param {string} [referencesCreatedDtDateLte] 
         * @param {string} [referencesCreatedDtGt] 
         * @param {string} [referencesCreatedDtGte] 
         * @param {string} [referencesCreatedDtLt] 
         * @param {string} [referencesCreatedDtLte] 
         * @param {string} [referencesDescription] 
         * @param {'ARTICLE' | 'EXTERNAL' | 'SOURCE'} [referencesType] 
         * @param {string} [referencesUpdatedDt] 
         * @param {string} [referencesUpdatedDtDate] 
         * @param {string} [referencesUpdatedDtDateGte] 
         * @param {string} [referencesUpdatedDtDateLte] 
         * @param {string} [referencesUpdatedDtGt] 
         * @param {string} [referencesUpdatedDtGte] 
         * @param {string} [referencesUpdatedDtLt] 
         * @param {string} [referencesUpdatedDtLte] 
         * @param {string} [referencesUrl] 
         * @param {string} [referencesUuid] 
         * @param {string} [reportedDt] 
         * @param {string} [reportedDtDate] 
         * @param {string} [reportedDtDateGte] 
         * @param {string} [reportedDtDateLte] 
         * @param {string} [reportedDtGt] 
         * @param {string} [reportedDtGte] 
         * @param {string} [reportedDtLt] 
         * @param {string} [reportedDtLte] 
         * @param {'' | 'APPROVED' | 'REJECTED' | 'REQUESTED'} [requiresCveDescription] 
         * @param {string} [search] 
         * @param {'' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'NVD' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'OSV' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF'} [source] 
         * @param {string} [statement] 
         * @param {boolean} [statementIsempty] 
         * @param {string} [teamId] 
         * @param {string} [title] 
         * @param {Array<string>} [trackerIds] Filter only Flaws which are related to specified Trackers (through Affects). Multiple tracker IDs may be separated by commas. Also only Affects that have the specified Trackers related will be shown.
         * @param {string} [unembargoDt] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {Array<'' | 'DONE' | 'NEW' | 'PRE_SECONDARY_ASSESSMENT' | 'REJECTED' | 'SECONDARY_ASSESSMENT' | 'TRIAGE'>} [workflowState] Multiple values may be separated by commas.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsList: async (acknowledgmentsAffiliation?: string, acknowledgmentsCreatedDt?: string, acknowledgmentsCreatedDtDate?: string, acknowledgmentsCreatedDtDateGte?: string, acknowledgmentsCreatedDtDateLte?: string, acknowledgmentsCreatedDtGt?: string, acknowledgmentsCreatedDtGte?: string, acknowledgmentsCreatedDtLt?: string, acknowledgmentsCreatedDtLte?: string, acknowledgmentsFromUpstream?: boolean, acknowledgmentsName?: string, acknowledgmentsUpdatedDt?: string, acknowledgmentsUpdatedDtDate?: string, acknowledgmentsUpdatedDtDateGte?: string, acknowledgmentsUpdatedDtDateLte?: string, acknowledgmentsUpdatedDtGt?: string, acknowledgmentsUpdatedDtGte?: string, acknowledgmentsUpdatedDtLt?: string, acknowledgmentsUpdatedDtLte?: string, acknowledgmentsUuid?: string, affectsAffectedness?: '' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED', affectsCreatedDt?: string, affectsCreatedDtDate?: string, affectsCreatedDtDateGte?: string, affectsCreatedDtDateLte?: string, affectsCreatedDtGt?: string, affectsCreatedDtGte?: string, affectsCreatedDtLt?: string, affectsCreatedDtLte?: string, affectsEmbargoed?: boolean, affectsImpact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', affectsPsComponent?: string, affectsPsModule?: string, affectsResolution?: '' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT', affectsTrackersCreatedDt?: string, affectsTrackersCreatedDtDate?: string, affectsTrackersCreatedDtDateGte?: string, affectsTrackersCreatedDtDateLte?: string, affectsTrackersCreatedDtGt?: string, affectsTrackersCreatedDtGte?: string, affectsTrackersCreatedDtLt?: string, affectsTrackersCreatedDtLte?: string, affectsTrackersEmbargoed?: boolean, affectsTrackersErrataAdvisoryName?: string, affectsTrackersErrataEtId?: number, affectsTrackersErrataShippedDt?: string, affectsTrackersErrataShippedDtDate?: string, affectsTrackersErrataShippedDtDateGte?: string, affectsTrackersErrataShippedDtDateLte?: string, affectsTrackersErrataShippedDtGt?: string, affectsTrackersErrataShippedDtGte?: string, affectsTrackersErrataShippedDtLt?: string, affectsTrackersErrataShippedDtLte?: string, affectsTrackersExternalSystemId?: string, affectsTrackersPsUpdateStream?: string, affectsTrackersResolution?: string, affectsTrackersStatus?: string, affectsTrackersType?: 'BUGZILLA' | 'JIRA', affectsTrackersUpdatedDt?: string, affectsTrackersUpdatedDtDate?: string, affectsTrackersUpdatedDtDateGte?: string, affectsTrackersUpdatedDtDateLte?: string, affectsTrackersUpdatedDtGt?: string, affectsTrackersUpdatedDtGte?: string, affectsTrackersUpdatedDtLt?: string, affectsTrackersUpdatedDtLte?: string, affectsTrackersUuid?: string, affectsUpdatedDt?: string, affectsUpdatedDtDate?: string, affectsUpdatedDtDateGte?: string, affectsUpdatedDtDateLte?: string, affectsUpdatedDtGt?: string, affectsUpdatedDtGte?: string, affectsUpdatedDtLt?: string, affectsUpdatedDtLte?: string, affectsUuid?: string, bzId?: number, changedAfter?: string, changedBefore?: string, commentZero?: string, components?: Array<string>, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, cveDescription?: string, cveDescriptionIsempty?: boolean, cveId?: Array<string>, cveIdIsempty?: boolean, cvss2NistIsempty?: boolean, cvss2RhIsempty?: boolean, cvss3NistIsempty?: boolean, cvss3RhIsempty?: boolean, cvss4NistIsempty?: boolean, cvss4RhIsempty?: boolean, cvssScoresComment?: string, cvssScoresCreatedDt?: string, cvssScoresCreatedDtDate?: string, cvssScoresCreatedDtDateGte?: string, cvssScoresCreatedDtDateLte?: string, cvssScoresCreatedDtGt?: string, cvssScoresCreatedDtGte?: string, cvssScoresCreatedDtLt?: string, cvssScoresCreatedDtLte?: string, cvssScoresCvssVersion?: string, cvssScoresIssuer?: 'NIST' | 'OSV' | 'RH', cvssScoresScore?: number, cvssScoresUpdatedDt?: string, cvssScoresUpdatedDtDate?: string, cvssScoresUpdatedDtDateGte?: string, cvssScoresUpdatedDtDateLte?: string, cvssScoresUpdatedDtGt?: string, cvssScoresUpdatedDtGte?: string, cvssScoresUpdatedDtLt?: string, cvssScoresUpdatedDtLte?: string, cvssScoresUuid?: string, cvssScoresVector?: string, cweId?: string, cweIdIsempty?: boolean, embargoed?: boolean, excludeFields?: Array<string>, impact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', includeFields?: Array<string>, includeMetaAttr?: Array<string>, limit?: number, majorIncidentStartDt?: string, majorIncidentStartDtDate?: string, majorIncidentStartDtDateGte?: string, majorIncidentStartDtDateLte?: string, majorIncidentStartDtGt?: string, majorIncidentStartDtGte?: string, majorIncidentStartDtLt?: string, majorIncidentStartDtLte?: string, majorIncidentState?: '' | 'APPROVED' | 'CISA_APPROVED' | 'INVALID' | 'REJECTED' | 'REQUESTED', mitigationIsempty?: boolean, nistCvssValidation?: '' | 'APPROVED' | 'REJECTED' | 'REQUESTED', offset?: number, order?: Array<'-acknowledgments__affiliation' | '-acknowledgments__created_dt' | '-acknowledgments__from_upstream' | '-acknowledgments__name' | '-acknowledgments__updated_dt' | '-acknowledgments__uuid' | '-affects__affectedness' | '-affects__created_dt' | '-affects__impact' | '-affects__ps_component' | '-affects__ps_module' | '-affects__resolution' | '-affects__trackers__created_dt' | '-affects__trackers__errata__advisory_name' | '-affects__trackers__errata__et_id' | '-affects__trackers__errata__shipped_dt' | '-affects__trackers__external_system_id' | '-affects__trackers__ps_update_stream' | '-affects__trackers__resolution' | '-affects__trackers__status' | '-affects__trackers__type' | '-affects__trackers__updated_dt' | '-affects__trackers__uuid' | '-affects__updated_dt' | '-affects__uuid' | '-bz_id' | '-comment_zero' | '-components' | '-created_dt' | '-cve_description' | '-cve_id' | '-cvss_scores__comment' | '-cvss_scores__created_dt' | '-cvss_scores__issuer' | '-cvss_scores__score' | '-cvss_scores__updated_dt' | '-cvss_scores__uuid' | '-cvss_scores__vector' | '-cwe_id' | '-embargoed' | '-impact' | '-major_incident_start_dt' | '-major_incident_state' | '-nist_cvss_validation' | '-owner' | '-references__created_dt' | '-references__description' | '-references__type' | '-references__updated_dt' | '-references__url' | '-references__uuid' | '-reported_dt' | '-requires_cve_description' | '-source' | '-statement' | '-team_id' | '-title' | '-unembargo_dt' | '-updated_dt' | '-uuid' | '-workflow_state' | 'acknowledgments__affiliation' | 'acknowledgments__created_dt' | 'acknowledgments__from_upstream' | 'acknowledgments__name' | 'acknowledgments__updated_dt' | 'acknowledgments__uuid' | 'affects__affectedness' | 'affects__created_dt' | 'affects__impact' | 'affects__ps_component' | 'affects__ps_module' | 'affects__resolution' | 'affects__trackers__created_dt' | 'affects__trackers__errata__advisory_name' | 'affects__trackers__errata__et_id' | 'affects__trackers__errata__shipped_dt' | 'affects__trackers__external_system_id' | 'affects__trackers__ps_update_stream' | 'affects__trackers__resolution' | 'affects__trackers__status' | 'affects__trackers__type' | 'affects__trackers__updated_dt' | 'affects__trackers__uuid' | 'affects__updated_dt' | 'affects__uuid' | 'bz_id' | 'comment_zero' | 'components' | 'created_dt' | 'cve_description' | 'cve_id' | 'cvss_scores__comment' | 'cvss_scores__created_dt' | 'cvss_scores__issuer' | 'cvss_scores__score' | 'cvss_scores__updated_dt' | 'cvss_scores__uuid' | 'cvss_scores__vector' | 'cwe_id' | 'embargoed' | 'impact' | 'major_incident_start_dt' | 'major_incident_state' | 'nist_cvss_validation' | 'owner' | 'references__created_dt' | 'references__description' | 'references__type' | 'references__updated_dt' | 'references__url' | 'references__uuid' | 'reported_dt' | 'requires_cve_description' | 'source' | 'statement' | 'team_id' | 'title' | 'unembargo_dt' | 'updated_dt' | 'uuid' | 'workflow_state'>, owner?: string, ownerIsempty?: boolean, referencesCreatedDt?: string, referencesCreatedDtDate?: string, referencesCreatedDtDateGte?: string, referencesCreatedDtDateLte?: string, referencesCreatedDtGt?: string, referencesCreatedDtGte?: string, referencesCreatedDtLt?: string, referencesCreatedDtLte?: string, referencesDescription?: string, referencesType?: 'ARTICLE' | 'EXTERNAL' | 'SOURCE', referencesUpdatedDt?: string, referencesUpdatedDtDate?: string, referencesUpdatedDtDateGte?: string, referencesUpdatedDtDateLte?: string, referencesUpdatedDtGt?: string, referencesUpdatedDtGte?: string, referencesUpdatedDtLt?: string, referencesUpdatedDtLte?: string, referencesUrl?: string, referencesUuid?: string, reportedDt?: string, reportedDtDate?: string, reportedDtDateGte?: string, reportedDtDateLte?: string, reportedDtGt?: string, reportedDtGte?: string, reportedDtLt?: string, reportedDtLte?: string, requiresCveDescription?: '' | 'APPROVED' | 'REJECTED' | 'REQUESTED', search?: string, source?: '' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'NVD' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'OSV' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF', statement?: string, statementIsempty?: boolean, teamId?: string, title?: string, trackerIds?: Array<string>, unembargoDt?: string, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, workflowState?: Array<'' | 'DONE' | 'NEW' | 'PRE_SECONDARY_ASSESSMENT' | 'REJECTED' | 'SECONDARY_ASSESSMENT' | 'TRIAGE'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/osidb/api/v1/flaws`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (acknowledgmentsAffiliation !== undefined) {
                localVarQueryParameter['acknowledgments__affiliation'] = acknowledgmentsAffiliation;
            }

            if (acknowledgmentsCreatedDt !== undefined) {
                localVarQueryParameter['acknowledgments__created_dt'] = (acknowledgmentsCreatedDt as any instanceof Date) ?
                    (acknowledgmentsCreatedDt as any).toISOString() :
                    acknowledgmentsCreatedDt;
            }

            if (acknowledgmentsCreatedDtDate !== undefined) {
                localVarQueryParameter['acknowledgments__created_dt__date'] = (acknowledgmentsCreatedDtDate as any instanceof Date) ?
                    (acknowledgmentsCreatedDtDate as any).toISOString().substr(0,10) :
                    acknowledgmentsCreatedDtDate;
            }

            if (acknowledgmentsCreatedDtDateGte !== undefined) {
                localVarQueryParameter['acknowledgments__created_dt__date__gte'] = (acknowledgmentsCreatedDtDateGte as any instanceof Date) ?
                    (acknowledgmentsCreatedDtDateGte as any).toISOString().substr(0,10) :
                    acknowledgmentsCreatedDtDateGte;
            }

            if (acknowledgmentsCreatedDtDateLte !== undefined) {
                localVarQueryParameter['acknowledgments__created_dt__date__lte'] = (acknowledgmentsCreatedDtDateLte as any instanceof Date) ?
                    (acknowledgmentsCreatedDtDateLte as any).toISOString().substr(0,10) :
                    acknowledgmentsCreatedDtDateLte;
            }

            if (acknowledgmentsCreatedDtGt !== undefined) {
                localVarQueryParameter['acknowledgments__created_dt__gt'] = (acknowledgmentsCreatedDtGt as any instanceof Date) ?
                    (acknowledgmentsCreatedDtGt as any).toISOString() :
                    acknowledgmentsCreatedDtGt;
            }

            if (acknowledgmentsCreatedDtGte !== undefined) {
                localVarQueryParameter['acknowledgments__created_dt__gte'] = (acknowledgmentsCreatedDtGte as any instanceof Date) ?
                    (acknowledgmentsCreatedDtGte as any).toISOString() :
                    acknowledgmentsCreatedDtGte;
            }

            if (acknowledgmentsCreatedDtLt !== undefined) {
                localVarQueryParameter['acknowledgments__created_dt__lt'] = (acknowledgmentsCreatedDtLt as any instanceof Date) ?
                    (acknowledgmentsCreatedDtLt as any).toISOString() :
                    acknowledgmentsCreatedDtLt;
            }

            if (acknowledgmentsCreatedDtLte !== undefined) {
                localVarQueryParameter['acknowledgments__created_dt__lte'] = (acknowledgmentsCreatedDtLte as any instanceof Date) ?
                    (acknowledgmentsCreatedDtLte as any).toISOString() :
                    acknowledgmentsCreatedDtLte;
            }

            if (acknowledgmentsFromUpstream !== undefined) {
                localVarQueryParameter['acknowledgments__from_upstream'] = acknowledgmentsFromUpstream;
            }

            if (acknowledgmentsName !== undefined) {
                localVarQueryParameter['acknowledgments__name'] = acknowledgmentsName;
            }

            if (acknowledgmentsUpdatedDt !== undefined) {
                localVarQueryParameter['acknowledgments__updated_dt'] = (acknowledgmentsUpdatedDt as any instanceof Date) ?
                    (acknowledgmentsUpdatedDt as any).toISOString() :
                    acknowledgmentsUpdatedDt;
            }

            if (acknowledgmentsUpdatedDtDate !== undefined) {
                localVarQueryParameter['acknowledgments__updated_dt__date'] = (acknowledgmentsUpdatedDtDate as any instanceof Date) ?
                    (acknowledgmentsUpdatedDtDate as any).toISOString().substr(0,10) :
                    acknowledgmentsUpdatedDtDate;
            }

            if (acknowledgmentsUpdatedDtDateGte !== undefined) {
                localVarQueryParameter['acknowledgments__updated_dt__date__gte'] = (acknowledgmentsUpdatedDtDateGte as any instanceof Date) ?
                    (acknowledgmentsUpdatedDtDateGte as any).toISOString().substr(0,10) :
                    acknowledgmentsUpdatedDtDateGte;
            }

            if (acknowledgmentsUpdatedDtDateLte !== undefined) {
                localVarQueryParameter['acknowledgments__updated_dt__date__lte'] = (acknowledgmentsUpdatedDtDateLte as any instanceof Date) ?
                    (acknowledgmentsUpdatedDtDateLte as any).toISOString().substr(0,10) :
                    acknowledgmentsUpdatedDtDateLte;
            }

            if (acknowledgmentsUpdatedDtGt !== undefined) {
                localVarQueryParameter['acknowledgments__updated_dt__gt'] = (acknowledgmentsUpdatedDtGt as any instanceof Date) ?
                    (acknowledgmentsUpdatedDtGt as any).toISOString() :
                    acknowledgmentsUpdatedDtGt;
            }

            if (acknowledgmentsUpdatedDtGte !== undefined) {
                localVarQueryParameter['acknowledgments__updated_dt__gte'] = (acknowledgmentsUpdatedDtGte as any instanceof Date) ?
                    (acknowledgmentsUpdatedDtGte as any).toISOString() :
                    acknowledgmentsUpdatedDtGte;
            }

            if (acknowledgmentsUpdatedDtLt !== undefined) {
                localVarQueryParameter['acknowledgments__updated_dt__lt'] = (acknowledgmentsUpdatedDtLt as any instanceof Date) ?
                    (acknowledgmentsUpdatedDtLt as any).toISOString() :
                    acknowledgmentsUpdatedDtLt;
            }

            if (acknowledgmentsUpdatedDtLte !== undefined) {
                localVarQueryParameter['acknowledgments__updated_dt__lte'] = (acknowledgmentsUpdatedDtLte as any instanceof Date) ?
                    (acknowledgmentsUpdatedDtLte as any).toISOString() :
                    acknowledgmentsUpdatedDtLte;
            }

            if (acknowledgmentsUuid !== undefined) {
                localVarQueryParameter['acknowledgments__uuid'] = acknowledgmentsUuid;
            }

            if (affectsAffectedness !== undefined) {
                localVarQueryParameter['affects__affectedness'] = affectsAffectedness;
            }

            if (affectsCreatedDt !== undefined) {
                localVarQueryParameter['affects__created_dt'] = (affectsCreatedDt as any instanceof Date) ?
                    (affectsCreatedDt as any).toISOString() :
                    affectsCreatedDt;
            }

            if (affectsCreatedDtDate !== undefined) {
                localVarQueryParameter['affects__created_dt__date'] = (affectsCreatedDtDate as any instanceof Date) ?
                    (affectsCreatedDtDate as any).toISOString().substr(0,10) :
                    affectsCreatedDtDate;
            }

            if (affectsCreatedDtDateGte !== undefined) {
                localVarQueryParameter['affects__created_dt__date__gte'] = (affectsCreatedDtDateGte as any instanceof Date) ?
                    (affectsCreatedDtDateGte as any).toISOString().substr(0,10) :
                    affectsCreatedDtDateGte;
            }

            if (affectsCreatedDtDateLte !== undefined) {
                localVarQueryParameter['affects__created_dt__date__lte'] = (affectsCreatedDtDateLte as any instanceof Date) ?
                    (affectsCreatedDtDateLte as any).toISOString().substr(0,10) :
                    affectsCreatedDtDateLte;
            }

            if (affectsCreatedDtGt !== undefined) {
                localVarQueryParameter['affects__created_dt__gt'] = (affectsCreatedDtGt as any instanceof Date) ?
                    (affectsCreatedDtGt as any).toISOString() :
                    affectsCreatedDtGt;
            }

            if (affectsCreatedDtGte !== undefined) {
                localVarQueryParameter['affects__created_dt__gte'] = (affectsCreatedDtGte as any instanceof Date) ?
                    (affectsCreatedDtGte as any).toISOString() :
                    affectsCreatedDtGte;
            }

            if (affectsCreatedDtLt !== undefined) {
                localVarQueryParameter['affects__created_dt__lt'] = (affectsCreatedDtLt as any instanceof Date) ?
                    (affectsCreatedDtLt as any).toISOString() :
                    affectsCreatedDtLt;
            }

            if (affectsCreatedDtLte !== undefined) {
                localVarQueryParameter['affects__created_dt__lte'] = (affectsCreatedDtLte as any instanceof Date) ?
                    (affectsCreatedDtLte as any).toISOString() :
                    affectsCreatedDtLte;
            }

            if (affectsEmbargoed !== undefined) {
                localVarQueryParameter['affects__embargoed'] = affectsEmbargoed;
            }

            if (affectsImpact !== undefined) {
                localVarQueryParameter['affects__impact'] = affectsImpact;
            }

            if (affectsPsComponent !== undefined) {
                localVarQueryParameter['affects__ps_component'] = affectsPsComponent;
            }

            if (affectsPsModule !== undefined) {
                localVarQueryParameter['affects__ps_module'] = affectsPsModule;
            }

            if (affectsResolution !== undefined) {
                localVarQueryParameter['affects__resolution'] = affectsResolution;
            }

            if (affectsTrackersCreatedDt !== undefined) {
                localVarQueryParameter['affects__trackers__created_dt'] = (affectsTrackersCreatedDt as any instanceof Date) ?
                    (affectsTrackersCreatedDt as any).toISOString() :
                    affectsTrackersCreatedDt;
            }

            if (affectsTrackersCreatedDtDate !== undefined) {
                localVarQueryParameter['affects__trackers__created_dt__date'] = (affectsTrackersCreatedDtDate as any instanceof Date) ?
                    (affectsTrackersCreatedDtDate as any).toISOString().substr(0,10) :
                    affectsTrackersCreatedDtDate;
            }

            if (affectsTrackersCreatedDtDateGte !== undefined) {
                localVarQueryParameter['affects__trackers__created_dt__date__gte'] = (affectsTrackersCreatedDtDateGte as any instanceof Date) ?
                    (affectsTrackersCreatedDtDateGte as any).toISOString().substr(0,10) :
                    affectsTrackersCreatedDtDateGte;
            }

            if (affectsTrackersCreatedDtDateLte !== undefined) {
                localVarQueryParameter['affects__trackers__created_dt__date__lte'] = (affectsTrackersCreatedDtDateLte as any instanceof Date) ?
                    (affectsTrackersCreatedDtDateLte as any).toISOString().substr(0,10) :
                    affectsTrackersCreatedDtDateLte;
            }

            if (affectsTrackersCreatedDtGt !== undefined) {
                localVarQueryParameter['affects__trackers__created_dt__gt'] = (affectsTrackersCreatedDtGt as any instanceof Date) ?
                    (affectsTrackersCreatedDtGt as any).toISOString() :
                    affectsTrackersCreatedDtGt;
            }

            if (affectsTrackersCreatedDtGte !== undefined) {
                localVarQueryParameter['affects__trackers__created_dt__gte'] = (affectsTrackersCreatedDtGte as any instanceof Date) ?
                    (affectsTrackersCreatedDtGte as any).toISOString() :
                    affectsTrackersCreatedDtGte;
            }

            if (affectsTrackersCreatedDtLt !== undefined) {
                localVarQueryParameter['affects__trackers__created_dt__lt'] = (affectsTrackersCreatedDtLt as any instanceof Date) ?
                    (affectsTrackersCreatedDtLt as any).toISOString() :
                    affectsTrackersCreatedDtLt;
            }

            if (affectsTrackersCreatedDtLte !== undefined) {
                localVarQueryParameter['affects__trackers__created_dt__lte'] = (affectsTrackersCreatedDtLte as any instanceof Date) ?
                    (affectsTrackersCreatedDtLte as any).toISOString() :
                    affectsTrackersCreatedDtLte;
            }

            if (affectsTrackersEmbargoed !== undefined) {
                localVarQueryParameter['affects__trackers__embargoed'] = affectsTrackersEmbargoed;
            }

            if (affectsTrackersErrataAdvisoryName !== undefined) {
                localVarQueryParameter['affects__trackers__errata__advisory_name'] = affectsTrackersErrataAdvisoryName;
            }

            if (affectsTrackersErrataEtId !== undefined) {
                localVarQueryParameter['affects__trackers__errata__et_id'] = affectsTrackersErrataEtId;
            }

            if (affectsTrackersErrataShippedDt !== undefined) {
                localVarQueryParameter['affects__trackers__errata__shipped_dt'] = (affectsTrackersErrataShippedDt as any instanceof Date) ?
                    (affectsTrackersErrataShippedDt as any).toISOString() :
                    affectsTrackersErrataShippedDt;
            }

            if (affectsTrackersErrataShippedDtDate !== undefined) {
                localVarQueryParameter['affects__trackers__errata__shipped_dt__date'] = (affectsTrackersErrataShippedDtDate as any instanceof Date) ?
                    (affectsTrackersErrataShippedDtDate as any).toISOString().substr(0,10) :
                    affectsTrackersErrataShippedDtDate;
            }

            if (affectsTrackersErrataShippedDtDateGte !== undefined) {
                localVarQueryParameter['affects__trackers__errata__shipped_dt__date__gte'] = (affectsTrackersErrataShippedDtDateGte as any instanceof Date) ?
                    (affectsTrackersErrataShippedDtDateGte as any).toISOString().substr(0,10) :
                    affectsTrackersErrataShippedDtDateGte;
            }

            if (affectsTrackersErrataShippedDtDateLte !== undefined) {
                localVarQueryParameter['affects__trackers__errata__shipped_dt__date__lte'] = (affectsTrackersErrataShippedDtDateLte as any instanceof Date) ?
                    (affectsTrackersErrataShippedDtDateLte as any).toISOString().substr(0,10) :
                    affectsTrackersErrataShippedDtDateLte;
            }

            if (affectsTrackersErrataShippedDtGt !== undefined) {
                localVarQueryParameter['affects__trackers__errata__shipped_dt__gt'] = (affectsTrackersErrataShippedDtGt as any instanceof Date) ?
                    (affectsTrackersErrataShippedDtGt as any).toISOString() :
                    affectsTrackersErrataShippedDtGt;
            }

            if (affectsTrackersErrataShippedDtGte !== undefined) {
                localVarQueryParameter['affects__trackers__errata__shipped_dt__gte'] = (affectsTrackersErrataShippedDtGte as any instanceof Date) ?
                    (affectsTrackersErrataShippedDtGte as any).toISOString() :
                    affectsTrackersErrataShippedDtGte;
            }

            if (affectsTrackersErrataShippedDtLt !== undefined) {
                localVarQueryParameter['affects__trackers__errata__shipped_dt__lt'] = (affectsTrackersErrataShippedDtLt as any instanceof Date) ?
                    (affectsTrackersErrataShippedDtLt as any).toISOString() :
                    affectsTrackersErrataShippedDtLt;
            }

            if (affectsTrackersErrataShippedDtLte !== undefined) {
                localVarQueryParameter['affects__trackers__errata__shipped_dt__lte'] = (affectsTrackersErrataShippedDtLte as any instanceof Date) ?
                    (affectsTrackersErrataShippedDtLte as any).toISOString() :
                    affectsTrackersErrataShippedDtLte;
            }

            if (affectsTrackersExternalSystemId !== undefined) {
                localVarQueryParameter['affects__trackers__external_system_id'] = affectsTrackersExternalSystemId;
            }

            if (affectsTrackersPsUpdateStream !== undefined) {
                localVarQueryParameter['affects__trackers__ps_update_stream'] = affectsTrackersPsUpdateStream;
            }

            if (affectsTrackersResolution !== undefined) {
                localVarQueryParameter['affects__trackers__resolution'] = affectsTrackersResolution;
            }

            if (affectsTrackersStatus !== undefined) {
                localVarQueryParameter['affects__trackers__status'] = affectsTrackersStatus;
            }

            if (affectsTrackersType !== undefined) {
                localVarQueryParameter['affects__trackers__type'] = affectsTrackersType;
            }

            if (affectsTrackersUpdatedDt !== undefined) {
                localVarQueryParameter['affects__trackers__updated_dt'] = (affectsTrackersUpdatedDt as any instanceof Date) ?
                    (affectsTrackersUpdatedDt as any).toISOString() :
                    affectsTrackersUpdatedDt;
            }

            if (affectsTrackersUpdatedDtDate !== undefined) {
                localVarQueryParameter['affects__trackers__updated_dt__date'] = (affectsTrackersUpdatedDtDate as any instanceof Date) ?
                    (affectsTrackersUpdatedDtDate as any).toISOString().substr(0,10) :
                    affectsTrackersUpdatedDtDate;
            }

            if (affectsTrackersUpdatedDtDateGte !== undefined) {
                localVarQueryParameter['affects__trackers__updated_dt__date__gte'] = (affectsTrackersUpdatedDtDateGte as any instanceof Date) ?
                    (affectsTrackersUpdatedDtDateGte as any).toISOString().substr(0,10) :
                    affectsTrackersUpdatedDtDateGte;
            }

            if (affectsTrackersUpdatedDtDateLte !== undefined) {
                localVarQueryParameter['affects__trackers__updated_dt__date__lte'] = (affectsTrackersUpdatedDtDateLte as any instanceof Date) ?
                    (affectsTrackersUpdatedDtDateLte as any).toISOString().substr(0,10) :
                    affectsTrackersUpdatedDtDateLte;
            }

            if (affectsTrackersUpdatedDtGt !== undefined) {
                localVarQueryParameter['affects__trackers__updated_dt__gt'] = (affectsTrackersUpdatedDtGt as any instanceof Date) ?
                    (affectsTrackersUpdatedDtGt as any).toISOString() :
                    affectsTrackersUpdatedDtGt;
            }

            if (affectsTrackersUpdatedDtGte !== undefined) {
                localVarQueryParameter['affects__trackers__updated_dt__gte'] = (affectsTrackersUpdatedDtGte as any instanceof Date) ?
                    (affectsTrackersUpdatedDtGte as any).toISOString() :
                    affectsTrackersUpdatedDtGte;
            }

            if (affectsTrackersUpdatedDtLt !== undefined) {
                localVarQueryParameter['affects__trackers__updated_dt__lt'] = (affectsTrackersUpdatedDtLt as any instanceof Date) ?
                    (affectsTrackersUpdatedDtLt as any).toISOString() :
                    affectsTrackersUpdatedDtLt;
            }

            if (affectsTrackersUpdatedDtLte !== undefined) {
                localVarQueryParameter['affects__trackers__updated_dt__lte'] = (affectsTrackersUpdatedDtLte as any instanceof Date) ?
                    (affectsTrackersUpdatedDtLte as any).toISOString() :
                    affectsTrackersUpdatedDtLte;
            }

            if (affectsTrackersUuid !== undefined) {
                localVarQueryParameter['affects__trackers__uuid'] = affectsTrackersUuid;
            }

            if (affectsUpdatedDt !== undefined) {
                localVarQueryParameter['affects__updated_dt'] = (affectsUpdatedDt as any instanceof Date) ?
                    (affectsUpdatedDt as any).toISOString() :
                    affectsUpdatedDt;
            }

            if (affectsUpdatedDtDate !== undefined) {
                localVarQueryParameter['affects__updated_dt__date'] = (affectsUpdatedDtDate as any instanceof Date) ?
                    (affectsUpdatedDtDate as any).toISOString().substr(0,10) :
                    affectsUpdatedDtDate;
            }

            if (affectsUpdatedDtDateGte !== undefined) {
                localVarQueryParameter['affects__updated_dt__date__gte'] = (affectsUpdatedDtDateGte as any instanceof Date) ?
                    (affectsUpdatedDtDateGte as any).toISOString().substr(0,10) :
                    affectsUpdatedDtDateGte;
            }

            if (affectsUpdatedDtDateLte !== undefined) {
                localVarQueryParameter['affects__updated_dt__date__lte'] = (affectsUpdatedDtDateLte as any instanceof Date) ?
                    (affectsUpdatedDtDateLte as any).toISOString().substr(0,10) :
                    affectsUpdatedDtDateLte;
            }

            if (affectsUpdatedDtGt !== undefined) {
                localVarQueryParameter['affects__updated_dt__gt'] = (affectsUpdatedDtGt as any instanceof Date) ?
                    (affectsUpdatedDtGt as any).toISOString() :
                    affectsUpdatedDtGt;
            }

            if (affectsUpdatedDtGte !== undefined) {
                localVarQueryParameter['affects__updated_dt__gte'] = (affectsUpdatedDtGte as any instanceof Date) ?
                    (affectsUpdatedDtGte as any).toISOString() :
                    affectsUpdatedDtGte;
            }

            if (affectsUpdatedDtLt !== undefined) {
                localVarQueryParameter['affects__updated_dt__lt'] = (affectsUpdatedDtLt as any instanceof Date) ?
                    (affectsUpdatedDtLt as any).toISOString() :
                    affectsUpdatedDtLt;
            }

            if (affectsUpdatedDtLte !== undefined) {
                localVarQueryParameter['affects__updated_dt__lte'] = (affectsUpdatedDtLte as any instanceof Date) ?
                    (affectsUpdatedDtLte as any).toISOString() :
                    affectsUpdatedDtLte;
            }

            if (affectsUuid !== undefined) {
                localVarQueryParameter['affects__uuid'] = affectsUuid;
            }

            if (bzId !== undefined) {
                localVarQueryParameter['bz_id'] = bzId;
            }

            if (changedAfter !== undefined) {
                localVarQueryParameter['changed_after'] = (changedAfter as any instanceof Date) ?
                    (changedAfter as any).toISOString() :
                    changedAfter;
            }

            if (changedBefore !== undefined) {
                localVarQueryParameter['changed_before'] = (changedBefore as any instanceof Date) ?
                    (changedBefore as any).toISOString() :
                    changedBefore;
            }

            if (commentZero !== undefined) {
                localVarQueryParameter['comment_zero'] = commentZero;
            }

            if (components) {
                localVarQueryParameter['components'] = components.join(COLLECTION_FORMATS.csv);
            }

            if (createdDt !== undefined) {
                localVarQueryParameter['created_dt'] = (createdDt as any instanceof Date) ?
                    (createdDt as any).toISOString() :
                    createdDt;
            }

            if (createdDtDate !== undefined) {
                localVarQueryParameter['created_dt__date'] = (createdDtDate as any instanceof Date) ?
                    (createdDtDate as any).toISOString().substr(0,10) :
                    createdDtDate;
            }

            if (createdDtDateGte !== undefined) {
                localVarQueryParameter['created_dt__date__gte'] = (createdDtDateGte as any instanceof Date) ?
                    (createdDtDateGte as any).toISOString().substr(0,10) :
                    createdDtDateGte;
            }

            if (createdDtDateLte !== undefined) {
                localVarQueryParameter['created_dt__date__lte'] = (createdDtDateLte as any instanceof Date) ?
                    (createdDtDateLte as any).toISOString().substr(0,10) :
                    createdDtDateLte;
            }

            if (createdDtGt !== undefined) {
                localVarQueryParameter['created_dt__gt'] = (createdDtGt as any instanceof Date) ?
                    (createdDtGt as any).toISOString() :
                    createdDtGt;
            }

            if (createdDtGte !== undefined) {
                localVarQueryParameter['created_dt__gte'] = (createdDtGte as any instanceof Date) ?
                    (createdDtGte as any).toISOString() :
                    createdDtGte;
            }

            if (createdDtLt !== undefined) {
                localVarQueryParameter['created_dt__lt'] = (createdDtLt as any instanceof Date) ?
                    (createdDtLt as any).toISOString() :
                    createdDtLt;
            }

            if (createdDtLte !== undefined) {
                localVarQueryParameter['created_dt__lte'] = (createdDtLte as any instanceof Date) ?
                    (createdDtLte as any).toISOString() :
                    createdDtLte;
            }

            if (cveDescription !== undefined) {
                localVarQueryParameter['cve_description'] = cveDescription;
            }

            if (cveDescriptionIsempty !== undefined) {
                localVarQueryParameter['cve_description__isempty'] = cveDescriptionIsempty;
            }

            if (cveId) {
                localVarQueryParameter['cve_id'] = cveId.join(COLLECTION_FORMATS.csv);
            }

            if (cveIdIsempty !== undefined) {
                localVarQueryParameter['cve_id__isempty'] = cveIdIsempty;
            }

            if (cvss2NistIsempty !== undefined) {
                localVarQueryParameter['cvss2_nist__isempty'] = cvss2NistIsempty;
            }

            if (cvss2RhIsempty !== undefined) {
                localVarQueryParameter['cvss2_rh__isempty'] = cvss2RhIsempty;
            }

            if (cvss3NistIsempty !== undefined) {
                localVarQueryParameter['cvss3_nist__isempty'] = cvss3NistIsempty;
            }

            if (cvss3RhIsempty !== undefined) {
                localVarQueryParameter['cvss3_rh__isempty'] = cvss3RhIsempty;
            }

            if (cvss4NistIsempty !== undefined) {
                localVarQueryParameter['cvss4_nist__isempty'] = cvss4NistIsempty;
            }

            if (cvss4RhIsempty !== undefined) {
                localVarQueryParameter['cvss4_rh__isempty'] = cvss4RhIsempty;
            }

            if (cvssScoresComment !== undefined) {
                localVarQueryParameter['cvss_scores__comment'] = cvssScoresComment;
            }

            if (cvssScoresCreatedDt !== undefined) {
                localVarQueryParameter['cvss_scores__created_dt'] = (cvssScoresCreatedDt as any instanceof Date) ?
                    (cvssScoresCreatedDt as any).toISOString() :
                    cvssScoresCreatedDt;
            }

            if (cvssScoresCreatedDtDate !== undefined) {
                localVarQueryParameter['cvss_scores__created_dt__date'] = (cvssScoresCreatedDtDate as any instanceof Date) ?
                    (cvssScoresCreatedDtDate as any).toISOString().substr(0,10) :
                    cvssScoresCreatedDtDate;
            }

            if (cvssScoresCreatedDtDateGte !== undefined) {
                localVarQueryParameter['cvss_scores__created_dt__date__gte'] = (cvssScoresCreatedDtDateGte as any instanceof Date) ?
                    (cvssScoresCreatedDtDateGte as any).toISOString().substr(0,10) :
                    cvssScoresCreatedDtDateGte;
            }

            if (cvssScoresCreatedDtDateLte !== undefined) {
                localVarQueryParameter['cvss_scores__created_dt__date__lte'] = (cvssScoresCreatedDtDateLte as any instanceof Date) ?
                    (cvssScoresCreatedDtDateLte as any).toISOString().substr(0,10) :
                    cvssScoresCreatedDtDateLte;
            }

            if (cvssScoresCreatedDtGt !== undefined) {
                localVarQueryParameter['cvss_scores__created_dt__gt'] = (cvssScoresCreatedDtGt as any instanceof Date) ?
                    (cvssScoresCreatedDtGt as any).toISOString() :
                    cvssScoresCreatedDtGt;
            }

            if (cvssScoresCreatedDtGte !== undefined) {
                localVarQueryParameter['cvss_scores__created_dt__gte'] = (cvssScoresCreatedDtGte as any instanceof Date) ?
                    (cvssScoresCreatedDtGte as any).toISOString() :
                    cvssScoresCreatedDtGte;
            }

            if (cvssScoresCreatedDtLt !== undefined) {
                localVarQueryParameter['cvss_scores__created_dt__lt'] = (cvssScoresCreatedDtLt as any instanceof Date) ?
                    (cvssScoresCreatedDtLt as any).toISOString() :
                    cvssScoresCreatedDtLt;
            }

            if (cvssScoresCreatedDtLte !== undefined) {
                localVarQueryParameter['cvss_scores__created_dt__lte'] = (cvssScoresCreatedDtLte as any instanceof Date) ?
                    (cvssScoresCreatedDtLte as any).toISOString() :
                    cvssScoresCreatedDtLte;
            }

            if (cvssScoresCvssVersion !== undefined) {
                localVarQueryParameter['cvss_scores__cvss_version'] = cvssScoresCvssVersion;
            }

            if (cvssScoresIssuer !== undefined) {
                localVarQueryParameter['cvss_scores__issuer'] = cvssScoresIssuer;
            }

            if (cvssScoresScore !== undefined) {
                localVarQueryParameter['cvss_scores__score'] = cvssScoresScore;
            }

            if (cvssScoresUpdatedDt !== undefined) {
                localVarQueryParameter['cvss_scores__updated_dt'] = (cvssScoresUpdatedDt as any instanceof Date) ?
                    (cvssScoresUpdatedDt as any).toISOString() :
                    cvssScoresUpdatedDt;
            }

            if (cvssScoresUpdatedDtDate !== undefined) {
                localVarQueryParameter['cvss_scores__updated_dt__date'] = (cvssScoresUpdatedDtDate as any instanceof Date) ?
                    (cvssScoresUpdatedDtDate as any).toISOString().substr(0,10) :
                    cvssScoresUpdatedDtDate;
            }

            if (cvssScoresUpdatedDtDateGte !== undefined) {
                localVarQueryParameter['cvss_scores__updated_dt__date__gte'] = (cvssScoresUpdatedDtDateGte as any instanceof Date) ?
                    (cvssScoresUpdatedDtDateGte as any).toISOString().substr(0,10) :
                    cvssScoresUpdatedDtDateGte;
            }

            if (cvssScoresUpdatedDtDateLte !== undefined) {
                localVarQueryParameter['cvss_scores__updated_dt__date__lte'] = (cvssScoresUpdatedDtDateLte as any instanceof Date) ?
                    (cvssScoresUpdatedDtDateLte as any).toISOString().substr(0,10) :
                    cvssScoresUpdatedDtDateLte;
            }

            if (cvssScoresUpdatedDtGt !== undefined) {
                localVarQueryParameter['cvss_scores__updated_dt__gt'] = (cvssScoresUpdatedDtGt as any instanceof Date) ?
                    (cvssScoresUpdatedDtGt as any).toISOString() :
                    cvssScoresUpdatedDtGt;
            }

            if (cvssScoresUpdatedDtGte !== undefined) {
                localVarQueryParameter['cvss_scores__updated_dt__gte'] = (cvssScoresUpdatedDtGte as any instanceof Date) ?
                    (cvssScoresUpdatedDtGte as any).toISOString() :
                    cvssScoresUpdatedDtGte;
            }

            if (cvssScoresUpdatedDtLt !== undefined) {
                localVarQueryParameter['cvss_scores__updated_dt__lt'] = (cvssScoresUpdatedDtLt as any instanceof Date) ?
                    (cvssScoresUpdatedDtLt as any).toISOString() :
                    cvssScoresUpdatedDtLt;
            }

            if (cvssScoresUpdatedDtLte !== undefined) {
                localVarQueryParameter['cvss_scores__updated_dt__lte'] = (cvssScoresUpdatedDtLte as any instanceof Date) ?
                    (cvssScoresUpdatedDtLte as any).toISOString() :
                    cvssScoresUpdatedDtLte;
            }

            if (cvssScoresUuid !== undefined) {
                localVarQueryParameter['cvss_scores__uuid'] = cvssScoresUuid;
            }

            if (cvssScoresVector !== undefined) {
                localVarQueryParameter['cvss_scores__vector'] = cvssScoresVector;
            }

            if (cweId !== undefined) {
                localVarQueryParameter['cwe_id'] = cweId;
            }

            if (cweIdIsempty !== undefined) {
                localVarQueryParameter['cwe_id__isempty'] = cweIdIsempty;
            }

            if (embargoed !== undefined) {
                localVarQueryParameter['embargoed'] = embargoed;
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (impact !== undefined) {
                localVarQueryParameter['impact'] = impact;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }

            if (includeMetaAttr) {
                localVarQueryParameter['include_meta_attr'] = includeMetaAttr;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (majorIncidentStartDt !== undefined) {
                localVarQueryParameter['major_incident_start_dt'] = (majorIncidentStartDt as any instanceof Date) ?
                    (majorIncidentStartDt as any).toISOString() :
                    majorIncidentStartDt;
            }

            if (majorIncidentStartDtDate !== undefined) {
                localVarQueryParameter['major_incident_start_dt__date'] = (majorIncidentStartDtDate as any instanceof Date) ?
                    (majorIncidentStartDtDate as any).toISOString().substr(0,10) :
                    majorIncidentStartDtDate;
            }

            if (majorIncidentStartDtDateGte !== undefined) {
                localVarQueryParameter['major_incident_start_dt__date__gte'] = (majorIncidentStartDtDateGte as any instanceof Date) ?
                    (majorIncidentStartDtDateGte as any).toISOString().substr(0,10) :
                    majorIncidentStartDtDateGte;
            }

            if (majorIncidentStartDtDateLte !== undefined) {
                localVarQueryParameter['major_incident_start_dt__date__lte'] = (majorIncidentStartDtDateLte as any instanceof Date) ?
                    (majorIncidentStartDtDateLte as any).toISOString().substr(0,10) :
                    majorIncidentStartDtDateLte;
            }

            if (majorIncidentStartDtGt !== undefined) {
                localVarQueryParameter['major_incident_start_dt__gt'] = (majorIncidentStartDtGt as any instanceof Date) ?
                    (majorIncidentStartDtGt as any).toISOString() :
                    majorIncidentStartDtGt;
            }

            if (majorIncidentStartDtGte !== undefined) {
                localVarQueryParameter['major_incident_start_dt__gte'] = (majorIncidentStartDtGte as any instanceof Date) ?
                    (majorIncidentStartDtGte as any).toISOString() :
                    majorIncidentStartDtGte;
            }

            if (majorIncidentStartDtLt !== undefined) {
                localVarQueryParameter['major_incident_start_dt__lt'] = (majorIncidentStartDtLt as any instanceof Date) ?
                    (majorIncidentStartDtLt as any).toISOString() :
                    majorIncidentStartDtLt;
            }

            if (majorIncidentStartDtLte !== undefined) {
                localVarQueryParameter['major_incident_start_dt__lte'] = (majorIncidentStartDtLte as any instanceof Date) ?
                    (majorIncidentStartDtLte as any).toISOString() :
                    majorIncidentStartDtLte;
            }

            if (majorIncidentState !== undefined) {
                localVarQueryParameter['major_incident_state'] = majorIncidentState;
            }

            if (mitigationIsempty !== undefined) {
                localVarQueryParameter['mitigation__isempty'] = mitigationIsempty;
            }

            if (nistCvssValidation !== undefined) {
                localVarQueryParameter['nist_cvss_validation'] = nistCvssValidation;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (order) {
                localVarQueryParameter['order'] = order.join(COLLECTION_FORMATS.csv);
            }

            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }

            if (ownerIsempty !== undefined) {
                localVarQueryParameter['owner__isempty'] = ownerIsempty;
            }

            if (referencesCreatedDt !== undefined) {
                localVarQueryParameter['references__created_dt'] = (referencesCreatedDt as any instanceof Date) ?
                    (referencesCreatedDt as any).toISOString() :
                    referencesCreatedDt;
            }

            if (referencesCreatedDtDate !== undefined) {
                localVarQueryParameter['references__created_dt__date'] = (referencesCreatedDtDate as any instanceof Date) ?
                    (referencesCreatedDtDate as any).toISOString().substr(0,10) :
                    referencesCreatedDtDate;
            }

            if (referencesCreatedDtDateGte !== undefined) {
                localVarQueryParameter['references__created_dt__date__gte'] = (referencesCreatedDtDateGte as any instanceof Date) ?
                    (referencesCreatedDtDateGte as any).toISOString().substr(0,10) :
                    referencesCreatedDtDateGte;
            }

            if (referencesCreatedDtDateLte !== undefined) {
                localVarQueryParameter['references__created_dt__date__lte'] = (referencesCreatedDtDateLte as any instanceof Date) ?
                    (referencesCreatedDtDateLte as any).toISOString().substr(0,10) :
                    referencesCreatedDtDateLte;
            }

            if (referencesCreatedDtGt !== undefined) {
                localVarQueryParameter['references__created_dt__gt'] = (referencesCreatedDtGt as any instanceof Date) ?
                    (referencesCreatedDtGt as any).toISOString() :
                    referencesCreatedDtGt;
            }

            if (referencesCreatedDtGte !== undefined) {
                localVarQueryParameter['references__created_dt__gte'] = (referencesCreatedDtGte as any instanceof Date) ?
                    (referencesCreatedDtGte as any).toISOString() :
                    referencesCreatedDtGte;
            }

            if (referencesCreatedDtLt !== undefined) {
                localVarQueryParameter['references__created_dt__lt'] = (referencesCreatedDtLt as any instanceof Date) ?
                    (referencesCreatedDtLt as any).toISOString() :
                    referencesCreatedDtLt;
            }

            if (referencesCreatedDtLte !== undefined) {
                localVarQueryParameter['references__created_dt__lte'] = (referencesCreatedDtLte as any instanceof Date) ?
                    (referencesCreatedDtLte as any).toISOString() :
                    referencesCreatedDtLte;
            }

            if (referencesDescription !== undefined) {
                localVarQueryParameter['references__description'] = referencesDescription;
            }

            if (referencesType !== undefined) {
                localVarQueryParameter['references__type'] = referencesType;
            }

            if (referencesUpdatedDt !== undefined) {
                localVarQueryParameter['references__updated_dt'] = (referencesUpdatedDt as any instanceof Date) ?
                    (referencesUpdatedDt as any).toISOString() :
                    referencesUpdatedDt;
            }

            if (referencesUpdatedDtDate !== undefined) {
                localVarQueryParameter['references__updated_dt__date'] = (referencesUpdatedDtDate as any instanceof Date) ?
                    (referencesUpdatedDtDate as any).toISOString().substr(0,10) :
                    referencesUpdatedDtDate;
            }

            if (referencesUpdatedDtDateGte !== undefined) {
                localVarQueryParameter['references__updated_dt__date__gte'] = (referencesUpdatedDtDateGte as any instanceof Date) ?
                    (referencesUpdatedDtDateGte as any).toISOString().substr(0,10) :
                    referencesUpdatedDtDateGte;
            }

            if (referencesUpdatedDtDateLte !== undefined) {
                localVarQueryParameter['references__updated_dt__date__lte'] = (referencesUpdatedDtDateLte as any instanceof Date) ?
                    (referencesUpdatedDtDateLte as any).toISOString().substr(0,10) :
                    referencesUpdatedDtDateLte;
            }

            if (referencesUpdatedDtGt !== undefined) {
                localVarQueryParameter['references__updated_dt__gt'] = (referencesUpdatedDtGt as any instanceof Date) ?
                    (referencesUpdatedDtGt as any).toISOString() :
                    referencesUpdatedDtGt;
            }

            if (referencesUpdatedDtGte !== undefined) {
                localVarQueryParameter['references__updated_dt__gte'] = (referencesUpdatedDtGte as any instanceof Date) ?
                    (referencesUpdatedDtGte as any).toISOString() :
                    referencesUpdatedDtGte;
            }

            if (referencesUpdatedDtLt !== undefined) {
                localVarQueryParameter['references__updated_dt__lt'] = (referencesUpdatedDtLt as any instanceof Date) ?
                    (referencesUpdatedDtLt as any).toISOString() :
                    referencesUpdatedDtLt;
            }

            if (referencesUpdatedDtLte !== undefined) {
                localVarQueryParameter['references__updated_dt__lte'] = (referencesUpdatedDtLte as any instanceof Date) ?
                    (referencesUpdatedDtLte as any).toISOString() :
                    referencesUpdatedDtLte;
            }

            if (referencesUrl !== undefined) {
                localVarQueryParameter['references__url'] = referencesUrl;
            }

            if (referencesUuid !== undefined) {
                localVarQueryParameter['references__uuid'] = referencesUuid;
            }

            if (reportedDt !== undefined) {
                localVarQueryParameter['reported_dt'] = (reportedDt as any instanceof Date) ?
                    (reportedDt as any).toISOString() :
                    reportedDt;
            }

            if (reportedDtDate !== undefined) {
                localVarQueryParameter['reported_dt__date'] = (reportedDtDate as any instanceof Date) ?
                    (reportedDtDate as any).toISOString().substr(0,10) :
                    reportedDtDate;
            }

            if (reportedDtDateGte !== undefined) {
                localVarQueryParameter['reported_dt__date__gte'] = (reportedDtDateGte as any instanceof Date) ?
                    (reportedDtDateGte as any).toISOString().substr(0,10) :
                    reportedDtDateGte;
            }

            if (reportedDtDateLte !== undefined) {
                localVarQueryParameter['reported_dt__date__lte'] = (reportedDtDateLte as any instanceof Date) ?
                    (reportedDtDateLte as any).toISOString().substr(0,10) :
                    reportedDtDateLte;
            }

            if (reportedDtGt !== undefined) {
                localVarQueryParameter['reported_dt__gt'] = (reportedDtGt as any instanceof Date) ?
                    (reportedDtGt as any).toISOString() :
                    reportedDtGt;
            }

            if (reportedDtGte !== undefined) {
                localVarQueryParameter['reported_dt__gte'] = (reportedDtGte as any instanceof Date) ?
                    (reportedDtGte as any).toISOString() :
                    reportedDtGte;
            }

            if (reportedDtLt !== undefined) {
                localVarQueryParameter['reported_dt__lt'] = (reportedDtLt as any instanceof Date) ?
                    (reportedDtLt as any).toISOString() :
                    reportedDtLt;
            }

            if (reportedDtLte !== undefined) {
                localVarQueryParameter['reported_dt__lte'] = (reportedDtLte as any instanceof Date) ?
                    (reportedDtLte as any).toISOString() :
                    reportedDtLte;
            }

            if (requiresCveDescription !== undefined) {
                localVarQueryParameter['requires_cve_description'] = requiresCveDescription;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (statement !== undefined) {
                localVarQueryParameter['statement'] = statement;
            }

            if (statementIsempty !== undefined) {
                localVarQueryParameter['statement__isempty'] = statementIsempty;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (trackerIds) {
                localVarQueryParameter['tracker_ids'] = trackerIds;
            }

            if (unembargoDt !== undefined) {
                localVarQueryParameter['unembargo_dt'] = (unembargoDt as any instanceof Date) ?
                    (unembargoDt as any).toISOString() :
                    unembargoDt;
            }

            if (updatedDt !== undefined) {
                localVarQueryParameter['updated_dt'] = (updatedDt as any instanceof Date) ?
                    (updatedDt as any).toISOString() :
                    updatedDt;
            }

            if (updatedDtDate !== undefined) {
                localVarQueryParameter['updated_dt__date'] = (updatedDtDate as any instanceof Date) ?
                    (updatedDtDate as any).toISOString().substr(0,10) :
                    updatedDtDate;
            }

            if (updatedDtDateGte !== undefined) {
                localVarQueryParameter['updated_dt__date__gte'] = (updatedDtDateGte as any instanceof Date) ?
                    (updatedDtDateGte as any).toISOString().substr(0,10) :
                    updatedDtDateGte;
            }

            if (updatedDtDateLte !== undefined) {
                localVarQueryParameter['updated_dt__date__lte'] = (updatedDtDateLte as any instanceof Date) ?
                    (updatedDtDateLte as any).toISOString().substr(0,10) :
                    updatedDtDateLte;
            }

            if (updatedDtGt !== undefined) {
                localVarQueryParameter['updated_dt__gt'] = (updatedDtGt as any instanceof Date) ?
                    (updatedDtGt as any).toISOString() :
                    updatedDtGt;
            }

            if (updatedDtGte !== undefined) {
                localVarQueryParameter['updated_dt__gte'] = (updatedDtGte as any instanceof Date) ?
                    (updatedDtGte as any).toISOString() :
                    updatedDtGte;
            }

            if (updatedDtLt !== undefined) {
                localVarQueryParameter['updated_dt__lt'] = (updatedDtLt as any instanceof Date) ?
                    (updatedDtLt as any).toISOString() :
                    updatedDtLt;
            }

            if (updatedDtLte !== undefined) {
                localVarQueryParameter['updated_dt__lte'] = (updatedDtLte as any instanceof Date) ?
                    (updatedDtLte as any).toISOString() :
                    updatedDtLte;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (workflowState) {
                localVarQueryParameter['workflow_state'] = workflowState.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId 
         * @param {FlawPackageVersionPost} flawPackageVersionPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsPackageVersionsCreate: async (bugzillaApiKey: string, flawId: string, flawPackageVersionPost: FlawPackageVersionPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bugzillaApiKey' is not null or undefined
            assertParamExists('osidbApiV1FlawsPackageVersionsCreate', 'bugzillaApiKey', bugzillaApiKey)
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsPackageVersionsCreate', 'flawId', flawId)
            // verify required parameter 'flawPackageVersionPost' is not null or undefined
            assertParamExists('osidbApiV1FlawsPackageVersionsCreate', 'flawPackageVersionPost', flawPackageVersionPost)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/package_versions`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (bugzillaApiKey != null) {
                localVarHeaderParameter['Bugzilla-Api-Key'] = String(bugzillaApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flawPackageVersionPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Destroy the instance and proxy the delete to Bugzilla
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsPackageVersionsDestroy: async (bugzillaApiKey: string, flawId: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bugzillaApiKey' is not null or undefined
            assertParamExists('osidbApiV1FlawsPackageVersionsDestroy', 'bugzillaApiKey', bugzillaApiKey)
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsPackageVersionsDestroy', 'flawId', flawId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osidbApiV1FlawsPackageVersionsDestroy', 'id', id)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/package_versions/{id}`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (bugzillaApiKey != null) {
                localVarHeaderParameter['Bugzilla-Api-Key'] = String(bugzillaApiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [_package] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {string} [versionsVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsPackageVersionsList: async (flawId: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, excludeFields?: Array<string>, includeFields?: Array<string>, limit?: number, offset?: number, _package?: string, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, versionsVersion?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsPackageVersionsList', 'flawId', flawId)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/package_versions`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (createdDt !== undefined) {
                localVarQueryParameter['created_dt'] = (createdDt as any instanceof Date) ?
                    (createdDt as any).toISOString() :
                    createdDt;
            }

            if (createdDtDate !== undefined) {
                localVarQueryParameter['created_dt__date'] = (createdDtDate as any instanceof Date) ?
                    (createdDtDate as any).toISOString().substr(0,10) :
                    createdDtDate;
            }

            if (createdDtDateGte !== undefined) {
                localVarQueryParameter['created_dt__date__gte'] = (createdDtDateGte as any instanceof Date) ?
                    (createdDtDateGte as any).toISOString().substr(0,10) :
                    createdDtDateGte;
            }

            if (createdDtDateLte !== undefined) {
                localVarQueryParameter['created_dt__date__lte'] = (createdDtDateLte as any instanceof Date) ?
                    (createdDtDateLte as any).toISOString().substr(0,10) :
                    createdDtDateLte;
            }

            if (createdDtGt !== undefined) {
                localVarQueryParameter['created_dt__gt'] = (createdDtGt as any instanceof Date) ?
                    (createdDtGt as any).toISOString() :
                    createdDtGt;
            }

            if (createdDtGte !== undefined) {
                localVarQueryParameter['created_dt__gte'] = (createdDtGte as any instanceof Date) ?
                    (createdDtGte as any).toISOString() :
                    createdDtGte;
            }

            if (createdDtLt !== undefined) {
                localVarQueryParameter['created_dt__lt'] = (createdDtLt as any instanceof Date) ?
                    (createdDtLt as any).toISOString() :
                    createdDtLt;
            }

            if (createdDtLte !== undefined) {
                localVarQueryParameter['created_dt__lte'] = (createdDtLte as any instanceof Date) ?
                    (createdDtLte as any).toISOString() :
                    createdDtLte;
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (_package !== undefined) {
                localVarQueryParameter['package'] = _package;
            }

            if (updatedDt !== undefined) {
                localVarQueryParameter['updated_dt'] = (updatedDt as any instanceof Date) ?
                    (updatedDt as any).toISOString() :
                    updatedDt;
            }

            if (updatedDtDate !== undefined) {
                localVarQueryParameter['updated_dt__date'] = (updatedDtDate as any instanceof Date) ?
                    (updatedDtDate as any).toISOString().substr(0,10) :
                    updatedDtDate;
            }

            if (updatedDtDateGte !== undefined) {
                localVarQueryParameter['updated_dt__date__gte'] = (updatedDtDateGte as any instanceof Date) ?
                    (updatedDtDateGte as any).toISOString().substr(0,10) :
                    updatedDtDateGte;
            }

            if (updatedDtDateLte !== undefined) {
                localVarQueryParameter['updated_dt__date__lte'] = (updatedDtDateLte as any instanceof Date) ?
                    (updatedDtDateLte as any).toISOString().substr(0,10) :
                    updatedDtDateLte;
            }

            if (updatedDtGt !== undefined) {
                localVarQueryParameter['updated_dt__gt'] = (updatedDtGt as any instanceof Date) ?
                    (updatedDtGt as any).toISOString() :
                    updatedDtGt;
            }

            if (updatedDtGte !== undefined) {
                localVarQueryParameter['updated_dt__gte'] = (updatedDtGte as any instanceof Date) ?
                    (updatedDtGte as any).toISOString() :
                    updatedDtGte;
            }

            if (updatedDtLt !== undefined) {
                localVarQueryParameter['updated_dt__lt'] = (updatedDtLt as any instanceof Date) ?
                    (updatedDtLt as any).toISOString() :
                    updatedDtLt;
            }

            if (updatedDtLte !== undefined) {
                localVarQueryParameter['updated_dt__lte'] = (updatedDtLte as any instanceof Date) ?
                    (updatedDtLte as any).toISOString() :
                    updatedDtLte;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (versionsVersion !== undefined) {
                localVarQueryParameter['versions__version'] = versionsVersion;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} id 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsPackageVersionsRetrieve: async (flawId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsPackageVersionsRetrieve', 'flawId', flawId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osidbApiV1FlawsPackageVersionsRetrieve', 'id', id)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/package_versions/{id}`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId 
         * @param {string} id 
         * @param {FlawPackageVersionPut} flawPackageVersionPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsPackageVersionsUpdate: async (bugzillaApiKey: string, flawId: string, id: string, flawPackageVersionPut: FlawPackageVersionPut, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bugzillaApiKey' is not null or undefined
            assertParamExists('osidbApiV1FlawsPackageVersionsUpdate', 'bugzillaApiKey', bugzillaApiKey)
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsPackageVersionsUpdate', 'flawId', flawId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osidbApiV1FlawsPackageVersionsUpdate', 'id', id)
            // verify required parameter 'flawPackageVersionPut' is not null or undefined
            assertParamExists('osidbApiV1FlawsPackageVersionsUpdate', 'flawPackageVersionPut', flawPackageVersionPut)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/package_versions/{id}`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (bugzillaApiKey != null) {
                localVarHeaderParameter['Bugzilla-Api-Key'] = String(bugzillaApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flawPackageVersionPut, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * workflow promotion API endpoint  try to adjust workflow classification of flaw to the next state available return its workflow:state classification or errors if not possible to promote
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {string} flawId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsPromoteCreate: async (bugzillaApiKey: string, jiraApiKey: string, flawId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bugzillaApiKey' is not null or undefined
            assertParamExists('osidbApiV1FlawsPromoteCreate', 'bugzillaApiKey', bugzillaApiKey)
            // verify required parameter 'jiraApiKey' is not null or undefined
            assertParamExists('osidbApiV1FlawsPromoteCreate', 'jiraApiKey', jiraApiKey)
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsPromoteCreate', 'flawId', flawId)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/promote`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (bugzillaApiKey != null) {
                localVarHeaderParameter['Bugzilla-Api-Key'] = String(bugzillaApiKey);
            }

            if (jiraApiKey != null) {
                localVarHeaderParameter['Jira-Api-Key'] = String(jiraApiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId 
         * @param {FlawReferencePost} flawReferencePost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsReferencesCreate: async (bugzillaApiKey: string, flawId: string, flawReferencePost: FlawReferencePost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bugzillaApiKey' is not null or undefined
            assertParamExists('osidbApiV1FlawsReferencesCreate', 'bugzillaApiKey', bugzillaApiKey)
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsReferencesCreate', 'flawId', flawId)
            // verify required parameter 'flawReferencePost' is not null or undefined
            assertParamExists('osidbApiV1FlawsReferencesCreate', 'flawReferencePost', flawReferencePost)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/references`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (bugzillaApiKey != null) {
                localVarHeaderParameter['Bugzilla-Api-Key'] = String(bugzillaApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flawReferencePost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Destroy the instance and proxy the delete to Bugzilla
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsReferencesDestroy: async (bugzillaApiKey: string, flawId: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bugzillaApiKey' is not null or undefined
            assertParamExists('osidbApiV1FlawsReferencesDestroy', 'bugzillaApiKey', bugzillaApiKey)
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsReferencesDestroy', 'flawId', flawId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osidbApiV1FlawsReferencesDestroy', 'id', id)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/references/{id}`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (bugzillaApiKey != null) {
                localVarHeaderParameter['Bugzilla-Api-Key'] = String(bugzillaApiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {string} [description] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {'ARTICLE' | 'EXTERNAL' | 'SOURCE'} [type] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [url] 
         * @param {string} [uuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsReferencesList: async (flawId: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, description?: string, excludeFields?: Array<string>, includeFields?: Array<string>, limit?: number, offset?: number, type?: 'ARTICLE' | 'EXTERNAL' | 'SOURCE', updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, url?: string, uuid?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsReferencesList', 'flawId', flawId)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/references`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (createdDt !== undefined) {
                localVarQueryParameter['created_dt'] = (createdDt as any instanceof Date) ?
                    (createdDt as any).toISOString() :
                    createdDt;
            }

            if (createdDtDate !== undefined) {
                localVarQueryParameter['created_dt__date'] = (createdDtDate as any instanceof Date) ?
                    (createdDtDate as any).toISOString().substr(0,10) :
                    createdDtDate;
            }

            if (createdDtDateGte !== undefined) {
                localVarQueryParameter['created_dt__date__gte'] = (createdDtDateGte as any instanceof Date) ?
                    (createdDtDateGte as any).toISOString().substr(0,10) :
                    createdDtDateGte;
            }

            if (createdDtDateLte !== undefined) {
                localVarQueryParameter['created_dt__date__lte'] = (createdDtDateLte as any instanceof Date) ?
                    (createdDtDateLte as any).toISOString().substr(0,10) :
                    createdDtDateLte;
            }

            if (createdDtGt !== undefined) {
                localVarQueryParameter['created_dt__gt'] = (createdDtGt as any instanceof Date) ?
                    (createdDtGt as any).toISOString() :
                    createdDtGt;
            }

            if (createdDtGte !== undefined) {
                localVarQueryParameter['created_dt__gte'] = (createdDtGte as any instanceof Date) ?
                    (createdDtGte as any).toISOString() :
                    createdDtGte;
            }

            if (createdDtLt !== undefined) {
                localVarQueryParameter['created_dt__lt'] = (createdDtLt as any instanceof Date) ?
                    (createdDtLt as any).toISOString() :
                    createdDtLt;
            }

            if (createdDtLte !== undefined) {
                localVarQueryParameter['created_dt__lte'] = (createdDtLte as any instanceof Date) ?
                    (createdDtLte as any).toISOString() :
                    createdDtLte;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (updatedDt !== undefined) {
                localVarQueryParameter['updated_dt'] = (updatedDt as any instanceof Date) ?
                    (updatedDt as any).toISOString() :
                    updatedDt;
            }

            if (updatedDtDate !== undefined) {
                localVarQueryParameter['updated_dt__date'] = (updatedDtDate as any instanceof Date) ?
                    (updatedDtDate as any).toISOString().substr(0,10) :
                    updatedDtDate;
            }

            if (updatedDtDateGte !== undefined) {
                localVarQueryParameter['updated_dt__date__gte'] = (updatedDtDateGte as any instanceof Date) ?
                    (updatedDtDateGte as any).toISOString().substr(0,10) :
                    updatedDtDateGte;
            }

            if (updatedDtDateLte !== undefined) {
                localVarQueryParameter['updated_dt__date__lte'] = (updatedDtDateLte as any instanceof Date) ?
                    (updatedDtDateLte as any).toISOString().substr(0,10) :
                    updatedDtDateLte;
            }

            if (updatedDtGt !== undefined) {
                localVarQueryParameter['updated_dt__gt'] = (updatedDtGt as any instanceof Date) ?
                    (updatedDtGt as any).toISOString() :
                    updatedDtGt;
            }

            if (updatedDtGte !== undefined) {
                localVarQueryParameter['updated_dt__gte'] = (updatedDtGte as any instanceof Date) ?
                    (updatedDtGte as any).toISOString() :
                    updatedDtGte;
            }

            if (updatedDtLt !== undefined) {
                localVarQueryParameter['updated_dt__lt'] = (updatedDtLt as any instanceof Date) ?
                    (updatedDtLt as any).toISOString() :
                    updatedDtLt;
            }

            if (updatedDtLte !== undefined) {
                localVarQueryParameter['updated_dt__lte'] = (updatedDtLte as any instanceof Date) ?
                    (updatedDtLte as any).toISOString() :
                    updatedDtLte;
            }

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} id 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsReferencesRetrieve: async (flawId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsReferencesRetrieve', 'flawId', flawId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osidbApiV1FlawsReferencesRetrieve', 'id', id)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/references/{id}`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId 
         * @param {string} id 
         * @param {FlawReferencePut} flawReferencePut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsReferencesUpdate: async (bugzillaApiKey: string, flawId: string, id: string, flawReferencePut: FlawReferencePut, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bugzillaApiKey' is not null or undefined
            assertParamExists('osidbApiV1FlawsReferencesUpdate', 'bugzillaApiKey', bugzillaApiKey)
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsReferencesUpdate', 'flawId', flawId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osidbApiV1FlawsReferencesUpdate', 'id', id)
            // verify required parameter 'flawReferencePut' is not null or undefined
            assertParamExists('osidbApiV1FlawsReferencesUpdate', 'flawReferencePut', flawReferencePut)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/references/{id}`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (bugzillaApiKey != null) {
                localVarHeaderParameter['Bugzilla-Api-Key'] = String(bugzillaApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flawReferencePut, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * workflow promotion API endpoint  try to reject a flaw / task
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {string} flawId 
         * @param {Reject} reject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsRejectCreate: async (bugzillaApiKey: string, jiraApiKey: string, flawId: string, reject: Reject, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bugzillaApiKey' is not null or undefined
            assertParamExists('osidbApiV1FlawsRejectCreate', 'bugzillaApiKey', bugzillaApiKey)
            // verify required parameter 'jiraApiKey' is not null or undefined
            assertParamExists('osidbApiV1FlawsRejectCreate', 'jiraApiKey', jiraApiKey)
            // verify required parameter 'flawId' is not null or undefined
            assertParamExists('osidbApiV1FlawsRejectCreate', 'flawId', flawId)
            // verify required parameter 'reject' is not null or undefined
            assertParamExists('osidbApiV1FlawsRejectCreate', 'reject', reject)
            const localVarPath = `/osidb/api/v1/flaws/{flaw_id}/reject`
                .replace(`{${"flaw_id"}}`, encodeURIComponent(String(flawId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (bugzillaApiKey != null) {
                localVarHeaderParameter['Bugzilla-Api-Key'] = String(bugzillaApiKey);
            }

            if (jiraApiKey != null) {
                localVarHeaderParameter['Jira-Api-Key'] = String(jiraApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {Array<string>} [trackerIds] Filter only Flaws which are related to specified Trackers (through Affects). Multiple tracker IDs may be separated by commas. Also only Affects that have the specified Trackers related will be shown.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsRetrieve: async (id: string, excludeFields?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, trackerIds?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osidbApiV1FlawsRetrieve', 'id', id)
            const localVarPath = `/osidb/api/v1/flaws/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }

            if (includeMetaAttr) {
                localVarQueryParameter['include_meta_attr'] = includeMetaAttr;
            }

            if (trackerIds) {
                localVarQueryParameter['tracker_ids'] = trackerIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {string} id A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
         * @param {Flaw} flaw 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsUpdate: async (bugzillaApiKey: string, jiraApiKey: string, id: string, flaw: Flaw, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bugzillaApiKey' is not null or undefined
            assertParamExists('osidbApiV1FlawsUpdate', 'bugzillaApiKey', bugzillaApiKey)
            // verify required parameter 'jiraApiKey' is not null or undefined
            assertParamExists('osidbApiV1FlawsUpdate', 'jiraApiKey', jiraApiKey)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osidbApiV1FlawsUpdate', 'id', id)
            // verify required parameter 'flaw' is not null or undefined
            assertParamExists('osidbApiV1FlawsUpdate', 'flaw', flaw)
            const localVarPath = `/osidb/api/v1/flaws/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (bugzillaApiKey != null) {
                localVarHeaderParameter['Bugzilla-Api-Key'] = String(bugzillaApiKey);
            }

            if (jiraApiKey != null) {
                localVarHeaderParameter['Jira-Api-Key'] = String(jiraApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flaw, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HTTP get /manifest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1ManifestRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/osidb/api/v1/manifest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {'json' | 'yaml'} [format] 
         * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1SchemaRetrieve: async (format?: 'json' | 'yaml', lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/osidb/api/v1/schema/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication KerberosAuthentication required

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HTTP get /status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1StatusRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/osidb/api/v1/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {TrackerPost} trackerPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1TrackersCreate: async (bugzillaApiKey: string, jiraApiKey: string, trackerPost: TrackerPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bugzillaApiKey' is not null or undefined
            assertParamExists('osidbApiV1TrackersCreate', 'bugzillaApiKey', bugzillaApiKey)
            // verify required parameter 'jiraApiKey' is not null or undefined
            assertParamExists('osidbApiV1TrackersCreate', 'jiraApiKey', jiraApiKey)
            // verify required parameter 'trackerPost' is not null or undefined
            assertParamExists('osidbApiV1TrackersCreate', 'trackerPost', trackerPost)
            const localVarPath = `/osidb/api/v1/trackers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (bugzillaApiKey != null) {
                localVarHeaderParameter['Bugzilla-Api-Key'] = String(bugzillaApiKey);
            }

            if (jiraApiKey != null) {
                localVarHeaderParameter['Jira-Api-Key'] = String(jiraApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trackerPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {'' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED'} [affectsAffectedness] 
         * @param {string} [affectsCreatedDt] 
         * @param {string} [affectsCreatedDtDate] 
         * @param {string} [affectsCreatedDtDateGte] 
         * @param {string} [affectsCreatedDtDateLte] 
         * @param {string} [affectsCreatedDtGt] 
         * @param {string} [affectsCreatedDtGte] 
         * @param {string} [affectsCreatedDtLt] 
         * @param {string} [affectsCreatedDtLte] 
         * @param {boolean} [affectsEmbargoed] 
         * @param {Array<string>} [affectsFlawComponents] Multiple values may be separated by commas.
         * @param {string} [affectsFlawCreatedDt] 
         * @param {string} [affectsFlawCreatedDtDate] 
         * @param {string} [affectsFlawCreatedDtDateGte] 
         * @param {string} [affectsFlawCreatedDtDateLte] 
         * @param {string} [affectsFlawCreatedDtGt] 
         * @param {string} [affectsFlawCreatedDtGte] 
         * @param {string} [affectsFlawCreatedDtLt] 
         * @param {string} [affectsFlawCreatedDtLte] 
         * @param {string} [affectsFlawCveId] 
         * @param {string} [affectsFlawCweId] 
         * @param {boolean} [affectsFlawEmbargoed] 
         * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [affectsFlawImpact] 
         * @param {string} [affectsFlawReportedDt] 
         * @param {string} [affectsFlawReportedDtDate] 
         * @param {string} [affectsFlawReportedDtDateGte] 
         * @param {string} [affectsFlawReportedDtDateLte] 
         * @param {string} [affectsFlawReportedDtGt] 
         * @param {string} [affectsFlawReportedDtGte] 
         * @param {string} [affectsFlawReportedDtLt] 
         * @param {string} [affectsFlawReportedDtLte] 
         * @param {'' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'NVD' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'OSV' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF'} [affectsFlawSource] 
         * @param {string} [affectsFlawUnembargoDt] 
         * @param {string} [affectsFlawUpdatedDt] 
         * @param {string} [affectsFlawUpdatedDtDate] 
         * @param {string} [affectsFlawUpdatedDtDateGte] 
         * @param {string} [affectsFlawUpdatedDtDateLte] 
         * @param {string} [affectsFlawUpdatedDtGt] 
         * @param {string} [affectsFlawUpdatedDtGte] 
         * @param {string} [affectsFlawUpdatedDtLt] 
         * @param {string} [affectsFlawUpdatedDtLte] 
         * @param {string} [affectsFlawUuid] 
         * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [affectsImpact] 
         * @param {string} [affectsPsComponent] 
         * @param {string} [affectsPsModule] 
         * @param {'' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT'} [affectsResolution] 
         * @param {string} [affectsUpdatedDt] 
         * @param {string} [affectsUpdatedDtDate] 
         * @param {string} [affectsUpdatedDtDateGte] 
         * @param {string} [affectsUpdatedDtDateLte] 
         * @param {string} [affectsUpdatedDtGt] 
         * @param {string} [affectsUpdatedDtGte] 
         * @param {string} [affectsUpdatedDtLt] 
         * @param {string} [affectsUpdatedDtLte] 
         * @param {string} [affectsUuid] 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {boolean} [embargoed] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {string} [externalSystemId] 
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {Array<'-affects__affectedness' | '-affects__created_dt' | '-affects__embargoed' | '-affects__flaw__components' | '-affects__flaw__created_dt' | '-affects__flaw__cve_id' | '-affects__flaw__cwe_id' | '-affects__flaw__embargoed' | '-affects__flaw__impact' | '-affects__flaw__reported_dt' | '-affects__flaw__source' | '-affects__flaw__unembargo_dt' | '-affects__flaw__updated_dt' | '-affects__flaw__uuid' | '-affects__impact' | '-affects__ps_component' | '-affects__ps_module' | '-affects__resolution' | '-affects__updated_dt' | '-affects__uuid' | '-created_dt' | '-embargoed' | '-external_system_id' | '-ps_update_stream' | '-resolution' | '-status' | '-type' | '-updated_dt' | '-uuid' | 'affects__affectedness' | 'affects__created_dt' | 'affects__embargoed' | 'affects__flaw__components' | 'affects__flaw__created_dt' | 'affects__flaw__cve_id' | 'affects__flaw__cwe_id' | 'affects__flaw__embargoed' | 'affects__flaw__impact' | 'affects__flaw__reported_dt' | 'affects__flaw__source' | 'affects__flaw__unembargo_dt' | 'affects__flaw__updated_dt' | 'affects__flaw__uuid' | 'affects__impact' | 'affects__ps_component' | 'affects__ps_module' | 'affects__resolution' | 'affects__updated_dt' | 'affects__uuid' | 'created_dt' | 'embargoed' | 'external_system_id' | 'ps_update_stream' | 'resolution' | 'status' | 'type' | 'updated_dt' | 'uuid'>} [order] Ordering
         * @param {string} [psUpdateStream] 
         * @param {string} [resolution] 
         * @param {string} [status] 
         * @param {'BUGZILLA' | 'JIRA'} [type] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1TrackersList: async (affectsAffectedness?: '' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED', affectsCreatedDt?: string, affectsCreatedDtDate?: string, affectsCreatedDtDateGte?: string, affectsCreatedDtDateLte?: string, affectsCreatedDtGt?: string, affectsCreatedDtGte?: string, affectsCreatedDtLt?: string, affectsCreatedDtLte?: string, affectsEmbargoed?: boolean, affectsFlawComponents?: Array<string>, affectsFlawCreatedDt?: string, affectsFlawCreatedDtDate?: string, affectsFlawCreatedDtDateGte?: string, affectsFlawCreatedDtDateLte?: string, affectsFlawCreatedDtGt?: string, affectsFlawCreatedDtGte?: string, affectsFlawCreatedDtLt?: string, affectsFlawCreatedDtLte?: string, affectsFlawCveId?: string, affectsFlawCweId?: string, affectsFlawEmbargoed?: boolean, affectsFlawImpact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', affectsFlawReportedDt?: string, affectsFlawReportedDtDate?: string, affectsFlawReportedDtDateGte?: string, affectsFlawReportedDtDateLte?: string, affectsFlawReportedDtGt?: string, affectsFlawReportedDtGte?: string, affectsFlawReportedDtLt?: string, affectsFlawReportedDtLte?: string, affectsFlawSource?: '' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'NVD' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'OSV' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF', affectsFlawUnembargoDt?: string, affectsFlawUpdatedDt?: string, affectsFlawUpdatedDtDate?: string, affectsFlawUpdatedDtDateGte?: string, affectsFlawUpdatedDtDateLte?: string, affectsFlawUpdatedDtGt?: string, affectsFlawUpdatedDtGte?: string, affectsFlawUpdatedDtLt?: string, affectsFlawUpdatedDtLte?: string, affectsFlawUuid?: string, affectsImpact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', affectsPsComponent?: string, affectsPsModule?: string, affectsResolution?: '' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT', affectsUpdatedDt?: string, affectsUpdatedDtDate?: string, affectsUpdatedDtDateGte?: string, affectsUpdatedDtDateLte?: string, affectsUpdatedDtGt?: string, affectsUpdatedDtGte?: string, affectsUpdatedDtLt?: string, affectsUpdatedDtLte?: string, affectsUuid?: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, embargoed?: boolean, excludeFields?: Array<string>, externalSystemId?: string, includeFields?: Array<string>, includeMetaAttr?: Array<string>, limit?: number, offset?: number, order?: Array<'-affects__affectedness' | '-affects__created_dt' | '-affects__embargoed' | '-affects__flaw__components' | '-affects__flaw__created_dt' | '-affects__flaw__cve_id' | '-affects__flaw__cwe_id' | '-affects__flaw__embargoed' | '-affects__flaw__impact' | '-affects__flaw__reported_dt' | '-affects__flaw__source' | '-affects__flaw__unembargo_dt' | '-affects__flaw__updated_dt' | '-affects__flaw__uuid' | '-affects__impact' | '-affects__ps_component' | '-affects__ps_module' | '-affects__resolution' | '-affects__updated_dt' | '-affects__uuid' | '-created_dt' | '-embargoed' | '-external_system_id' | '-ps_update_stream' | '-resolution' | '-status' | '-type' | '-updated_dt' | '-uuid' | 'affects__affectedness' | 'affects__created_dt' | 'affects__embargoed' | 'affects__flaw__components' | 'affects__flaw__created_dt' | 'affects__flaw__cve_id' | 'affects__flaw__cwe_id' | 'affects__flaw__embargoed' | 'affects__flaw__impact' | 'affects__flaw__reported_dt' | 'affects__flaw__source' | 'affects__flaw__unembargo_dt' | 'affects__flaw__updated_dt' | 'affects__flaw__uuid' | 'affects__impact' | 'affects__ps_component' | 'affects__ps_module' | 'affects__resolution' | 'affects__updated_dt' | 'affects__uuid' | 'created_dt' | 'embargoed' | 'external_system_id' | 'ps_update_stream' | 'resolution' | 'status' | 'type' | 'updated_dt' | 'uuid'>, psUpdateStream?: string, resolution?: string, status?: string, type?: 'BUGZILLA' | 'JIRA', updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/osidb/api/v1/trackers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (affectsAffectedness !== undefined) {
                localVarQueryParameter['affects__affectedness'] = affectsAffectedness;
            }

            if (affectsCreatedDt !== undefined) {
                localVarQueryParameter['affects__created_dt'] = (affectsCreatedDt as any instanceof Date) ?
                    (affectsCreatedDt as any).toISOString() :
                    affectsCreatedDt;
            }

            if (affectsCreatedDtDate !== undefined) {
                localVarQueryParameter['affects__created_dt__date'] = (affectsCreatedDtDate as any instanceof Date) ?
                    (affectsCreatedDtDate as any).toISOString().substr(0,10) :
                    affectsCreatedDtDate;
            }

            if (affectsCreatedDtDateGte !== undefined) {
                localVarQueryParameter['affects__created_dt__date__gte'] = (affectsCreatedDtDateGte as any instanceof Date) ?
                    (affectsCreatedDtDateGte as any).toISOString().substr(0,10) :
                    affectsCreatedDtDateGte;
            }

            if (affectsCreatedDtDateLte !== undefined) {
                localVarQueryParameter['affects__created_dt__date__lte'] = (affectsCreatedDtDateLte as any instanceof Date) ?
                    (affectsCreatedDtDateLte as any).toISOString().substr(0,10) :
                    affectsCreatedDtDateLte;
            }

            if (affectsCreatedDtGt !== undefined) {
                localVarQueryParameter['affects__created_dt__gt'] = (affectsCreatedDtGt as any instanceof Date) ?
                    (affectsCreatedDtGt as any).toISOString() :
                    affectsCreatedDtGt;
            }

            if (affectsCreatedDtGte !== undefined) {
                localVarQueryParameter['affects__created_dt__gte'] = (affectsCreatedDtGte as any instanceof Date) ?
                    (affectsCreatedDtGte as any).toISOString() :
                    affectsCreatedDtGte;
            }

            if (affectsCreatedDtLt !== undefined) {
                localVarQueryParameter['affects__created_dt__lt'] = (affectsCreatedDtLt as any instanceof Date) ?
                    (affectsCreatedDtLt as any).toISOString() :
                    affectsCreatedDtLt;
            }

            if (affectsCreatedDtLte !== undefined) {
                localVarQueryParameter['affects__created_dt__lte'] = (affectsCreatedDtLte as any instanceof Date) ?
                    (affectsCreatedDtLte as any).toISOString() :
                    affectsCreatedDtLte;
            }

            if (affectsEmbargoed !== undefined) {
                localVarQueryParameter['affects__embargoed'] = affectsEmbargoed;
            }

            if (affectsFlawComponents) {
                localVarQueryParameter['affects__flaw__components'] = affectsFlawComponents.join(COLLECTION_FORMATS.csv);
            }

            if (affectsFlawCreatedDt !== undefined) {
                localVarQueryParameter['affects__flaw__created_dt'] = (affectsFlawCreatedDt as any instanceof Date) ?
                    (affectsFlawCreatedDt as any).toISOString() :
                    affectsFlawCreatedDt;
            }

            if (affectsFlawCreatedDtDate !== undefined) {
                localVarQueryParameter['affects__flaw__created_dt__date'] = (affectsFlawCreatedDtDate as any instanceof Date) ?
                    (affectsFlawCreatedDtDate as any).toISOString().substr(0,10) :
                    affectsFlawCreatedDtDate;
            }

            if (affectsFlawCreatedDtDateGte !== undefined) {
                localVarQueryParameter['affects__flaw__created_dt__date__gte'] = (affectsFlawCreatedDtDateGte as any instanceof Date) ?
                    (affectsFlawCreatedDtDateGte as any).toISOString().substr(0,10) :
                    affectsFlawCreatedDtDateGte;
            }

            if (affectsFlawCreatedDtDateLte !== undefined) {
                localVarQueryParameter['affects__flaw__created_dt__date__lte'] = (affectsFlawCreatedDtDateLte as any instanceof Date) ?
                    (affectsFlawCreatedDtDateLte as any).toISOString().substr(0,10) :
                    affectsFlawCreatedDtDateLte;
            }

            if (affectsFlawCreatedDtGt !== undefined) {
                localVarQueryParameter['affects__flaw__created_dt__gt'] = (affectsFlawCreatedDtGt as any instanceof Date) ?
                    (affectsFlawCreatedDtGt as any).toISOString() :
                    affectsFlawCreatedDtGt;
            }

            if (affectsFlawCreatedDtGte !== undefined) {
                localVarQueryParameter['affects__flaw__created_dt__gte'] = (affectsFlawCreatedDtGte as any instanceof Date) ?
                    (affectsFlawCreatedDtGte as any).toISOString() :
                    affectsFlawCreatedDtGte;
            }

            if (affectsFlawCreatedDtLt !== undefined) {
                localVarQueryParameter['affects__flaw__created_dt__lt'] = (affectsFlawCreatedDtLt as any instanceof Date) ?
                    (affectsFlawCreatedDtLt as any).toISOString() :
                    affectsFlawCreatedDtLt;
            }

            if (affectsFlawCreatedDtLte !== undefined) {
                localVarQueryParameter['affects__flaw__created_dt__lte'] = (affectsFlawCreatedDtLte as any instanceof Date) ?
                    (affectsFlawCreatedDtLte as any).toISOString() :
                    affectsFlawCreatedDtLte;
            }

            if (affectsFlawCveId !== undefined) {
                localVarQueryParameter['affects__flaw__cve_id'] = affectsFlawCveId;
            }

            if (affectsFlawCweId !== undefined) {
                localVarQueryParameter['affects__flaw__cwe_id'] = affectsFlawCweId;
            }

            if (affectsFlawEmbargoed !== undefined) {
                localVarQueryParameter['affects__flaw__embargoed'] = affectsFlawEmbargoed;
            }

            if (affectsFlawImpact !== undefined) {
                localVarQueryParameter['affects__flaw__impact'] = affectsFlawImpact;
            }

            if (affectsFlawReportedDt !== undefined) {
                localVarQueryParameter['affects__flaw__reported_dt'] = (affectsFlawReportedDt as any instanceof Date) ?
                    (affectsFlawReportedDt as any).toISOString() :
                    affectsFlawReportedDt;
            }

            if (affectsFlawReportedDtDate !== undefined) {
                localVarQueryParameter['affects__flaw__reported_dt__date'] = (affectsFlawReportedDtDate as any instanceof Date) ?
                    (affectsFlawReportedDtDate as any).toISOString().substr(0,10) :
                    affectsFlawReportedDtDate;
            }

            if (affectsFlawReportedDtDateGte !== undefined) {
                localVarQueryParameter['affects__flaw__reported_dt__date__gte'] = (affectsFlawReportedDtDateGte as any instanceof Date) ?
                    (affectsFlawReportedDtDateGte as any).toISOString().substr(0,10) :
                    affectsFlawReportedDtDateGte;
            }

            if (affectsFlawReportedDtDateLte !== undefined) {
                localVarQueryParameter['affects__flaw__reported_dt__date__lte'] = (affectsFlawReportedDtDateLte as any instanceof Date) ?
                    (affectsFlawReportedDtDateLte as any).toISOString().substr(0,10) :
                    affectsFlawReportedDtDateLte;
            }

            if (affectsFlawReportedDtGt !== undefined) {
                localVarQueryParameter['affects__flaw__reported_dt__gt'] = (affectsFlawReportedDtGt as any instanceof Date) ?
                    (affectsFlawReportedDtGt as any).toISOString() :
                    affectsFlawReportedDtGt;
            }

            if (affectsFlawReportedDtGte !== undefined) {
                localVarQueryParameter['affects__flaw__reported_dt__gte'] = (affectsFlawReportedDtGte as any instanceof Date) ?
                    (affectsFlawReportedDtGte as any).toISOString() :
                    affectsFlawReportedDtGte;
            }

            if (affectsFlawReportedDtLt !== undefined) {
                localVarQueryParameter['affects__flaw__reported_dt__lt'] = (affectsFlawReportedDtLt as any instanceof Date) ?
                    (affectsFlawReportedDtLt as any).toISOString() :
                    affectsFlawReportedDtLt;
            }

            if (affectsFlawReportedDtLte !== undefined) {
                localVarQueryParameter['affects__flaw__reported_dt__lte'] = (affectsFlawReportedDtLte as any instanceof Date) ?
                    (affectsFlawReportedDtLte as any).toISOString() :
                    affectsFlawReportedDtLte;
            }

            if (affectsFlawSource !== undefined) {
                localVarQueryParameter['affects__flaw__source'] = affectsFlawSource;
            }

            if (affectsFlawUnembargoDt !== undefined) {
                localVarQueryParameter['affects__flaw__unembargo_dt'] = (affectsFlawUnembargoDt as any instanceof Date) ?
                    (affectsFlawUnembargoDt as any).toISOString() :
                    affectsFlawUnembargoDt;
            }

            if (affectsFlawUpdatedDt !== undefined) {
                localVarQueryParameter['affects__flaw__updated_dt'] = (affectsFlawUpdatedDt as any instanceof Date) ?
                    (affectsFlawUpdatedDt as any).toISOString() :
                    affectsFlawUpdatedDt;
            }

            if (affectsFlawUpdatedDtDate !== undefined) {
                localVarQueryParameter['affects__flaw__updated_dt__date'] = (affectsFlawUpdatedDtDate as any instanceof Date) ?
                    (affectsFlawUpdatedDtDate as any).toISOString().substr(0,10) :
                    affectsFlawUpdatedDtDate;
            }

            if (affectsFlawUpdatedDtDateGte !== undefined) {
                localVarQueryParameter['affects__flaw__updated_dt__date__gte'] = (affectsFlawUpdatedDtDateGte as any instanceof Date) ?
                    (affectsFlawUpdatedDtDateGte as any).toISOString().substr(0,10) :
                    affectsFlawUpdatedDtDateGte;
            }

            if (affectsFlawUpdatedDtDateLte !== undefined) {
                localVarQueryParameter['affects__flaw__updated_dt__date__lte'] = (affectsFlawUpdatedDtDateLte as any instanceof Date) ?
                    (affectsFlawUpdatedDtDateLte as any).toISOString().substr(0,10) :
                    affectsFlawUpdatedDtDateLte;
            }

            if (affectsFlawUpdatedDtGt !== undefined) {
                localVarQueryParameter['affects__flaw__updated_dt__gt'] = (affectsFlawUpdatedDtGt as any instanceof Date) ?
                    (affectsFlawUpdatedDtGt as any).toISOString() :
                    affectsFlawUpdatedDtGt;
            }

            if (affectsFlawUpdatedDtGte !== undefined) {
                localVarQueryParameter['affects__flaw__updated_dt__gte'] = (affectsFlawUpdatedDtGte as any instanceof Date) ?
                    (affectsFlawUpdatedDtGte as any).toISOString() :
                    affectsFlawUpdatedDtGte;
            }

            if (affectsFlawUpdatedDtLt !== undefined) {
                localVarQueryParameter['affects__flaw__updated_dt__lt'] = (affectsFlawUpdatedDtLt as any instanceof Date) ?
                    (affectsFlawUpdatedDtLt as any).toISOString() :
                    affectsFlawUpdatedDtLt;
            }

            if (affectsFlawUpdatedDtLte !== undefined) {
                localVarQueryParameter['affects__flaw__updated_dt__lte'] = (affectsFlawUpdatedDtLte as any instanceof Date) ?
                    (affectsFlawUpdatedDtLte as any).toISOString() :
                    affectsFlawUpdatedDtLte;
            }

            if (affectsFlawUuid !== undefined) {
                localVarQueryParameter['affects__flaw__uuid'] = affectsFlawUuid;
            }

            if (affectsImpact !== undefined) {
                localVarQueryParameter['affects__impact'] = affectsImpact;
            }

            if (affectsPsComponent !== undefined) {
                localVarQueryParameter['affects__ps_component'] = affectsPsComponent;
            }

            if (affectsPsModule !== undefined) {
                localVarQueryParameter['affects__ps_module'] = affectsPsModule;
            }

            if (affectsResolution !== undefined) {
                localVarQueryParameter['affects__resolution'] = affectsResolution;
            }

            if (affectsUpdatedDt !== undefined) {
                localVarQueryParameter['affects__updated_dt'] = (affectsUpdatedDt as any instanceof Date) ?
                    (affectsUpdatedDt as any).toISOString() :
                    affectsUpdatedDt;
            }

            if (affectsUpdatedDtDate !== undefined) {
                localVarQueryParameter['affects__updated_dt__date'] = (affectsUpdatedDtDate as any instanceof Date) ?
                    (affectsUpdatedDtDate as any).toISOString().substr(0,10) :
                    affectsUpdatedDtDate;
            }

            if (affectsUpdatedDtDateGte !== undefined) {
                localVarQueryParameter['affects__updated_dt__date__gte'] = (affectsUpdatedDtDateGte as any instanceof Date) ?
                    (affectsUpdatedDtDateGte as any).toISOString().substr(0,10) :
                    affectsUpdatedDtDateGte;
            }

            if (affectsUpdatedDtDateLte !== undefined) {
                localVarQueryParameter['affects__updated_dt__date__lte'] = (affectsUpdatedDtDateLte as any instanceof Date) ?
                    (affectsUpdatedDtDateLte as any).toISOString().substr(0,10) :
                    affectsUpdatedDtDateLte;
            }

            if (affectsUpdatedDtGt !== undefined) {
                localVarQueryParameter['affects__updated_dt__gt'] = (affectsUpdatedDtGt as any instanceof Date) ?
                    (affectsUpdatedDtGt as any).toISOString() :
                    affectsUpdatedDtGt;
            }

            if (affectsUpdatedDtGte !== undefined) {
                localVarQueryParameter['affects__updated_dt__gte'] = (affectsUpdatedDtGte as any instanceof Date) ?
                    (affectsUpdatedDtGte as any).toISOString() :
                    affectsUpdatedDtGte;
            }

            if (affectsUpdatedDtLt !== undefined) {
                localVarQueryParameter['affects__updated_dt__lt'] = (affectsUpdatedDtLt as any instanceof Date) ?
                    (affectsUpdatedDtLt as any).toISOString() :
                    affectsUpdatedDtLt;
            }

            if (affectsUpdatedDtLte !== undefined) {
                localVarQueryParameter['affects__updated_dt__lte'] = (affectsUpdatedDtLte as any instanceof Date) ?
                    (affectsUpdatedDtLte as any).toISOString() :
                    affectsUpdatedDtLte;
            }

            if (affectsUuid !== undefined) {
                localVarQueryParameter['affects__uuid'] = affectsUuid;
            }

            if (createdDt !== undefined) {
                localVarQueryParameter['created_dt'] = (createdDt as any instanceof Date) ?
                    (createdDt as any).toISOString() :
                    createdDt;
            }

            if (createdDtDate !== undefined) {
                localVarQueryParameter['created_dt__date'] = (createdDtDate as any instanceof Date) ?
                    (createdDtDate as any).toISOString().substr(0,10) :
                    createdDtDate;
            }

            if (createdDtDateGte !== undefined) {
                localVarQueryParameter['created_dt__date__gte'] = (createdDtDateGte as any instanceof Date) ?
                    (createdDtDateGte as any).toISOString().substr(0,10) :
                    createdDtDateGte;
            }

            if (createdDtDateLte !== undefined) {
                localVarQueryParameter['created_dt__date__lte'] = (createdDtDateLte as any instanceof Date) ?
                    (createdDtDateLte as any).toISOString().substr(0,10) :
                    createdDtDateLte;
            }

            if (createdDtGt !== undefined) {
                localVarQueryParameter['created_dt__gt'] = (createdDtGt as any instanceof Date) ?
                    (createdDtGt as any).toISOString() :
                    createdDtGt;
            }

            if (createdDtGte !== undefined) {
                localVarQueryParameter['created_dt__gte'] = (createdDtGte as any instanceof Date) ?
                    (createdDtGte as any).toISOString() :
                    createdDtGte;
            }

            if (createdDtLt !== undefined) {
                localVarQueryParameter['created_dt__lt'] = (createdDtLt as any instanceof Date) ?
                    (createdDtLt as any).toISOString() :
                    createdDtLt;
            }

            if (createdDtLte !== undefined) {
                localVarQueryParameter['created_dt__lte'] = (createdDtLte as any instanceof Date) ?
                    (createdDtLte as any).toISOString() :
                    createdDtLte;
            }

            if (embargoed !== undefined) {
                localVarQueryParameter['embargoed'] = embargoed;
            }

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (externalSystemId !== undefined) {
                localVarQueryParameter['external_system_id'] = externalSystemId;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }

            if (includeMetaAttr) {
                localVarQueryParameter['include_meta_attr'] = includeMetaAttr;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (order) {
                localVarQueryParameter['order'] = order.join(COLLECTION_FORMATS.csv);
            }

            if (psUpdateStream !== undefined) {
                localVarQueryParameter['ps_update_stream'] = psUpdateStream;
            }

            if (resolution !== undefined) {
                localVarQueryParameter['resolution'] = resolution;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (updatedDt !== undefined) {
                localVarQueryParameter['updated_dt'] = (updatedDt as any instanceof Date) ?
                    (updatedDt as any).toISOString() :
                    updatedDt;
            }

            if (updatedDtDate !== undefined) {
                localVarQueryParameter['updated_dt__date'] = (updatedDtDate as any instanceof Date) ?
                    (updatedDtDate as any).toISOString().substr(0,10) :
                    updatedDtDate;
            }

            if (updatedDtDateGte !== undefined) {
                localVarQueryParameter['updated_dt__date__gte'] = (updatedDtDateGte as any instanceof Date) ?
                    (updatedDtDateGte as any).toISOString().substr(0,10) :
                    updatedDtDateGte;
            }

            if (updatedDtDateLte !== undefined) {
                localVarQueryParameter['updated_dt__date__lte'] = (updatedDtDateLte as any instanceof Date) ?
                    (updatedDtDateLte as any).toISOString().substr(0,10) :
                    updatedDtDateLte;
            }

            if (updatedDtGt !== undefined) {
                localVarQueryParameter['updated_dt__gt'] = (updatedDtGt as any instanceof Date) ?
                    (updatedDtGt as any).toISOString() :
                    updatedDtGt;
            }

            if (updatedDtGte !== undefined) {
                localVarQueryParameter['updated_dt__gte'] = (updatedDtGte as any instanceof Date) ?
                    (updatedDtGte as any).toISOString() :
                    updatedDtGte;
            }

            if (updatedDtLt !== undefined) {
                localVarQueryParameter['updated_dt__lt'] = (updatedDtLt as any instanceof Date) ?
                    (updatedDtLt as any).toISOString() :
                    updatedDtLt;
            }

            if (updatedDtLte !== undefined) {
                localVarQueryParameter['updated_dt__lte'] = (updatedDtLte as any instanceof Date) ?
                    (updatedDtLte as any).toISOString() :
                    updatedDtLte;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid A UUID string identifying this Tracker.
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1TrackersRetrieve: async (uuid: string, excludeFields?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('osidbApiV1TrackersRetrieve', 'uuid', uuid)
            const localVarPath = `/osidb/api/v1/trackers/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (excludeFields) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }

            if (includeFields) {
                localVarQueryParameter['include_fields'] = includeFields;
            }

            if (includeMetaAttr) {
                localVarQueryParameter['include_meta_attr'] = includeMetaAttr;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {string} uuid A UUID string identifying this Tracker.
         * @param {Tracker} tracker 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1TrackersUpdate: async (bugzillaApiKey: string, jiraApiKey: string, uuid: string, tracker: Tracker, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bugzillaApiKey' is not null or undefined
            assertParamExists('osidbApiV1TrackersUpdate', 'bugzillaApiKey', bugzillaApiKey)
            // verify required parameter 'jiraApiKey' is not null or undefined
            assertParamExists('osidbApiV1TrackersUpdate', 'jiraApiKey', jiraApiKey)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('osidbApiV1TrackersUpdate', 'uuid', uuid)
            // verify required parameter 'tracker' is not null or undefined
            assertParamExists('osidbApiV1TrackersUpdate', 'tracker', tracker)
            const localVarPath = `/osidb/api/v1/trackers/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (bugzillaApiKey != null) {
                localVarHeaderParameter['Bugzilla-Api-Key'] = String(bugzillaApiKey);
            }

            if (jiraApiKey != null) {
                localVarHeaderParameter['Jira-Api-Key'] = String(jiraApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tracker, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * unauthenticated view providing healthcheck on osidb service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbHealthyRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/osidb/healthy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View that provides information about the currently logged-in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbWhoamiRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/osidb/whoami`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OsidbApi - functional programming interface
 * @export
 */
export const OsidbApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OsidbApiAxiosParamCreator(configuration)
    return {
        /**
         * Bulk create endpoint. Expects a list of dict Affect objects.
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {Array<AffectPost>} affectPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1AffectsBulkCreate(bugzillaApiKey: string, affectPost: Array<AffectPost>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1AffectsBulkUpdate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1AffectsBulkCreate(bugzillaApiKey, affectPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Bulk delete endpoint. Expects a list of Affect uuids.
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1AffectsBulkDestroy(bugzillaApiKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200ResponseAllOf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1AffectsBulkDestroy(bugzillaApiKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Bulk update endpoint. Expects a list of dict Affect objects.
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {Array<AffectBulkPut>} affectBulkPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1AffectsBulkUpdate(bugzillaApiKey: string, jiraApiKey: string, affectBulkPut: Array<AffectBulkPut>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1AffectsBulkUpdate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1AffectsBulkUpdate(bugzillaApiKey, jiraApiKey, affectBulkPut, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {AffectPost} affectPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1AffectsCreate(bugzillaApiKey: string, jiraApiKey: string, affectPost: AffectPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1AffectsCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1AffectsCreate(bugzillaApiKey, jiraApiKey, affectPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} affectId 
         * @param {AffectCVSSPost} affectCVSSPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1AffectsCvssScoresCreate(bugzillaApiKey: string, affectId: string, affectCVSSPost: AffectCVSSPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1AffectsCvssScoresCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1AffectsCvssScoresCreate(bugzillaApiKey, affectId, affectCVSSPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Destroy the instance and proxy the delete to Bugzilla.
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} affectId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1AffectsCvssScoresDestroy(bugzillaApiKey: string, affectId: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200ResponseAllOf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1AffectsCvssScoresDestroy(bugzillaApiKey, affectId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} affectId 
         * @param {string} [comment] 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {string} [cvssVersion] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {'NIST' | 'OSV' | 'RH'} [issuer] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {number} [score] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {string} [vector] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1AffectsCvssScoresList(affectId: string, comment?: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, cvssVersion?: string, excludeFields?: Array<string>, includeFields?: Array<string>, issuer?: 'NIST' | 'OSV' | 'RH', limit?: number, offset?: number, score?: number, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, vector?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1AffectsCvssScoresList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1AffectsCvssScoresList(affectId, comment, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, cvssVersion, excludeFields, includeFields, issuer, limit, offset, score, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, vector, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} affectId 
         * @param {string} id 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1AffectsCvssScoresRetrieve(affectId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1AffectsCvssScoresCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1AffectsCvssScoresRetrieve(affectId, id, excludeFields, includeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} affectId 
         * @param {string} id 
         * @param {AffectCVSSPut} affectCVSSPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1AffectsCvssScoresUpdate(bugzillaApiKey: string, affectId: string, id: string, affectCVSSPut: AffectCVSSPut, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1AffectsCvssScoresCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1AffectsCvssScoresUpdate(bugzillaApiKey, affectId, id, affectCVSSPut, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Destroy the instance and proxy the delete to Bugzilla
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} uuid A UUID string identifying this Affect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1AffectsDestroy(bugzillaApiKey: string, uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200ResponseAllOf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1AffectsDestroy(bugzillaApiKey, uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {'' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED'} [affectedness] 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {string} [cvssScoresComment] 
         * @param {string} [cvssScoresCreatedDt] 
         * @param {string} [cvssScoresCreatedDtDate] 
         * @param {string} [cvssScoresCreatedDtDateGte] 
         * @param {string} [cvssScoresCreatedDtDateLte] 
         * @param {string} [cvssScoresCreatedDtGt] 
         * @param {string} [cvssScoresCreatedDtGte] 
         * @param {string} [cvssScoresCreatedDtLt] 
         * @param {string} [cvssScoresCreatedDtLte] 
         * @param {string} [cvssScoresCvssVersion] 
         * @param {'NIST' | 'OSV' | 'RH'} [cvssScoresIssuer] 
         * @param {number} [cvssScoresScore] 
         * @param {string} [cvssScoresUpdatedDt] 
         * @param {string} [cvssScoresUpdatedDtDate] 
         * @param {string} [cvssScoresUpdatedDtDateGte] 
         * @param {string} [cvssScoresUpdatedDtDateLte] 
         * @param {string} [cvssScoresUpdatedDtGt] 
         * @param {string} [cvssScoresUpdatedDtGte] 
         * @param {string} [cvssScoresUpdatedDtLt] 
         * @param {string} [cvssScoresUpdatedDtLte] 
         * @param {string} [cvssScoresUuid] 
         * @param {string} [cvssScoresVector] 
         * @param {boolean} [embargoed] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [flawComponents] Multiple values may be separated by commas.
         * @param {string} [flawCreatedDt] 
         * @param {string} [flawCreatedDtDate] 
         * @param {string} [flawCreatedDtDateGte] 
         * @param {string} [flawCreatedDtDateLte] 
         * @param {string} [flawCreatedDtGt] 
         * @param {string} [flawCreatedDtGte] 
         * @param {string} [flawCreatedDtLt] 
         * @param {string} [flawCreatedDtLte] 
         * @param {string} [flawCveId] 
         * @param {string} [flawCweId] 
         * @param {boolean} [flawEmbargoed] 
         * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [flawImpact] 
         * @param {string} [flawReportedDt] 
         * @param {string} [flawReportedDtDate] 
         * @param {string} [flawReportedDtDateGte] 
         * @param {string} [flawReportedDtDateLte] 
         * @param {string} [flawReportedDtGt] 
         * @param {string} [flawReportedDtGte] 
         * @param {string} [flawReportedDtLt] 
         * @param {string} [flawReportedDtLte] 
         * @param {'' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'NVD' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'OSV' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF'} [flawSource] 
         * @param {string} [flawUnembargoDt] 
         * @param {string} [flawUpdatedDt] 
         * @param {string} [flawUpdatedDtDate] 
         * @param {string} [flawUpdatedDtDateGte] 
         * @param {string} [flawUpdatedDtDateLte] 
         * @param {string} [flawUpdatedDtGt] 
         * @param {string} [flawUpdatedDtGte] 
         * @param {string} [flawUpdatedDtLt] 
         * @param {string} [flawUpdatedDtLte] 
         * @param {string} [flawUuid] 
         * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [impact] 
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {Array<'-affectedness' | '-created_dt' | '-cvss_scores__comment' | '-cvss_scores__created_dt' | '-cvss_scores__cvss_version' | '-cvss_scores__issuer' | '-cvss_scores__score' | '-cvss_scores__updated_dt' | '-cvss_scores__uuid' | '-cvss_scores__vector' | '-embargoed' | '-flaw__components' | '-flaw__created_dt' | '-flaw__cve_id' | '-flaw__cwe_id' | '-flaw__embargoed' | '-flaw__impact' | '-flaw__reported_dt' | '-flaw__source' | '-flaw__unembargo_dt' | '-flaw__updated_dt' | '-flaw__uuid' | '-impact' | '-ps_component' | '-ps_module' | '-resolution' | '-trackers__created_dt' | '-trackers__embargoed' | '-trackers__external_system_id' | '-trackers__ps_update_stream' | '-trackers__resolution' | '-trackers__status' | '-trackers__type' | '-trackers__updated_dt' | '-trackers__uuid' | '-updated_dt' | '-uuid' | 'affectedness' | 'created_dt' | 'cvss_scores__comment' | 'cvss_scores__created_dt' | 'cvss_scores__cvss_version' | 'cvss_scores__issuer' | 'cvss_scores__score' | 'cvss_scores__updated_dt' | 'cvss_scores__uuid' | 'cvss_scores__vector' | 'embargoed' | 'flaw__components' | 'flaw__created_dt' | 'flaw__cve_id' | 'flaw__cwe_id' | 'flaw__embargoed' | 'flaw__impact' | 'flaw__reported_dt' | 'flaw__source' | 'flaw__unembargo_dt' | 'flaw__updated_dt' | 'flaw__uuid' | 'impact' | 'ps_component' | 'ps_module' | 'resolution' | 'trackers__created_dt' | 'trackers__embargoed' | 'trackers__external_system_id' | 'trackers__ps_update_stream' | 'trackers__resolution' | 'trackers__status' | 'trackers__type' | 'trackers__updated_dt' | 'trackers__uuid' | 'updated_dt' | 'uuid'>} [order] Ordering
         * @param {string} [psComponent] 
         * @param {string} [psModule] 
         * @param {'' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT'} [resolution] 
         * @param {string} [trackersCreatedDt] 
         * @param {string} [trackersCreatedDtDate] 
         * @param {string} [trackersCreatedDtDateGte] 
         * @param {string} [trackersCreatedDtDateLte] 
         * @param {string} [trackersCreatedDtGt] 
         * @param {string} [trackersCreatedDtGte] 
         * @param {string} [trackersCreatedDtLt] 
         * @param {string} [trackersCreatedDtLte] 
         * @param {boolean} [trackersEmbargoed] 
         * @param {string} [trackersExternalSystemId] 
         * @param {string} [trackersPsUpdateStream] 
         * @param {string} [trackersResolution] 
         * @param {string} [trackersStatus] 
         * @param {'BUGZILLA' | 'JIRA'} [trackersType] 
         * @param {string} [trackersUpdatedDt] 
         * @param {string} [trackersUpdatedDtDate] 
         * @param {string} [trackersUpdatedDtDateGte] 
         * @param {string} [trackersUpdatedDtDateLte] 
         * @param {string} [trackersUpdatedDtGt] 
         * @param {string} [trackersUpdatedDtGte] 
         * @param {string} [trackersUpdatedDtLt] 
         * @param {string} [trackersUpdatedDtLte] 
         * @param {string} [trackersUuid] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1AffectsList(affectedness?: '' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED', createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, cvssScoresComment?: string, cvssScoresCreatedDt?: string, cvssScoresCreatedDtDate?: string, cvssScoresCreatedDtDateGte?: string, cvssScoresCreatedDtDateLte?: string, cvssScoresCreatedDtGt?: string, cvssScoresCreatedDtGte?: string, cvssScoresCreatedDtLt?: string, cvssScoresCreatedDtLte?: string, cvssScoresCvssVersion?: string, cvssScoresIssuer?: 'NIST' | 'OSV' | 'RH', cvssScoresScore?: number, cvssScoresUpdatedDt?: string, cvssScoresUpdatedDtDate?: string, cvssScoresUpdatedDtDateGte?: string, cvssScoresUpdatedDtDateLte?: string, cvssScoresUpdatedDtGt?: string, cvssScoresUpdatedDtGte?: string, cvssScoresUpdatedDtLt?: string, cvssScoresUpdatedDtLte?: string, cvssScoresUuid?: string, cvssScoresVector?: string, embargoed?: boolean, excludeFields?: Array<string>, flawComponents?: Array<string>, flawCreatedDt?: string, flawCreatedDtDate?: string, flawCreatedDtDateGte?: string, flawCreatedDtDateLte?: string, flawCreatedDtGt?: string, flawCreatedDtGte?: string, flawCreatedDtLt?: string, flawCreatedDtLte?: string, flawCveId?: string, flawCweId?: string, flawEmbargoed?: boolean, flawImpact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', flawReportedDt?: string, flawReportedDtDate?: string, flawReportedDtDateGte?: string, flawReportedDtDateLte?: string, flawReportedDtGt?: string, flawReportedDtGte?: string, flawReportedDtLt?: string, flawReportedDtLte?: string, flawSource?: '' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'NVD' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'OSV' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF', flawUnembargoDt?: string, flawUpdatedDt?: string, flawUpdatedDtDate?: string, flawUpdatedDtDateGte?: string, flawUpdatedDtDateLte?: string, flawUpdatedDtGt?: string, flawUpdatedDtGte?: string, flawUpdatedDtLt?: string, flawUpdatedDtLte?: string, flawUuid?: string, impact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', includeFields?: Array<string>, includeMetaAttr?: Array<string>, limit?: number, offset?: number, order?: Array<'-affectedness' | '-created_dt' | '-cvss_scores__comment' | '-cvss_scores__created_dt' | '-cvss_scores__cvss_version' | '-cvss_scores__issuer' | '-cvss_scores__score' | '-cvss_scores__updated_dt' | '-cvss_scores__uuid' | '-cvss_scores__vector' | '-embargoed' | '-flaw__components' | '-flaw__created_dt' | '-flaw__cve_id' | '-flaw__cwe_id' | '-flaw__embargoed' | '-flaw__impact' | '-flaw__reported_dt' | '-flaw__source' | '-flaw__unembargo_dt' | '-flaw__updated_dt' | '-flaw__uuid' | '-impact' | '-ps_component' | '-ps_module' | '-resolution' | '-trackers__created_dt' | '-trackers__embargoed' | '-trackers__external_system_id' | '-trackers__ps_update_stream' | '-trackers__resolution' | '-trackers__status' | '-trackers__type' | '-trackers__updated_dt' | '-trackers__uuid' | '-updated_dt' | '-uuid' | 'affectedness' | 'created_dt' | 'cvss_scores__comment' | 'cvss_scores__created_dt' | 'cvss_scores__cvss_version' | 'cvss_scores__issuer' | 'cvss_scores__score' | 'cvss_scores__updated_dt' | 'cvss_scores__uuid' | 'cvss_scores__vector' | 'embargoed' | 'flaw__components' | 'flaw__created_dt' | 'flaw__cve_id' | 'flaw__cwe_id' | 'flaw__embargoed' | 'flaw__impact' | 'flaw__reported_dt' | 'flaw__source' | 'flaw__unembargo_dt' | 'flaw__updated_dt' | 'flaw__uuid' | 'impact' | 'ps_component' | 'ps_module' | 'resolution' | 'trackers__created_dt' | 'trackers__embargoed' | 'trackers__external_system_id' | 'trackers__ps_update_stream' | 'trackers__resolution' | 'trackers__status' | 'trackers__type' | 'trackers__updated_dt' | 'trackers__uuid' | 'updated_dt' | 'uuid'>, psComponent?: string, psModule?: string, resolution?: '' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT', trackersCreatedDt?: string, trackersCreatedDtDate?: string, trackersCreatedDtDateGte?: string, trackersCreatedDtDateLte?: string, trackersCreatedDtGt?: string, trackersCreatedDtGte?: string, trackersCreatedDtLt?: string, trackersCreatedDtLte?: string, trackersEmbargoed?: boolean, trackersExternalSystemId?: string, trackersPsUpdateStream?: string, trackersResolution?: string, trackersStatus?: string, trackersType?: 'BUGZILLA' | 'JIRA', trackersUpdatedDt?: string, trackersUpdatedDtDate?: string, trackersUpdatedDtDateGte?: string, trackersUpdatedDtDateLte?: string, trackersUpdatedDtGt?: string, trackersUpdatedDtGte?: string, trackersUpdatedDtLt?: string, trackersUpdatedDtLte?: string, trackersUuid?: string, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1AffectsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1AffectsList(affectedness, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, cvssScoresComment, cvssScoresCreatedDt, cvssScoresCreatedDtDate, cvssScoresCreatedDtDateGte, cvssScoresCreatedDtDateLte, cvssScoresCreatedDtGt, cvssScoresCreatedDtGte, cvssScoresCreatedDtLt, cvssScoresCreatedDtLte, cvssScoresCvssVersion, cvssScoresIssuer, cvssScoresScore, cvssScoresUpdatedDt, cvssScoresUpdatedDtDate, cvssScoresUpdatedDtDateGte, cvssScoresUpdatedDtDateLte, cvssScoresUpdatedDtGt, cvssScoresUpdatedDtGte, cvssScoresUpdatedDtLt, cvssScoresUpdatedDtLte, cvssScoresUuid, cvssScoresVector, embargoed, excludeFields, flawComponents, flawCreatedDt, flawCreatedDtDate, flawCreatedDtDateGte, flawCreatedDtDateLte, flawCreatedDtGt, flawCreatedDtGte, flawCreatedDtLt, flawCreatedDtLte, flawCveId, flawCweId, flawEmbargoed, flawImpact, flawReportedDt, flawReportedDtDate, flawReportedDtDateGte, flawReportedDtDateLte, flawReportedDtGt, flawReportedDtGte, flawReportedDtLt, flawReportedDtLte, flawSource, flawUnembargoDt, flawUpdatedDt, flawUpdatedDtDate, flawUpdatedDtDateGte, flawUpdatedDtDateLte, flawUpdatedDtGt, flawUpdatedDtGte, flawUpdatedDtLt, flawUpdatedDtLte, flawUuid, impact, includeFields, includeMetaAttr, limit, offset, order, psComponent, psModule, resolution, trackersCreatedDt, trackersCreatedDtDate, trackersCreatedDtDateGte, trackersCreatedDtDateLte, trackersCreatedDtGt, trackersCreatedDtGte, trackersCreatedDtLt, trackersCreatedDtLte, trackersEmbargoed, trackersExternalSystemId, trackersPsUpdateStream, trackersResolution, trackersStatus, trackersType, trackersUpdatedDt, trackersUpdatedDtDate, trackersUpdatedDtDateGte, trackersUpdatedDtDateLte, trackersUpdatedDtGt, trackersUpdatedDtGte, trackersUpdatedDtLt, trackersUpdatedDtLte, trackersUuid, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid A UUID string identifying this Affect.
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1AffectsRetrieve(uuid: string, excludeFields?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1AffectsCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1AffectsRetrieve(uuid, excludeFields, includeFields, includeMetaAttr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {string} uuid A UUID string identifying this Affect.
         * @param {Affect} affect 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1AffectsUpdate(bugzillaApiKey: string, jiraApiKey: string, uuid: string, affect: Affect, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1AffectsCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1AffectsUpdate(bugzillaApiKey, jiraApiKey, uuid, affect, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List existing alerts for all models.
         * @param {'ERROR' | 'WARNING'} [alertType] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] Retrieve only Alerts with the specified name, which is given by the model\&#39;s validation process.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {'affect' | 'affectcvss' | 'flaw' | 'flawacknowledgment' | 'flawcomment' | 'flawcvss' | 'flawreference' | 'package' | 'snippet' | 'tracker'} [parentModel] Retrieve only Alerts related to the specified model, e.g. flaw or affect.
         * @param {string} [parentUuid] Retrieve only Alerts related to a model with the given UUID.
         * @param {string} [uuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1AlertsList(alertType?: 'ERROR' | 'WARNING', excludeFields?: Array<string>, includeFields?: Array<string>, limit?: number, name?: string, offset?: number, parentModel?: 'affect' | 'affectcvss' | 'flaw' | 'flawacknowledgment' | 'flawcomment' | 'flawcvss' | 'flawreference' | 'package' | 'snippet' | 'tracker', parentUuid?: string, uuid?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1AlertsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1AlertsList(alertType, excludeFields, includeFields, limit, name, offset, parentModel, parentUuid, uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid A UUID string identifying this alert.
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1AlertsRetrieve(uuid: string, excludeFields?: Array<string>, includeFields?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1AlertsRetrieve200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1AlertsRetrieve(uuid, excludeFields, includeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * basic view of audit history events
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [pghCreatedAt] 
         * @param {string} [pghLabel] 
         * @param {string} [pghObjModel] 
         * @param {string} [pghSlug] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1AuditList(limit?: number, offset?: number, pghCreatedAt?: string, pghLabel?: string, pghObjModel?: string, pghSlug?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1AuditList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1AuditList(limit, offset, pghCreatedAt, pghLabel, pghObjModel, pghSlug, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * basic view of audit history events
         * @param {string} pghSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1AuditRetrieve(pghSlug: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1AuditRetrieve200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1AuditRetrieve(pghSlug, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * basic view of audit history events
         * @param {string} pghSlug 
         * @param {Audit} audit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1AuditUpdate(pghSlug: string, audit: Audit, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1AuditRetrieve200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1AuditUpdate(pghSlug, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId 
         * @param {FlawAcknowledgmentPost} flawAcknowledgmentPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsAcknowledgmentsCreate(bugzillaApiKey: string, flawId: string, flawAcknowledgmentPost: FlawAcknowledgmentPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsAcknowledgmentsCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsAcknowledgmentsCreate(bugzillaApiKey, flawId, flawAcknowledgmentPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Destroy the instance and proxy the delete to Bugzilla
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsAcknowledgmentsDestroy(bugzillaApiKey: string, flawId: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200ResponseAllOf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsAcknowledgmentsDestroy(bugzillaApiKey, flawId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} [affiliation] 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {boolean} [fromUpstream] 
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsAcknowledgmentsList(flawId: string, affiliation?: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, excludeFields?: Array<string>, fromUpstream?: boolean, includeFields?: Array<string>, limit?: number, name?: string, offset?: number, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsAcknowledgmentsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsAcknowledgmentsList(flawId, affiliation, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, excludeFields, fromUpstream, includeFields, limit, name, offset, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} id 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsAcknowledgmentsRetrieve(flawId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsAcknowledgmentsCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsAcknowledgmentsRetrieve(flawId, id, excludeFields, includeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId 
         * @param {string} id 
         * @param {FlawAcknowledgmentPut} flawAcknowledgmentPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsAcknowledgmentsUpdate(bugzillaApiKey: string, flawId: string, id: string, flawAcknowledgmentPut: FlawAcknowledgmentPut, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsAcknowledgmentsCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsAcknowledgmentsUpdate(bugzillaApiKey, flawId, id, flawAcknowledgmentPut, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new comment for a given flaw. Beware that freshly created comments are not guaranteed to keep their original UUIDs, especially if multiple comments are created simultaneously.
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
         * @param {FlawCommentPost} flawCommentPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsCommentsCreate(bugzillaApiKey: string, flawId: string, flawCommentPost: FlawCommentPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsCommentsCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsCommentsCreate(bugzillaApiKey, flawId, flawCommentPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List existing comments for a given flaw. Beware that freshly created comments are not guaranteed to keep their original UUIDs, especially if multiple comments are created simultaneously.
         * @param {string} flawId A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
         * @param {string} [creator] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {string} [externalSystemId] 
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {number} [order] Retrieve only FlawComment resource with the specified order number. Regular flaw comments are numbered from 1 up.
         * @param {string} [uuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsCommentsList(flawId: string, creator?: string, excludeFields?: Array<string>, externalSystemId?: string, includeFields?: Array<string>, limit?: number, offset?: number, order?: number, uuid?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsCommentsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsCommentsList(flawId, creator, excludeFields, externalSystemId, includeFields, limit, offset, order, uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single existing comments for a given flaw. Beware that freshly created comments are not guaranteed to keep their original UUIDs, especially if multiple comments are created simultaneously.
         * @param {string} commentId A string representing the internal OSIDB UUID of the FlawComment resource.
         * @param {string} flawId A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsCommentsRetrieve(commentId: string, flawId: string, excludeFields?: Array<string>, includeFields?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsCommentsCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsCommentsRetrieve(commentId, flawId, excludeFields, includeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {FlawPost} flawPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsCreate(bugzillaApiKey: string, jiraApiKey: string, flawPost: FlawPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsCreate(bugzillaApiKey, jiraApiKey, flawPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId 
         * @param {FlawCVSSPost} flawCVSSPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsCvssScoresCreate(bugzillaApiKey: string, flawId: string, flawCVSSPost: FlawCVSSPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsCvssScoresCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsCvssScoresCreate(bugzillaApiKey, flawId, flawCVSSPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Destroy the instance and proxy the delete to Bugzilla
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsCvssScoresDestroy(bugzillaApiKey: string, flawId: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200ResponseAllOf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsCvssScoresDestroy(bugzillaApiKey, flawId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} [comment] 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {string} [cvssVersion] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {'NIST' | 'OSV' | 'RH'} [issuer] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {number} [score] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {string} [vector] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsCvssScoresList(flawId: string, comment?: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, cvssVersion?: string, excludeFields?: Array<string>, includeFields?: Array<string>, issuer?: 'NIST' | 'OSV' | 'RH', limit?: number, offset?: number, score?: number, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, vector?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsCvssScoresList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsCvssScoresList(flawId, comment, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, cvssVersion, excludeFields, includeFields, issuer, limit, offset, score, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, vector, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} id 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsCvssScoresRetrieve(flawId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsCvssScoresCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsCvssScoresRetrieve(flawId, id, excludeFields, includeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId 
         * @param {string} id 
         * @param {FlawCVSSPut} flawCVSSPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsCvssScoresUpdate(bugzillaApiKey: string, flawId: string, id: string, flawCVSSPut: FlawCVSSPut, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsCvssScoresCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsCvssScoresUpdate(bugzillaApiKey, flawId, id, flawCVSSPut, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [acknowledgmentsAffiliation] 
         * @param {string} [acknowledgmentsCreatedDt] 
         * @param {string} [acknowledgmentsCreatedDtDate] 
         * @param {string} [acknowledgmentsCreatedDtDateGte] 
         * @param {string} [acknowledgmentsCreatedDtDateLte] 
         * @param {string} [acknowledgmentsCreatedDtGt] 
         * @param {string} [acknowledgmentsCreatedDtGte] 
         * @param {string} [acknowledgmentsCreatedDtLt] 
         * @param {string} [acknowledgmentsCreatedDtLte] 
         * @param {boolean} [acknowledgmentsFromUpstream] 
         * @param {string} [acknowledgmentsName] 
         * @param {string} [acknowledgmentsUpdatedDt] 
         * @param {string} [acknowledgmentsUpdatedDtDate] 
         * @param {string} [acknowledgmentsUpdatedDtDateGte] 
         * @param {string} [acknowledgmentsUpdatedDtDateLte] 
         * @param {string} [acknowledgmentsUpdatedDtGt] 
         * @param {string} [acknowledgmentsUpdatedDtGte] 
         * @param {string} [acknowledgmentsUpdatedDtLt] 
         * @param {string} [acknowledgmentsUpdatedDtLte] 
         * @param {string} [acknowledgmentsUuid] 
         * @param {'' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED'} [affectsAffectedness] 
         * @param {string} [affectsCreatedDt] 
         * @param {string} [affectsCreatedDtDate] 
         * @param {string} [affectsCreatedDtDateGte] 
         * @param {string} [affectsCreatedDtDateLte] 
         * @param {string} [affectsCreatedDtGt] 
         * @param {string} [affectsCreatedDtGte] 
         * @param {string} [affectsCreatedDtLt] 
         * @param {string} [affectsCreatedDtLte] 
         * @param {boolean} [affectsEmbargoed] 
         * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [affectsImpact] 
         * @param {string} [affectsPsComponent] 
         * @param {string} [affectsPsModule] 
         * @param {'' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT'} [affectsResolution] 
         * @param {string} [affectsTrackersCreatedDt] 
         * @param {string} [affectsTrackersCreatedDtDate] 
         * @param {string} [affectsTrackersCreatedDtDateGte] 
         * @param {string} [affectsTrackersCreatedDtDateLte] 
         * @param {string} [affectsTrackersCreatedDtGt] 
         * @param {string} [affectsTrackersCreatedDtGte] 
         * @param {string} [affectsTrackersCreatedDtLt] 
         * @param {string} [affectsTrackersCreatedDtLte] 
         * @param {boolean} [affectsTrackersEmbargoed] 
         * @param {string} [affectsTrackersErrataAdvisoryName] 
         * @param {number} [affectsTrackersErrataEtId] 
         * @param {string} [affectsTrackersErrataShippedDt] 
         * @param {string} [affectsTrackersErrataShippedDtDate] 
         * @param {string} [affectsTrackersErrataShippedDtDateGte] 
         * @param {string} [affectsTrackersErrataShippedDtDateLte] 
         * @param {string} [affectsTrackersErrataShippedDtGt] 
         * @param {string} [affectsTrackersErrataShippedDtGte] 
         * @param {string} [affectsTrackersErrataShippedDtLt] 
         * @param {string} [affectsTrackersErrataShippedDtLte] 
         * @param {string} [affectsTrackersExternalSystemId] 
         * @param {string} [affectsTrackersPsUpdateStream] 
         * @param {string} [affectsTrackersResolution] 
         * @param {string} [affectsTrackersStatus] 
         * @param {'BUGZILLA' | 'JIRA'} [affectsTrackersType] 
         * @param {string} [affectsTrackersUpdatedDt] 
         * @param {string} [affectsTrackersUpdatedDtDate] 
         * @param {string} [affectsTrackersUpdatedDtDateGte] 
         * @param {string} [affectsTrackersUpdatedDtDateLte] 
         * @param {string} [affectsTrackersUpdatedDtGt] 
         * @param {string} [affectsTrackersUpdatedDtGte] 
         * @param {string} [affectsTrackersUpdatedDtLt] 
         * @param {string} [affectsTrackersUpdatedDtLte] 
         * @param {string} [affectsTrackersUuid] 
         * @param {string} [affectsUpdatedDt] 
         * @param {string} [affectsUpdatedDtDate] 
         * @param {string} [affectsUpdatedDtDateGte] 
         * @param {string} [affectsUpdatedDtDateLte] 
         * @param {string} [affectsUpdatedDtGt] 
         * @param {string} [affectsUpdatedDtGte] 
         * @param {string} [affectsUpdatedDtLt] 
         * @param {string} [affectsUpdatedDtLte] 
         * @param {string} [affectsUuid] 
         * @param {number} [bzId] 
         * @param {string} [changedAfter] 
         * @param {string} [changedBefore] 
         * @param {string} [commentZero] 
         * @param {Array<string>} [components] Multiple values may be separated by commas.
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {string} [cveDescription] 
         * @param {boolean} [cveDescriptionIsempty] 
         * @param {Array<string>} [cveId] Multiple values may be separated by commas.
         * @param {boolean} [cveIdIsempty] 
         * @param {boolean} [cvss2NistIsempty] 
         * @param {boolean} [cvss2RhIsempty] 
         * @param {boolean} [cvss3NistIsempty] 
         * @param {boolean} [cvss3RhIsempty] 
         * @param {boolean} [cvss4NistIsempty] 
         * @param {boolean} [cvss4RhIsempty] 
         * @param {string} [cvssScoresComment] 
         * @param {string} [cvssScoresCreatedDt] 
         * @param {string} [cvssScoresCreatedDtDate] 
         * @param {string} [cvssScoresCreatedDtDateGte] 
         * @param {string} [cvssScoresCreatedDtDateLte] 
         * @param {string} [cvssScoresCreatedDtGt] 
         * @param {string} [cvssScoresCreatedDtGte] 
         * @param {string} [cvssScoresCreatedDtLt] 
         * @param {string} [cvssScoresCreatedDtLte] 
         * @param {string} [cvssScoresCvssVersion] 
         * @param {'NIST' | 'OSV' | 'RH'} [cvssScoresIssuer] 
         * @param {number} [cvssScoresScore] 
         * @param {string} [cvssScoresUpdatedDt] 
         * @param {string} [cvssScoresUpdatedDtDate] 
         * @param {string} [cvssScoresUpdatedDtDateGte] 
         * @param {string} [cvssScoresUpdatedDtDateLte] 
         * @param {string} [cvssScoresUpdatedDtGt] 
         * @param {string} [cvssScoresUpdatedDtGte] 
         * @param {string} [cvssScoresUpdatedDtLt] 
         * @param {string} [cvssScoresUpdatedDtLte] 
         * @param {string} [cvssScoresUuid] 
         * @param {string} [cvssScoresVector] 
         * @param {string} [cweId] 
         * @param {boolean} [cweIdIsempty] 
         * @param {boolean} [embargoed] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [impact] 
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [majorIncidentStartDt] 
         * @param {string} [majorIncidentStartDtDate] 
         * @param {string} [majorIncidentStartDtDateGte] 
         * @param {string} [majorIncidentStartDtDateLte] 
         * @param {string} [majorIncidentStartDtGt] 
         * @param {string} [majorIncidentStartDtGte] 
         * @param {string} [majorIncidentStartDtLt] 
         * @param {string} [majorIncidentStartDtLte] 
         * @param {'' | 'APPROVED' | 'CISA_APPROVED' | 'INVALID' | 'REJECTED' | 'REQUESTED'} [majorIncidentState] 
         * @param {boolean} [mitigationIsempty] 
         * @param {'' | 'APPROVED' | 'REJECTED' | 'REQUESTED'} [nistCvssValidation] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {Array<'-acknowledgments__affiliation' | '-acknowledgments__created_dt' | '-acknowledgments__from_upstream' | '-acknowledgments__name' | '-acknowledgments__updated_dt' | '-acknowledgments__uuid' | '-affects__affectedness' | '-affects__created_dt' | '-affects__impact' | '-affects__ps_component' | '-affects__ps_module' | '-affects__resolution' | '-affects__trackers__created_dt' | '-affects__trackers__errata__advisory_name' | '-affects__trackers__errata__et_id' | '-affects__trackers__errata__shipped_dt' | '-affects__trackers__external_system_id' | '-affects__trackers__ps_update_stream' | '-affects__trackers__resolution' | '-affects__trackers__status' | '-affects__trackers__type' | '-affects__trackers__updated_dt' | '-affects__trackers__uuid' | '-affects__updated_dt' | '-affects__uuid' | '-bz_id' | '-comment_zero' | '-components' | '-created_dt' | '-cve_description' | '-cve_id' | '-cvss_scores__comment' | '-cvss_scores__created_dt' | '-cvss_scores__issuer' | '-cvss_scores__score' | '-cvss_scores__updated_dt' | '-cvss_scores__uuid' | '-cvss_scores__vector' | '-cwe_id' | '-embargoed' | '-impact' | '-major_incident_start_dt' | '-major_incident_state' | '-nist_cvss_validation' | '-owner' | '-references__created_dt' | '-references__description' | '-references__type' | '-references__updated_dt' | '-references__url' | '-references__uuid' | '-reported_dt' | '-requires_cve_description' | '-source' | '-statement' | '-team_id' | '-title' | '-unembargo_dt' | '-updated_dt' | '-uuid' | '-workflow_state' | 'acknowledgments__affiliation' | 'acknowledgments__created_dt' | 'acknowledgments__from_upstream' | 'acknowledgments__name' | 'acknowledgments__updated_dt' | 'acknowledgments__uuid' | 'affects__affectedness' | 'affects__created_dt' | 'affects__impact' | 'affects__ps_component' | 'affects__ps_module' | 'affects__resolution' | 'affects__trackers__created_dt' | 'affects__trackers__errata__advisory_name' | 'affects__trackers__errata__et_id' | 'affects__trackers__errata__shipped_dt' | 'affects__trackers__external_system_id' | 'affects__trackers__ps_update_stream' | 'affects__trackers__resolution' | 'affects__trackers__status' | 'affects__trackers__type' | 'affects__trackers__updated_dt' | 'affects__trackers__uuid' | 'affects__updated_dt' | 'affects__uuid' | 'bz_id' | 'comment_zero' | 'components' | 'created_dt' | 'cve_description' | 'cve_id' | 'cvss_scores__comment' | 'cvss_scores__created_dt' | 'cvss_scores__issuer' | 'cvss_scores__score' | 'cvss_scores__updated_dt' | 'cvss_scores__uuid' | 'cvss_scores__vector' | 'cwe_id' | 'embargoed' | 'impact' | 'major_incident_start_dt' | 'major_incident_state' | 'nist_cvss_validation' | 'owner' | 'references__created_dt' | 'references__description' | 'references__type' | 'references__updated_dt' | 'references__url' | 'references__uuid' | 'reported_dt' | 'requires_cve_description' | 'source' | 'statement' | 'team_id' | 'title' | 'unembargo_dt' | 'updated_dt' | 'uuid' | 'workflow_state'>} [order] Ordering
         * @param {string} [owner] 
         * @param {boolean} [ownerIsempty] 
         * @param {string} [referencesCreatedDt] 
         * @param {string} [referencesCreatedDtDate] 
         * @param {string} [referencesCreatedDtDateGte] 
         * @param {string} [referencesCreatedDtDateLte] 
         * @param {string} [referencesCreatedDtGt] 
         * @param {string} [referencesCreatedDtGte] 
         * @param {string} [referencesCreatedDtLt] 
         * @param {string} [referencesCreatedDtLte] 
         * @param {string} [referencesDescription] 
         * @param {'ARTICLE' | 'EXTERNAL' | 'SOURCE'} [referencesType] 
         * @param {string} [referencesUpdatedDt] 
         * @param {string} [referencesUpdatedDtDate] 
         * @param {string} [referencesUpdatedDtDateGte] 
         * @param {string} [referencesUpdatedDtDateLte] 
         * @param {string} [referencesUpdatedDtGt] 
         * @param {string} [referencesUpdatedDtGte] 
         * @param {string} [referencesUpdatedDtLt] 
         * @param {string} [referencesUpdatedDtLte] 
         * @param {string} [referencesUrl] 
         * @param {string} [referencesUuid] 
         * @param {string} [reportedDt] 
         * @param {string} [reportedDtDate] 
         * @param {string} [reportedDtDateGte] 
         * @param {string} [reportedDtDateLte] 
         * @param {string} [reportedDtGt] 
         * @param {string} [reportedDtGte] 
         * @param {string} [reportedDtLt] 
         * @param {string} [reportedDtLte] 
         * @param {'' | 'APPROVED' | 'REJECTED' | 'REQUESTED'} [requiresCveDescription] 
         * @param {string} [search] 
         * @param {'' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'NVD' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'OSV' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF'} [source] 
         * @param {string} [statement] 
         * @param {boolean} [statementIsempty] 
         * @param {string} [teamId] 
         * @param {string} [title] 
         * @param {Array<string>} [trackerIds] Filter only Flaws which are related to specified Trackers (through Affects). Multiple tracker IDs may be separated by commas. Also only Affects that have the specified Trackers related will be shown.
         * @param {string} [unembargoDt] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {Array<'' | 'DONE' | 'NEW' | 'PRE_SECONDARY_ASSESSMENT' | 'REJECTED' | 'SECONDARY_ASSESSMENT' | 'TRIAGE'>} [workflowState] Multiple values may be separated by commas.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsList(acknowledgmentsAffiliation?: string, acknowledgmentsCreatedDt?: string, acknowledgmentsCreatedDtDate?: string, acknowledgmentsCreatedDtDateGte?: string, acknowledgmentsCreatedDtDateLte?: string, acknowledgmentsCreatedDtGt?: string, acknowledgmentsCreatedDtGte?: string, acknowledgmentsCreatedDtLt?: string, acknowledgmentsCreatedDtLte?: string, acknowledgmentsFromUpstream?: boolean, acknowledgmentsName?: string, acknowledgmentsUpdatedDt?: string, acknowledgmentsUpdatedDtDate?: string, acknowledgmentsUpdatedDtDateGte?: string, acknowledgmentsUpdatedDtDateLte?: string, acknowledgmentsUpdatedDtGt?: string, acknowledgmentsUpdatedDtGte?: string, acknowledgmentsUpdatedDtLt?: string, acknowledgmentsUpdatedDtLte?: string, acknowledgmentsUuid?: string, affectsAffectedness?: '' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED', affectsCreatedDt?: string, affectsCreatedDtDate?: string, affectsCreatedDtDateGte?: string, affectsCreatedDtDateLte?: string, affectsCreatedDtGt?: string, affectsCreatedDtGte?: string, affectsCreatedDtLt?: string, affectsCreatedDtLte?: string, affectsEmbargoed?: boolean, affectsImpact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', affectsPsComponent?: string, affectsPsModule?: string, affectsResolution?: '' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT', affectsTrackersCreatedDt?: string, affectsTrackersCreatedDtDate?: string, affectsTrackersCreatedDtDateGte?: string, affectsTrackersCreatedDtDateLte?: string, affectsTrackersCreatedDtGt?: string, affectsTrackersCreatedDtGte?: string, affectsTrackersCreatedDtLt?: string, affectsTrackersCreatedDtLte?: string, affectsTrackersEmbargoed?: boolean, affectsTrackersErrataAdvisoryName?: string, affectsTrackersErrataEtId?: number, affectsTrackersErrataShippedDt?: string, affectsTrackersErrataShippedDtDate?: string, affectsTrackersErrataShippedDtDateGte?: string, affectsTrackersErrataShippedDtDateLte?: string, affectsTrackersErrataShippedDtGt?: string, affectsTrackersErrataShippedDtGte?: string, affectsTrackersErrataShippedDtLt?: string, affectsTrackersErrataShippedDtLte?: string, affectsTrackersExternalSystemId?: string, affectsTrackersPsUpdateStream?: string, affectsTrackersResolution?: string, affectsTrackersStatus?: string, affectsTrackersType?: 'BUGZILLA' | 'JIRA', affectsTrackersUpdatedDt?: string, affectsTrackersUpdatedDtDate?: string, affectsTrackersUpdatedDtDateGte?: string, affectsTrackersUpdatedDtDateLte?: string, affectsTrackersUpdatedDtGt?: string, affectsTrackersUpdatedDtGte?: string, affectsTrackersUpdatedDtLt?: string, affectsTrackersUpdatedDtLte?: string, affectsTrackersUuid?: string, affectsUpdatedDt?: string, affectsUpdatedDtDate?: string, affectsUpdatedDtDateGte?: string, affectsUpdatedDtDateLte?: string, affectsUpdatedDtGt?: string, affectsUpdatedDtGte?: string, affectsUpdatedDtLt?: string, affectsUpdatedDtLte?: string, affectsUuid?: string, bzId?: number, changedAfter?: string, changedBefore?: string, commentZero?: string, components?: Array<string>, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, cveDescription?: string, cveDescriptionIsempty?: boolean, cveId?: Array<string>, cveIdIsempty?: boolean, cvss2NistIsempty?: boolean, cvss2RhIsempty?: boolean, cvss3NistIsempty?: boolean, cvss3RhIsempty?: boolean, cvss4NistIsempty?: boolean, cvss4RhIsempty?: boolean, cvssScoresComment?: string, cvssScoresCreatedDt?: string, cvssScoresCreatedDtDate?: string, cvssScoresCreatedDtDateGte?: string, cvssScoresCreatedDtDateLte?: string, cvssScoresCreatedDtGt?: string, cvssScoresCreatedDtGte?: string, cvssScoresCreatedDtLt?: string, cvssScoresCreatedDtLte?: string, cvssScoresCvssVersion?: string, cvssScoresIssuer?: 'NIST' | 'OSV' | 'RH', cvssScoresScore?: number, cvssScoresUpdatedDt?: string, cvssScoresUpdatedDtDate?: string, cvssScoresUpdatedDtDateGte?: string, cvssScoresUpdatedDtDateLte?: string, cvssScoresUpdatedDtGt?: string, cvssScoresUpdatedDtGte?: string, cvssScoresUpdatedDtLt?: string, cvssScoresUpdatedDtLte?: string, cvssScoresUuid?: string, cvssScoresVector?: string, cweId?: string, cweIdIsempty?: boolean, embargoed?: boolean, excludeFields?: Array<string>, impact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', includeFields?: Array<string>, includeMetaAttr?: Array<string>, limit?: number, majorIncidentStartDt?: string, majorIncidentStartDtDate?: string, majorIncidentStartDtDateGte?: string, majorIncidentStartDtDateLte?: string, majorIncidentStartDtGt?: string, majorIncidentStartDtGte?: string, majorIncidentStartDtLt?: string, majorIncidentStartDtLte?: string, majorIncidentState?: '' | 'APPROVED' | 'CISA_APPROVED' | 'INVALID' | 'REJECTED' | 'REQUESTED', mitigationIsempty?: boolean, nistCvssValidation?: '' | 'APPROVED' | 'REJECTED' | 'REQUESTED', offset?: number, order?: Array<'-acknowledgments__affiliation' | '-acknowledgments__created_dt' | '-acknowledgments__from_upstream' | '-acknowledgments__name' | '-acknowledgments__updated_dt' | '-acknowledgments__uuid' | '-affects__affectedness' | '-affects__created_dt' | '-affects__impact' | '-affects__ps_component' | '-affects__ps_module' | '-affects__resolution' | '-affects__trackers__created_dt' | '-affects__trackers__errata__advisory_name' | '-affects__trackers__errata__et_id' | '-affects__trackers__errata__shipped_dt' | '-affects__trackers__external_system_id' | '-affects__trackers__ps_update_stream' | '-affects__trackers__resolution' | '-affects__trackers__status' | '-affects__trackers__type' | '-affects__trackers__updated_dt' | '-affects__trackers__uuid' | '-affects__updated_dt' | '-affects__uuid' | '-bz_id' | '-comment_zero' | '-components' | '-created_dt' | '-cve_description' | '-cve_id' | '-cvss_scores__comment' | '-cvss_scores__created_dt' | '-cvss_scores__issuer' | '-cvss_scores__score' | '-cvss_scores__updated_dt' | '-cvss_scores__uuid' | '-cvss_scores__vector' | '-cwe_id' | '-embargoed' | '-impact' | '-major_incident_start_dt' | '-major_incident_state' | '-nist_cvss_validation' | '-owner' | '-references__created_dt' | '-references__description' | '-references__type' | '-references__updated_dt' | '-references__url' | '-references__uuid' | '-reported_dt' | '-requires_cve_description' | '-source' | '-statement' | '-team_id' | '-title' | '-unembargo_dt' | '-updated_dt' | '-uuid' | '-workflow_state' | 'acknowledgments__affiliation' | 'acknowledgments__created_dt' | 'acknowledgments__from_upstream' | 'acknowledgments__name' | 'acknowledgments__updated_dt' | 'acknowledgments__uuid' | 'affects__affectedness' | 'affects__created_dt' | 'affects__impact' | 'affects__ps_component' | 'affects__ps_module' | 'affects__resolution' | 'affects__trackers__created_dt' | 'affects__trackers__errata__advisory_name' | 'affects__trackers__errata__et_id' | 'affects__trackers__errata__shipped_dt' | 'affects__trackers__external_system_id' | 'affects__trackers__ps_update_stream' | 'affects__trackers__resolution' | 'affects__trackers__status' | 'affects__trackers__type' | 'affects__trackers__updated_dt' | 'affects__trackers__uuid' | 'affects__updated_dt' | 'affects__uuid' | 'bz_id' | 'comment_zero' | 'components' | 'created_dt' | 'cve_description' | 'cve_id' | 'cvss_scores__comment' | 'cvss_scores__created_dt' | 'cvss_scores__issuer' | 'cvss_scores__score' | 'cvss_scores__updated_dt' | 'cvss_scores__uuid' | 'cvss_scores__vector' | 'cwe_id' | 'embargoed' | 'impact' | 'major_incident_start_dt' | 'major_incident_state' | 'nist_cvss_validation' | 'owner' | 'references__created_dt' | 'references__description' | 'references__type' | 'references__updated_dt' | 'references__url' | 'references__uuid' | 'reported_dt' | 'requires_cve_description' | 'source' | 'statement' | 'team_id' | 'title' | 'unembargo_dt' | 'updated_dt' | 'uuid' | 'workflow_state'>, owner?: string, ownerIsempty?: boolean, referencesCreatedDt?: string, referencesCreatedDtDate?: string, referencesCreatedDtDateGte?: string, referencesCreatedDtDateLte?: string, referencesCreatedDtGt?: string, referencesCreatedDtGte?: string, referencesCreatedDtLt?: string, referencesCreatedDtLte?: string, referencesDescription?: string, referencesType?: 'ARTICLE' | 'EXTERNAL' | 'SOURCE', referencesUpdatedDt?: string, referencesUpdatedDtDate?: string, referencesUpdatedDtDateGte?: string, referencesUpdatedDtDateLte?: string, referencesUpdatedDtGt?: string, referencesUpdatedDtGte?: string, referencesUpdatedDtLt?: string, referencesUpdatedDtLte?: string, referencesUrl?: string, referencesUuid?: string, reportedDt?: string, reportedDtDate?: string, reportedDtDateGte?: string, reportedDtDateLte?: string, reportedDtGt?: string, reportedDtGte?: string, reportedDtLt?: string, reportedDtLte?: string, requiresCveDescription?: '' | 'APPROVED' | 'REJECTED' | 'REQUESTED', search?: string, source?: '' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'NVD' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'OSV' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF', statement?: string, statementIsempty?: boolean, teamId?: string, title?: string, trackerIds?: Array<string>, unembargoDt?: string, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, workflowState?: Array<'' | 'DONE' | 'NEW' | 'PRE_SECONDARY_ASSESSMENT' | 'REJECTED' | 'SECONDARY_ASSESSMENT' | 'TRIAGE'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsList(acknowledgmentsAffiliation, acknowledgmentsCreatedDt, acknowledgmentsCreatedDtDate, acknowledgmentsCreatedDtDateGte, acknowledgmentsCreatedDtDateLte, acknowledgmentsCreatedDtGt, acknowledgmentsCreatedDtGte, acknowledgmentsCreatedDtLt, acknowledgmentsCreatedDtLte, acknowledgmentsFromUpstream, acknowledgmentsName, acknowledgmentsUpdatedDt, acknowledgmentsUpdatedDtDate, acknowledgmentsUpdatedDtDateGte, acknowledgmentsUpdatedDtDateLte, acknowledgmentsUpdatedDtGt, acknowledgmentsUpdatedDtGte, acknowledgmentsUpdatedDtLt, acknowledgmentsUpdatedDtLte, acknowledgmentsUuid, affectsAffectedness, affectsCreatedDt, affectsCreatedDtDate, affectsCreatedDtDateGte, affectsCreatedDtDateLte, affectsCreatedDtGt, affectsCreatedDtGte, affectsCreatedDtLt, affectsCreatedDtLte, affectsEmbargoed, affectsImpact, affectsPsComponent, affectsPsModule, affectsResolution, affectsTrackersCreatedDt, affectsTrackersCreatedDtDate, affectsTrackersCreatedDtDateGte, affectsTrackersCreatedDtDateLte, affectsTrackersCreatedDtGt, affectsTrackersCreatedDtGte, affectsTrackersCreatedDtLt, affectsTrackersCreatedDtLte, affectsTrackersEmbargoed, affectsTrackersErrataAdvisoryName, affectsTrackersErrataEtId, affectsTrackersErrataShippedDt, affectsTrackersErrataShippedDtDate, affectsTrackersErrataShippedDtDateGte, affectsTrackersErrataShippedDtDateLte, affectsTrackersErrataShippedDtGt, affectsTrackersErrataShippedDtGte, affectsTrackersErrataShippedDtLt, affectsTrackersErrataShippedDtLte, affectsTrackersExternalSystemId, affectsTrackersPsUpdateStream, affectsTrackersResolution, affectsTrackersStatus, affectsTrackersType, affectsTrackersUpdatedDt, affectsTrackersUpdatedDtDate, affectsTrackersUpdatedDtDateGte, affectsTrackersUpdatedDtDateLte, affectsTrackersUpdatedDtGt, affectsTrackersUpdatedDtGte, affectsTrackersUpdatedDtLt, affectsTrackersUpdatedDtLte, affectsTrackersUuid, affectsUpdatedDt, affectsUpdatedDtDate, affectsUpdatedDtDateGte, affectsUpdatedDtDateLte, affectsUpdatedDtGt, affectsUpdatedDtGte, affectsUpdatedDtLt, affectsUpdatedDtLte, affectsUuid, bzId, changedAfter, changedBefore, commentZero, components, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, cveDescription, cveDescriptionIsempty, cveId, cveIdIsempty, cvss2NistIsempty, cvss2RhIsempty, cvss3NistIsempty, cvss3RhIsempty, cvss4NistIsempty, cvss4RhIsempty, cvssScoresComment, cvssScoresCreatedDt, cvssScoresCreatedDtDate, cvssScoresCreatedDtDateGte, cvssScoresCreatedDtDateLte, cvssScoresCreatedDtGt, cvssScoresCreatedDtGte, cvssScoresCreatedDtLt, cvssScoresCreatedDtLte, cvssScoresCvssVersion, cvssScoresIssuer, cvssScoresScore, cvssScoresUpdatedDt, cvssScoresUpdatedDtDate, cvssScoresUpdatedDtDateGte, cvssScoresUpdatedDtDateLte, cvssScoresUpdatedDtGt, cvssScoresUpdatedDtGte, cvssScoresUpdatedDtLt, cvssScoresUpdatedDtLte, cvssScoresUuid, cvssScoresVector, cweId, cweIdIsempty, embargoed, excludeFields, impact, includeFields, includeMetaAttr, limit, majorIncidentStartDt, majorIncidentStartDtDate, majorIncidentStartDtDateGte, majorIncidentStartDtDateLte, majorIncidentStartDtGt, majorIncidentStartDtGte, majorIncidentStartDtLt, majorIncidentStartDtLte, majorIncidentState, mitigationIsempty, nistCvssValidation, offset, order, owner, ownerIsempty, referencesCreatedDt, referencesCreatedDtDate, referencesCreatedDtDateGte, referencesCreatedDtDateLte, referencesCreatedDtGt, referencesCreatedDtGte, referencesCreatedDtLt, referencesCreatedDtLte, referencesDescription, referencesType, referencesUpdatedDt, referencesUpdatedDtDate, referencesUpdatedDtDateGte, referencesUpdatedDtDateLte, referencesUpdatedDtGt, referencesUpdatedDtGte, referencesUpdatedDtLt, referencesUpdatedDtLte, referencesUrl, referencesUuid, reportedDt, reportedDtDate, reportedDtDateGte, reportedDtDateLte, reportedDtGt, reportedDtGte, reportedDtLt, reportedDtLte, requiresCveDescription, search, source, statement, statementIsempty, teamId, title, trackerIds, unembargoDt, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, workflowState, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId 
         * @param {FlawPackageVersionPost} flawPackageVersionPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsPackageVersionsCreate(bugzillaApiKey: string, flawId: string, flawPackageVersionPost: FlawPackageVersionPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsPackageVersionsCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsPackageVersionsCreate(bugzillaApiKey, flawId, flawPackageVersionPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Destroy the instance and proxy the delete to Bugzilla
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsPackageVersionsDestroy(bugzillaApiKey: string, flawId: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200ResponseAllOf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsPackageVersionsDestroy(bugzillaApiKey, flawId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [_package] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {string} [versionsVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsPackageVersionsList(flawId: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, excludeFields?: Array<string>, includeFields?: Array<string>, limit?: number, offset?: number, _package?: string, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, versionsVersion?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsPackageVersionsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsPackageVersionsList(flawId, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, excludeFields, includeFields, limit, offset, _package, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, versionsVersion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} id 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsPackageVersionsRetrieve(flawId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsPackageVersionsCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsPackageVersionsRetrieve(flawId, id, excludeFields, includeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId 
         * @param {string} id 
         * @param {FlawPackageVersionPut} flawPackageVersionPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsPackageVersionsUpdate(bugzillaApiKey: string, flawId: string, id: string, flawPackageVersionPut: FlawPackageVersionPut, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsPackageVersionsCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsPackageVersionsUpdate(bugzillaApiKey, flawId, id, flawPackageVersionPut, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * workflow promotion API endpoint  try to adjust workflow classification of flaw to the next state available return its workflow:state classification or errors if not possible to promote
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {string} flawId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsPromoteCreate(bugzillaApiKey: string, jiraApiKey: string, flawId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200ResponseAllOf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsPromoteCreate(bugzillaApiKey, jiraApiKey, flawId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId 
         * @param {FlawReferencePost} flawReferencePost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsReferencesCreate(bugzillaApiKey: string, flawId: string, flawReferencePost: FlawReferencePost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsReferencesCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsReferencesCreate(bugzillaApiKey, flawId, flawReferencePost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Destroy the instance and proxy the delete to Bugzilla
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsReferencesDestroy(bugzillaApiKey: string, flawId: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200ResponseAllOf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsReferencesDestroy(bugzillaApiKey, flawId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {string} [description] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {'ARTICLE' | 'EXTERNAL' | 'SOURCE'} [type] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [url] 
         * @param {string} [uuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsReferencesList(flawId: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, description?: string, excludeFields?: Array<string>, includeFields?: Array<string>, limit?: number, offset?: number, type?: 'ARTICLE' | 'EXTERNAL' | 'SOURCE', updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, url?: string, uuid?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsReferencesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsReferencesList(flawId, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, description, excludeFields, includeFields, limit, offset, type, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, url, uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} id 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsReferencesRetrieve(flawId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsReferencesCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsReferencesRetrieve(flawId, id, excludeFields, includeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId 
         * @param {string} id 
         * @param {FlawReferencePut} flawReferencePut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsReferencesUpdate(bugzillaApiKey: string, flawId: string, id: string, flawReferencePut: FlawReferencePut, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsReferencesCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsReferencesUpdate(bugzillaApiKey, flawId, id, flawReferencePut, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * workflow promotion API endpoint  try to reject a flaw / task
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {string} flawId 
         * @param {Reject} reject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsRejectCreate(bugzillaApiKey: string, jiraApiKey: string, flawId: string, reject: Reject, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200ResponseAllOf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsRejectCreate(bugzillaApiKey, jiraApiKey, flawId, reject, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {Array<string>} [trackerIds] Filter only Flaws which are related to specified Trackers (through Affects). Multiple tracker IDs may be separated by commas. Also only Affects that have the specified Trackers related will be shown.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsRetrieve(id: string, excludeFields?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, trackerIds?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsRetrieve(id, excludeFields, includeFields, includeMetaAttr, trackerIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {string} id A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
         * @param {Flaw} flaw 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1FlawsUpdate(bugzillaApiKey: string, jiraApiKey: string, id: string, flaw: Flaw, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1FlawsCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1FlawsUpdate(bugzillaApiKey, jiraApiKey, id, flaw, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * HTTP get /manifest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1ManifestRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200ResponseAllOf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1ManifestRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {'json' | 'yaml'} [format] 
         * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1SchemaRetrieve(format?: 'json' | 'yaml', lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1SchemaRetrieve(format, lang, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * HTTP get /status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1StatusRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1StatusRetrieve200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1StatusRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {TrackerPost} trackerPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1TrackersCreate(bugzillaApiKey: string, jiraApiKey: string, trackerPost: TrackerPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1TrackersCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1TrackersCreate(bugzillaApiKey, jiraApiKey, trackerPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {'' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED'} [affectsAffectedness] 
         * @param {string} [affectsCreatedDt] 
         * @param {string} [affectsCreatedDtDate] 
         * @param {string} [affectsCreatedDtDateGte] 
         * @param {string} [affectsCreatedDtDateLte] 
         * @param {string} [affectsCreatedDtGt] 
         * @param {string} [affectsCreatedDtGte] 
         * @param {string} [affectsCreatedDtLt] 
         * @param {string} [affectsCreatedDtLte] 
         * @param {boolean} [affectsEmbargoed] 
         * @param {Array<string>} [affectsFlawComponents] Multiple values may be separated by commas.
         * @param {string} [affectsFlawCreatedDt] 
         * @param {string} [affectsFlawCreatedDtDate] 
         * @param {string} [affectsFlawCreatedDtDateGte] 
         * @param {string} [affectsFlawCreatedDtDateLte] 
         * @param {string} [affectsFlawCreatedDtGt] 
         * @param {string} [affectsFlawCreatedDtGte] 
         * @param {string} [affectsFlawCreatedDtLt] 
         * @param {string} [affectsFlawCreatedDtLte] 
         * @param {string} [affectsFlawCveId] 
         * @param {string} [affectsFlawCweId] 
         * @param {boolean} [affectsFlawEmbargoed] 
         * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [affectsFlawImpact] 
         * @param {string} [affectsFlawReportedDt] 
         * @param {string} [affectsFlawReportedDtDate] 
         * @param {string} [affectsFlawReportedDtDateGte] 
         * @param {string} [affectsFlawReportedDtDateLte] 
         * @param {string} [affectsFlawReportedDtGt] 
         * @param {string} [affectsFlawReportedDtGte] 
         * @param {string} [affectsFlawReportedDtLt] 
         * @param {string} [affectsFlawReportedDtLte] 
         * @param {'' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'NVD' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'OSV' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF'} [affectsFlawSource] 
         * @param {string} [affectsFlawUnembargoDt] 
         * @param {string} [affectsFlawUpdatedDt] 
         * @param {string} [affectsFlawUpdatedDtDate] 
         * @param {string} [affectsFlawUpdatedDtDateGte] 
         * @param {string} [affectsFlawUpdatedDtDateLte] 
         * @param {string} [affectsFlawUpdatedDtGt] 
         * @param {string} [affectsFlawUpdatedDtGte] 
         * @param {string} [affectsFlawUpdatedDtLt] 
         * @param {string} [affectsFlawUpdatedDtLte] 
         * @param {string} [affectsFlawUuid] 
         * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [affectsImpact] 
         * @param {string} [affectsPsComponent] 
         * @param {string} [affectsPsModule] 
         * @param {'' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT'} [affectsResolution] 
         * @param {string} [affectsUpdatedDt] 
         * @param {string} [affectsUpdatedDtDate] 
         * @param {string} [affectsUpdatedDtDateGte] 
         * @param {string} [affectsUpdatedDtDateLte] 
         * @param {string} [affectsUpdatedDtGt] 
         * @param {string} [affectsUpdatedDtGte] 
         * @param {string} [affectsUpdatedDtLt] 
         * @param {string} [affectsUpdatedDtLte] 
         * @param {string} [affectsUuid] 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {boolean} [embargoed] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {string} [externalSystemId] 
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {Array<'-affects__affectedness' | '-affects__created_dt' | '-affects__embargoed' | '-affects__flaw__components' | '-affects__flaw__created_dt' | '-affects__flaw__cve_id' | '-affects__flaw__cwe_id' | '-affects__flaw__embargoed' | '-affects__flaw__impact' | '-affects__flaw__reported_dt' | '-affects__flaw__source' | '-affects__flaw__unembargo_dt' | '-affects__flaw__updated_dt' | '-affects__flaw__uuid' | '-affects__impact' | '-affects__ps_component' | '-affects__ps_module' | '-affects__resolution' | '-affects__updated_dt' | '-affects__uuid' | '-created_dt' | '-embargoed' | '-external_system_id' | '-ps_update_stream' | '-resolution' | '-status' | '-type' | '-updated_dt' | '-uuid' | 'affects__affectedness' | 'affects__created_dt' | 'affects__embargoed' | 'affects__flaw__components' | 'affects__flaw__created_dt' | 'affects__flaw__cve_id' | 'affects__flaw__cwe_id' | 'affects__flaw__embargoed' | 'affects__flaw__impact' | 'affects__flaw__reported_dt' | 'affects__flaw__source' | 'affects__flaw__unembargo_dt' | 'affects__flaw__updated_dt' | 'affects__flaw__uuid' | 'affects__impact' | 'affects__ps_component' | 'affects__ps_module' | 'affects__resolution' | 'affects__updated_dt' | 'affects__uuid' | 'created_dt' | 'embargoed' | 'external_system_id' | 'ps_update_stream' | 'resolution' | 'status' | 'type' | 'updated_dt' | 'uuid'>} [order] Ordering
         * @param {string} [psUpdateStream] 
         * @param {string} [resolution] 
         * @param {string} [status] 
         * @param {'BUGZILLA' | 'JIRA'} [type] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1TrackersList(affectsAffectedness?: '' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED', affectsCreatedDt?: string, affectsCreatedDtDate?: string, affectsCreatedDtDateGte?: string, affectsCreatedDtDateLte?: string, affectsCreatedDtGt?: string, affectsCreatedDtGte?: string, affectsCreatedDtLt?: string, affectsCreatedDtLte?: string, affectsEmbargoed?: boolean, affectsFlawComponents?: Array<string>, affectsFlawCreatedDt?: string, affectsFlawCreatedDtDate?: string, affectsFlawCreatedDtDateGte?: string, affectsFlawCreatedDtDateLte?: string, affectsFlawCreatedDtGt?: string, affectsFlawCreatedDtGte?: string, affectsFlawCreatedDtLt?: string, affectsFlawCreatedDtLte?: string, affectsFlawCveId?: string, affectsFlawCweId?: string, affectsFlawEmbargoed?: boolean, affectsFlawImpact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', affectsFlawReportedDt?: string, affectsFlawReportedDtDate?: string, affectsFlawReportedDtDateGte?: string, affectsFlawReportedDtDateLte?: string, affectsFlawReportedDtGt?: string, affectsFlawReportedDtGte?: string, affectsFlawReportedDtLt?: string, affectsFlawReportedDtLte?: string, affectsFlawSource?: '' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'NVD' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'OSV' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF', affectsFlawUnembargoDt?: string, affectsFlawUpdatedDt?: string, affectsFlawUpdatedDtDate?: string, affectsFlawUpdatedDtDateGte?: string, affectsFlawUpdatedDtDateLte?: string, affectsFlawUpdatedDtGt?: string, affectsFlawUpdatedDtGte?: string, affectsFlawUpdatedDtLt?: string, affectsFlawUpdatedDtLte?: string, affectsFlawUuid?: string, affectsImpact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', affectsPsComponent?: string, affectsPsModule?: string, affectsResolution?: '' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT', affectsUpdatedDt?: string, affectsUpdatedDtDate?: string, affectsUpdatedDtDateGte?: string, affectsUpdatedDtDateLte?: string, affectsUpdatedDtGt?: string, affectsUpdatedDtGte?: string, affectsUpdatedDtLt?: string, affectsUpdatedDtLte?: string, affectsUuid?: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, embargoed?: boolean, excludeFields?: Array<string>, externalSystemId?: string, includeFields?: Array<string>, includeMetaAttr?: Array<string>, limit?: number, offset?: number, order?: Array<'-affects__affectedness' | '-affects__created_dt' | '-affects__embargoed' | '-affects__flaw__components' | '-affects__flaw__created_dt' | '-affects__flaw__cve_id' | '-affects__flaw__cwe_id' | '-affects__flaw__embargoed' | '-affects__flaw__impact' | '-affects__flaw__reported_dt' | '-affects__flaw__source' | '-affects__flaw__unembargo_dt' | '-affects__flaw__updated_dt' | '-affects__flaw__uuid' | '-affects__impact' | '-affects__ps_component' | '-affects__ps_module' | '-affects__resolution' | '-affects__updated_dt' | '-affects__uuid' | '-created_dt' | '-embargoed' | '-external_system_id' | '-ps_update_stream' | '-resolution' | '-status' | '-type' | '-updated_dt' | '-uuid' | 'affects__affectedness' | 'affects__created_dt' | 'affects__embargoed' | 'affects__flaw__components' | 'affects__flaw__created_dt' | 'affects__flaw__cve_id' | 'affects__flaw__cwe_id' | 'affects__flaw__embargoed' | 'affects__flaw__impact' | 'affects__flaw__reported_dt' | 'affects__flaw__source' | 'affects__flaw__unembargo_dt' | 'affects__flaw__updated_dt' | 'affects__flaw__uuid' | 'affects__impact' | 'affects__ps_component' | 'affects__ps_module' | 'affects__resolution' | 'affects__updated_dt' | 'affects__uuid' | 'created_dt' | 'embargoed' | 'external_system_id' | 'ps_update_stream' | 'resolution' | 'status' | 'type' | 'updated_dt' | 'uuid'>, psUpdateStream?: string, resolution?: string, status?: string, type?: 'BUGZILLA' | 'JIRA', updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1TrackersList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1TrackersList(affectsAffectedness, affectsCreatedDt, affectsCreatedDtDate, affectsCreatedDtDateGte, affectsCreatedDtDateLte, affectsCreatedDtGt, affectsCreatedDtGte, affectsCreatedDtLt, affectsCreatedDtLte, affectsEmbargoed, affectsFlawComponents, affectsFlawCreatedDt, affectsFlawCreatedDtDate, affectsFlawCreatedDtDateGte, affectsFlawCreatedDtDateLte, affectsFlawCreatedDtGt, affectsFlawCreatedDtGte, affectsFlawCreatedDtLt, affectsFlawCreatedDtLte, affectsFlawCveId, affectsFlawCweId, affectsFlawEmbargoed, affectsFlawImpact, affectsFlawReportedDt, affectsFlawReportedDtDate, affectsFlawReportedDtDateGte, affectsFlawReportedDtDateLte, affectsFlawReportedDtGt, affectsFlawReportedDtGte, affectsFlawReportedDtLt, affectsFlawReportedDtLte, affectsFlawSource, affectsFlawUnembargoDt, affectsFlawUpdatedDt, affectsFlawUpdatedDtDate, affectsFlawUpdatedDtDateGte, affectsFlawUpdatedDtDateLte, affectsFlawUpdatedDtGt, affectsFlawUpdatedDtGte, affectsFlawUpdatedDtLt, affectsFlawUpdatedDtLte, affectsFlawUuid, affectsImpact, affectsPsComponent, affectsPsModule, affectsResolution, affectsUpdatedDt, affectsUpdatedDtDate, affectsUpdatedDtDateGte, affectsUpdatedDtDateLte, affectsUpdatedDtGt, affectsUpdatedDtGte, affectsUpdatedDtLt, affectsUpdatedDtLte, affectsUuid, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, embargoed, excludeFields, externalSystemId, includeFields, includeMetaAttr, limit, offset, order, psUpdateStream, resolution, status, type, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid A UUID string identifying this Tracker.
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1TrackersRetrieve(uuid: string, excludeFields?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1TrackersCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1TrackersRetrieve(uuid, excludeFields, includeFields, includeMetaAttr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {string} uuid A UUID string identifying this Tracker.
         * @param {Tracker} tracker 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbApiV1TrackersUpdate(bugzillaApiKey: string, jiraApiKey: string, uuid: string, tracker: Tracker, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbApiV1TrackersCreate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbApiV1TrackersUpdate(bugzillaApiKey, jiraApiKey, uuid, tracker, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * unauthenticated view providing healthcheck on osidb service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbHealthyRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200ResponseAllOf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbHealthyRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * View that provides information about the currently logged-in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osidbWhoamiRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsidbWhoamiRetrieve200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osidbWhoamiRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OsidbApi - factory interface
 * @export
 */
export const OsidbApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OsidbApiFp(configuration)
    return {
        /**
         * Bulk create endpoint. Expects a list of dict Affect objects.
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {Array<AffectPost>} affectPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsBulkCreate(bugzillaApiKey: string, affectPost: Array<AffectPost>, options?: any): AxiosPromise<OsidbApiV1AffectsBulkUpdate200Response> {
            return localVarFp.osidbApiV1AffectsBulkCreate(bugzillaApiKey, affectPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Bulk delete endpoint. Expects a list of Affect uuids.
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsBulkDestroy(bugzillaApiKey: string, options?: any): AxiosPromise<AuthTokenCreate200ResponseAllOf> {
            return localVarFp.osidbApiV1AffectsBulkDestroy(bugzillaApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Bulk update endpoint. Expects a list of dict Affect objects.
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {Array<AffectBulkPut>} affectBulkPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsBulkUpdate(bugzillaApiKey: string, jiraApiKey: string, affectBulkPut: Array<AffectBulkPut>, options?: any): AxiosPromise<OsidbApiV1AffectsBulkUpdate200Response> {
            return localVarFp.osidbApiV1AffectsBulkUpdate(bugzillaApiKey, jiraApiKey, affectBulkPut, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {AffectPost} affectPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsCreate(bugzillaApiKey: string, jiraApiKey: string, affectPost: AffectPost, options?: any): AxiosPromise<OsidbApiV1AffectsCreate201Response> {
            return localVarFp.osidbApiV1AffectsCreate(bugzillaApiKey, jiraApiKey, affectPost, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} affectId 
         * @param {AffectCVSSPost} affectCVSSPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsCvssScoresCreate(bugzillaApiKey: string, affectId: string, affectCVSSPost: AffectCVSSPost, options?: any): AxiosPromise<OsidbApiV1AffectsCvssScoresCreate201Response> {
            return localVarFp.osidbApiV1AffectsCvssScoresCreate(bugzillaApiKey, affectId, affectCVSSPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Destroy the instance and proxy the delete to Bugzilla.
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} affectId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsCvssScoresDestroy(bugzillaApiKey: string, affectId: string, id: string, options?: any): AxiosPromise<AuthTokenCreate200ResponseAllOf> {
            return localVarFp.osidbApiV1AffectsCvssScoresDestroy(bugzillaApiKey, affectId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} affectId 
         * @param {string} [comment] 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {string} [cvssVersion] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {'NIST' | 'OSV' | 'RH'} [issuer] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {number} [score] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {string} [vector] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsCvssScoresList(affectId: string, comment?: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, cvssVersion?: string, excludeFields?: Array<string>, includeFields?: Array<string>, issuer?: 'NIST' | 'OSV' | 'RH', limit?: number, offset?: number, score?: number, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, vector?: string, options?: any): AxiosPromise<OsidbApiV1AffectsCvssScoresList200Response> {
            return localVarFp.osidbApiV1AffectsCvssScoresList(affectId, comment, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, cvssVersion, excludeFields, includeFields, issuer, limit, offset, score, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, vector, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} affectId 
         * @param {string} id 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsCvssScoresRetrieve(affectId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, options?: any): AxiosPromise<OsidbApiV1AffectsCvssScoresCreate201Response> {
            return localVarFp.osidbApiV1AffectsCvssScoresRetrieve(affectId, id, excludeFields, includeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} affectId 
         * @param {string} id 
         * @param {AffectCVSSPut} affectCVSSPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsCvssScoresUpdate(bugzillaApiKey: string, affectId: string, id: string, affectCVSSPut: AffectCVSSPut, options?: any): AxiosPromise<OsidbApiV1AffectsCvssScoresCreate201Response> {
            return localVarFp.osidbApiV1AffectsCvssScoresUpdate(bugzillaApiKey, affectId, id, affectCVSSPut, options).then((request) => request(axios, basePath));
        },
        /**
         * Destroy the instance and proxy the delete to Bugzilla
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} uuid A UUID string identifying this Affect.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsDestroy(bugzillaApiKey: string, uuid: string, options?: any): AxiosPromise<AuthTokenCreate200ResponseAllOf> {
            return localVarFp.osidbApiV1AffectsDestroy(bugzillaApiKey, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {'' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED'} [affectedness] 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {string} [cvssScoresComment] 
         * @param {string} [cvssScoresCreatedDt] 
         * @param {string} [cvssScoresCreatedDtDate] 
         * @param {string} [cvssScoresCreatedDtDateGte] 
         * @param {string} [cvssScoresCreatedDtDateLte] 
         * @param {string} [cvssScoresCreatedDtGt] 
         * @param {string} [cvssScoresCreatedDtGte] 
         * @param {string} [cvssScoresCreatedDtLt] 
         * @param {string} [cvssScoresCreatedDtLte] 
         * @param {string} [cvssScoresCvssVersion] 
         * @param {'NIST' | 'OSV' | 'RH'} [cvssScoresIssuer] 
         * @param {number} [cvssScoresScore] 
         * @param {string} [cvssScoresUpdatedDt] 
         * @param {string} [cvssScoresUpdatedDtDate] 
         * @param {string} [cvssScoresUpdatedDtDateGte] 
         * @param {string} [cvssScoresUpdatedDtDateLte] 
         * @param {string} [cvssScoresUpdatedDtGt] 
         * @param {string} [cvssScoresUpdatedDtGte] 
         * @param {string} [cvssScoresUpdatedDtLt] 
         * @param {string} [cvssScoresUpdatedDtLte] 
         * @param {string} [cvssScoresUuid] 
         * @param {string} [cvssScoresVector] 
         * @param {boolean} [embargoed] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [flawComponents] Multiple values may be separated by commas.
         * @param {string} [flawCreatedDt] 
         * @param {string} [flawCreatedDtDate] 
         * @param {string} [flawCreatedDtDateGte] 
         * @param {string} [flawCreatedDtDateLte] 
         * @param {string} [flawCreatedDtGt] 
         * @param {string} [flawCreatedDtGte] 
         * @param {string} [flawCreatedDtLt] 
         * @param {string} [flawCreatedDtLte] 
         * @param {string} [flawCveId] 
         * @param {string} [flawCweId] 
         * @param {boolean} [flawEmbargoed] 
         * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [flawImpact] 
         * @param {string} [flawReportedDt] 
         * @param {string} [flawReportedDtDate] 
         * @param {string} [flawReportedDtDateGte] 
         * @param {string} [flawReportedDtDateLte] 
         * @param {string} [flawReportedDtGt] 
         * @param {string} [flawReportedDtGte] 
         * @param {string} [flawReportedDtLt] 
         * @param {string} [flawReportedDtLte] 
         * @param {'' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'NVD' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'OSV' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF'} [flawSource] 
         * @param {string} [flawUnembargoDt] 
         * @param {string} [flawUpdatedDt] 
         * @param {string} [flawUpdatedDtDate] 
         * @param {string} [flawUpdatedDtDateGte] 
         * @param {string} [flawUpdatedDtDateLte] 
         * @param {string} [flawUpdatedDtGt] 
         * @param {string} [flawUpdatedDtGte] 
         * @param {string} [flawUpdatedDtLt] 
         * @param {string} [flawUpdatedDtLte] 
         * @param {string} [flawUuid] 
         * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [impact] 
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {Array<'-affectedness' | '-created_dt' | '-cvss_scores__comment' | '-cvss_scores__created_dt' | '-cvss_scores__cvss_version' | '-cvss_scores__issuer' | '-cvss_scores__score' | '-cvss_scores__updated_dt' | '-cvss_scores__uuid' | '-cvss_scores__vector' | '-embargoed' | '-flaw__components' | '-flaw__created_dt' | '-flaw__cve_id' | '-flaw__cwe_id' | '-flaw__embargoed' | '-flaw__impact' | '-flaw__reported_dt' | '-flaw__source' | '-flaw__unembargo_dt' | '-flaw__updated_dt' | '-flaw__uuid' | '-impact' | '-ps_component' | '-ps_module' | '-resolution' | '-trackers__created_dt' | '-trackers__embargoed' | '-trackers__external_system_id' | '-trackers__ps_update_stream' | '-trackers__resolution' | '-trackers__status' | '-trackers__type' | '-trackers__updated_dt' | '-trackers__uuid' | '-updated_dt' | '-uuid' | 'affectedness' | 'created_dt' | 'cvss_scores__comment' | 'cvss_scores__created_dt' | 'cvss_scores__cvss_version' | 'cvss_scores__issuer' | 'cvss_scores__score' | 'cvss_scores__updated_dt' | 'cvss_scores__uuid' | 'cvss_scores__vector' | 'embargoed' | 'flaw__components' | 'flaw__created_dt' | 'flaw__cve_id' | 'flaw__cwe_id' | 'flaw__embargoed' | 'flaw__impact' | 'flaw__reported_dt' | 'flaw__source' | 'flaw__unembargo_dt' | 'flaw__updated_dt' | 'flaw__uuid' | 'impact' | 'ps_component' | 'ps_module' | 'resolution' | 'trackers__created_dt' | 'trackers__embargoed' | 'trackers__external_system_id' | 'trackers__ps_update_stream' | 'trackers__resolution' | 'trackers__status' | 'trackers__type' | 'trackers__updated_dt' | 'trackers__uuid' | 'updated_dt' | 'uuid'>} [order] Ordering
         * @param {string} [psComponent] 
         * @param {string} [psModule] 
         * @param {'' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT'} [resolution] 
         * @param {string} [trackersCreatedDt] 
         * @param {string} [trackersCreatedDtDate] 
         * @param {string} [trackersCreatedDtDateGte] 
         * @param {string} [trackersCreatedDtDateLte] 
         * @param {string} [trackersCreatedDtGt] 
         * @param {string} [trackersCreatedDtGte] 
         * @param {string} [trackersCreatedDtLt] 
         * @param {string} [trackersCreatedDtLte] 
         * @param {boolean} [trackersEmbargoed] 
         * @param {string} [trackersExternalSystemId] 
         * @param {string} [trackersPsUpdateStream] 
         * @param {string} [trackersResolution] 
         * @param {string} [trackersStatus] 
         * @param {'BUGZILLA' | 'JIRA'} [trackersType] 
         * @param {string} [trackersUpdatedDt] 
         * @param {string} [trackersUpdatedDtDate] 
         * @param {string} [trackersUpdatedDtDateGte] 
         * @param {string} [trackersUpdatedDtDateLte] 
         * @param {string} [trackersUpdatedDtGt] 
         * @param {string} [trackersUpdatedDtGte] 
         * @param {string} [trackersUpdatedDtLt] 
         * @param {string} [trackersUpdatedDtLte] 
         * @param {string} [trackersUuid] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsList(affectedness?: '' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED', createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, cvssScoresComment?: string, cvssScoresCreatedDt?: string, cvssScoresCreatedDtDate?: string, cvssScoresCreatedDtDateGte?: string, cvssScoresCreatedDtDateLte?: string, cvssScoresCreatedDtGt?: string, cvssScoresCreatedDtGte?: string, cvssScoresCreatedDtLt?: string, cvssScoresCreatedDtLte?: string, cvssScoresCvssVersion?: string, cvssScoresIssuer?: 'NIST' | 'OSV' | 'RH', cvssScoresScore?: number, cvssScoresUpdatedDt?: string, cvssScoresUpdatedDtDate?: string, cvssScoresUpdatedDtDateGte?: string, cvssScoresUpdatedDtDateLte?: string, cvssScoresUpdatedDtGt?: string, cvssScoresUpdatedDtGte?: string, cvssScoresUpdatedDtLt?: string, cvssScoresUpdatedDtLte?: string, cvssScoresUuid?: string, cvssScoresVector?: string, embargoed?: boolean, excludeFields?: Array<string>, flawComponents?: Array<string>, flawCreatedDt?: string, flawCreatedDtDate?: string, flawCreatedDtDateGte?: string, flawCreatedDtDateLte?: string, flawCreatedDtGt?: string, flawCreatedDtGte?: string, flawCreatedDtLt?: string, flawCreatedDtLte?: string, flawCveId?: string, flawCweId?: string, flawEmbargoed?: boolean, flawImpact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', flawReportedDt?: string, flawReportedDtDate?: string, flawReportedDtDateGte?: string, flawReportedDtDateLte?: string, flawReportedDtGt?: string, flawReportedDtGte?: string, flawReportedDtLt?: string, flawReportedDtLte?: string, flawSource?: '' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'NVD' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'OSV' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF', flawUnembargoDt?: string, flawUpdatedDt?: string, flawUpdatedDtDate?: string, flawUpdatedDtDateGte?: string, flawUpdatedDtDateLte?: string, flawUpdatedDtGt?: string, flawUpdatedDtGte?: string, flawUpdatedDtLt?: string, flawUpdatedDtLte?: string, flawUuid?: string, impact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', includeFields?: Array<string>, includeMetaAttr?: Array<string>, limit?: number, offset?: number, order?: Array<'-affectedness' | '-created_dt' | '-cvss_scores__comment' | '-cvss_scores__created_dt' | '-cvss_scores__cvss_version' | '-cvss_scores__issuer' | '-cvss_scores__score' | '-cvss_scores__updated_dt' | '-cvss_scores__uuid' | '-cvss_scores__vector' | '-embargoed' | '-flaw__components' | '-flaw__created_dt' | '-flaw__cve_id' | '-flaw__cwe_id' | '-flaw__embargoed' | '-flaw__impact' | '-flaw__reported_dt' | '-flaw__source' | '-flaw__unembargo_dt' | '-flaw__updated_dt' | '-flaw__uuid' | '-impact' | '-ps_component' | '-ps_module' | '-resolution' | '-trackers__created_dt' | '-trackers__embargoed' | '-trackers__external_system_id' | '-trackers__ps_update_stream' | '-trackers__resolution' | '-trackers__status' | '-trackers__type' | '-trackers__updated_dt' | '-trackers__uuid' | '-updated_dt' | '-uuid' | 'affectedness' | 'created_dt' | 'cvss_scores__comment' | 'cvss_scores__created_dt' | 'cvss_scores__cvss_version' | 'cvss_scores__issuer' | 'cvss_scores__score' | 'cvss_scores__updated_dt' | 'cvss_scores__uuid' | 'cvss_scores__vector' | 'embargoed' | 'flaw__components' | 'flaw__created_dt' | 'flaw__cve_id' | 'flaw__cwe_id' | 'flaw__embargoed' | 'flaw__impact' | 'flaw__reported_dt' | 'flaw__source' | 'flaw__unembargo_dt' | 'flaw__updated_dt' | 'flaw__uuid' | 'impact' | 'ps_component' | 'ps_module' | 'resolution' | 'trackers__created_dt' | 'trackers__embargoed' | 'trackers__external_system_id' | 'trackers__ps_update_stream' | 'trackers__resolution' | 'trackers__status' | 'trackers__type' | 'trackers__updated_dt' | 'trackers__uuid' | 'updated_dt' | 'uuid'>, psComponent?: string, psModule?: string, resolution?: '' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT', trackersCreatedDt?: string, trackersCreatedDtDate?: string, trackersCreatedDtDateGte?: string, trackersCreatedDtDateLte?: string, trackersCreatedDtGt?: string, trackersCreatedDtGte?: string, trackersCreatedDtLt?: string, trackersCreatedDtLte?: string, trackersEmbargoed?: boolean, trackersExternalSystemId?: string, trackersPsUpdateStream?: string, trackersResolution?: string, trackersStatus?: string, trackersType?: 'BUGZILLA' | 'JIRA', trackersUpdatedDt?: string, trackersUpdatedDtDate?: string, trackersUpdatedDtDateGte?: string, trackersUpdatedDtDateLte?: string, trackersUpdatedDtGt?: string, trackersUpdatedDtGte?: string, trackersUpdatedDtLt?: string, trackersUpdatedDtLte?: string, trackersUuid?: string, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, options?: any): AxiosPromise<OsidbApiV1AffectsList200Response> {
            return localVarFp.osidbApiV1AffectsList(affectedness, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, cvssScoresComment, cvssScoresCreatedDt, cvssScoresCreatedDtDate, cvssScoresCreatedDtDateGte, cvssScoresCreatedDtDateLte, cvssScoresCreatedDtGt, cvssScoresCreatedDtGte, cvssScoresCreatedDtLt, cvssScoresCreatedDtLte, cvssScoresCvssVersion, cvssScoresIssuer, cvssScoresScore, cvssScoresUpdatedDt, cvssScoresUpdatedDtDate, cvssScoresUpdatedDtDateGte, cvssScoresUpdatedDtDateLte, cvssScoresUpdatedDtGt, cvssScoresUpdatedDtGte, cvssScoresUpdatedDtLt, cvssScoresUpdatedDtLte, cvssScoresUuid, cvssScoresVector, embargoed, excludeFields, flawComponents, flawCreatedDt, flawCreatedDtDate, flawCreatedDtDateGte, flawCreatedDtDateLte, flawCreatedDtGt, flawCreatedDtGte, flawCreatedDtLt, flawCreatedDtLte, flawCveId, flawCweId, flawEmbargoed, flawImpact, flawReportedDt, flawReportedDtDate, flawReportedDtDateGte, flawReportedDtDateLte, flawReportedDtGt, flawReportedDtGte, flawReportedDtLt, flawReportedDtLte, flawSource, flawUnembargoDt, flawUpdatedDt, flawUpdatedDtDate, flawUpdatedDtDateGte, flawUpdatedDtDateLte, flawUpdatedDtGt, flawUpdatedDtGte, flawUpdatedDtLt, flawUpdatedDtLte, flawUuid, impact, includeFields, includeMetaAttr, limit, offset, order, psComponent, psModule, resolution, trackersCreatedDt, trackersCreatedDtDate, trackersCreatedDtDateGte, trackersCreatedDtDateLte, trackersCreatedDtGt, trackersCreatedDtGte, trackersCreatedDtLt, trackersCreatedDtLte, trackersEmbargoed, trackersExternalSystemId, trackersPsUpdateStream, trackersResolution, trackersStatus, trackersType, trackersUpdatedDt, trackersUpdatedDtDate, trackersUpdatedDtDateGte, trackersUpdatedDtDateLte, trackersUpdatedDtGt, trackersUpdatedDtGte, trackersUpdatedDtLt, trackersUpdatedDtLte, trackersUuid, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid A UUID string identifying this Affect.
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsRetrieve(uuid: string, excludeFields?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, options?: any): AxiosPromise<OsidbApiV1AffectsCreate201Response> {
            return localVarFp.osidbApiV1AffectsRetrieve(uuid, excludeFields, includeFields, includeMetaAttr, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {string} uuid A UUID string identifying this Affect.
         * @param {Affect} affect 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AffectsUpdate(bugzillaApiKey: string, jiraApiKey: string, uuid: string, affect: Affect, options?: any): AxiosPromise<OsidbApiV1AffectsCreate201Response> {
            return localVarFp.osidbApiV1AffectsUpdate(bugzillaApiKey, jiraApiKey, uuid, affect, options).then((request) => request(axios, basePath));
        },
        /**
         * List existing alerts for all models.
         * @param {'ERROR' | 'WARNING'} [alertType] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] Retrieve only Alerts with the specified name, which is given by the model\&#39;s validation process.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {'affect' | 'affectcvss' | 'flaw' | 'flawacknowledgment' | 'flawcomment' | 'flawcvss' | 'flawreference' | 'package' | 'snippet' | 'tracker'} [parentModel] Retrieve only Alerts related to the specified model, e.g. flaw or affect.
         * @param {string} [parentUuid] Retrieve only Alerts related to a model with the given UUID.
         * @param {string} [uuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AlertsList(alertType?: 'ERROR' | 'WARNING', excludeFields?: Array<string>, includeFields?: Array<string>, limit?: number, name?: string, offset?: number, parentModel?: 'affect' | 'affectcvss' | 'flaw' | 'flawacknowledgment' | 'flawcomment' | 'flawcvss' | 'flawreference' | 'package' | 'snippet' | 'tracker', parentUuid?: string, uuid?: string, options?: any): AxiosPromise<OsidbApiV1AlertsList200Response> {
            return localVarFp.osidbApiV1AlertsList(alertType, excludeFields, includeFields, limit, name, offset, parentModel, parentUuid, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid A UUID string identifying this alert.
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AlertsRetrieve(uuid: string, excludeFields?: Array<string>, includeFields?: Array<string>, options?: any): AxiosPromise<OsidbApiV1AlertsRetrieve200Response> {
            return localVarFp.osidbApiV1AlertsRetrieve(uuid, excludeFields, includeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * basic view of audit history events
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [pghCreatedAt] 
         * @param {string} [pghLabel] 
         * @param {string} [pghObjModel] 
         * @param {string} [pghSlug] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AuditList(limit?: number, offset?: number, pghCreatedAt?: string, pghLabel?: string, pghObjModel?: string, pghSlug?: string, options?: any): AxiosPromise<OsidbApiV1AuditList200Response> {
            return localVarFp.osidbApiV1AuditList(limit, offset, pghCreatedAt, pghLabel, pghObjModel, pghSlug, options).then((request) => request(axios, basePath));
        },
        /**
         * basic view of audit history events
         * @param {string} pghSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AuditRetrieve(pghSlug: string, options?: any): AxiosPromise<OsidbApiV1AuditRetrieve200Response> {
            return localVarFp.osidbApiV1AuditRetrieve(pghSlug, options).then((request) => request(axios, basePath));
        },
        /**
         * basic view of audit history events
         * @param {string} pghSlug 
         * @param {Audit} audit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1AuditUpdate(pghSlug: string, audit: Audit, options?: any): AxiosPromise<OsidbApiV1AuditRetrieve200Response> {
            return localVarFp.osidbApiV1AuditUpdate(pghSlug, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId 
         * @param {FlawAcknowledgmentPost} flawAcknowledgmentPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsAcknowledgmentsCreate(bugzillaApiKey: string, flawId: string, flawAcknowledgmentPost: FlawAcknowledgmentPost, options?: any): AxiosPromise<OsidbApiV1FlawsAcknowledgmentsCreate201Response> {
            return localVarFp.osidbApiV1FlawsAcknowledgmentsCreate(bugzillaApiKey, flawId, flawAcknowledgmentPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Destroy the instance and proxy the delete to Bugzilla
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsAcknowledgmentsDestroy(bugzillaApiKey: string, flawId: string, id: string, options?: any): AxiosPromise<AuthTokenCreate200ResponseAllOf> {
            return localVarFp.osidbApiV1FlawsAcknowledgmentsDestroy(bugzillaApiKey, flawId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} [affiliation] 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {boolean} [fromUpstream] 
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsAcknowledgmentsList(flawId: string, affiliation?: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, excludeFields?: Array<string>, fromUpstream?: boolean, includeFields?: Array<string>, limit?: number, name?: string, offset?: number, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, options?: any): AxiosPromise<OsidbApiV1FlawsAcknowledgmentsList200Response> {
            return localVarFp.osidbApiV1FlawsAcknowledgmentsList(flawId, affiliation, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, excludeFields, fromUpstream, includeFields, limit, name, offset, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} id 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsAcknowledgmentsRetrieve(flawId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, options?: any): AxiosPromise<OsidbApiV1FlawsAcknowledgmentsCreate201Response> {
            return localVarFp.osidbApiV1FlawsAcknowledgmentsRetrieve(flawId, id, excludeFields, includeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId 
         * @param {string} id 
         * @param {FlawAcknowledgmentPut} flawAcknowledgmentPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsAcknowledgmentsUpdate(bugzillaApiKey: string, flawId: string, id: string, flawAcknowledgmentPut: FlawAcknowledgmentPut, options?: any): AxiosPromise<OsidbApiV1FlawsAcknowledgmentsCreate201Response> {
            return localVarFp.osidbApiV1FlawsAcknowledgmentsUpdate(bugzillaApiKey, flawId, id, flawAcknowledgmentPut, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new comment for a given flaw. Beware that freshly created comments are not guaranteed to keep their original UUIDs, especially if multiple comments are created simultaneously.
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
         * @param {FlawCommentPost} flawCommentPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsCommentsCreate(bugzillaApiKey: string, flawId: string, flawCommentPost: FlawCommentPost, options?: any): AxiosPromise<OsidbApiV1FlawsCommentsCreate201Response> {
            return localVarFp.osidbApiV1FlawsCommentsCreate(bugzillaApiKey, flawId, flawCommentPost, options).then((request) => request(axios, basePath));
        },
        /**
         * List existing comments for a given flaw. Beware that freshly created comments are not guaranteed to keep their original UUIDs, especially if multiple comments are created simultaneously.
         * @param {string} flawId A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
         * @param {string} [creator] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {string} [externalSystemId] 
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {number} [order] Retrieve only FlawComment resource with the specified order number. Regular flaw comments are numbered from 1 up.
         * @param {string} [uuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsCommentsList(flawId: string, creator?: string, excludeFields?: Array<string>, externalSystemId?: string, includeFields?: Array<string>, limit?: number, offset?: number, order?: number, uuid?: string, options?: any): AxiosPromise<OsidbApiV1FlawsCommentsList200Response> {
            return localVarFp.osidbApiV1FlawsCommentsList(flawId, creator, excludeFields, externalSystemId, includeFields, limit, offset, order, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single existing comments for a given flaw. Beware that freshly created comments are not guaranteed to keep their original UUIDs, especially if multiple comments are created simultaneously.
         * @param {string} commentId A string representing the internal OSIDB UUID of the FlawComment resource.
         * @param {string} flawId A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsCommentsRetrieve(commentId: string, flawId: string, excludeFields?: Array<string>, includeFields?: Array<string>, options?: any): AxiosPromise<OsidbApiV1FlawsCommentsCreate201Response> {
            return localVarFp.osidbApiV1FlawsCommentsRetrieve(commentId, flawId, excludeFields, includeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {FlawPost} flawPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsCreate(bugzillaApiKey: string, jiraApiKey: string, flawPost: FlawPost, options?: any): AxiosPromise<OsidbApiV1FlawsCreate201Response> {
            return localVarFp.osidbApiV1FlawsCreate(bugzillaApiKey, jiraApiKey, flawPost, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId 
         * @param {FlawCVSSPost} flawCVSSPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsCvssScoresCreate(bugzillaApiKey: string, flawId: string, flawCVSSPost: FlawCVSSPost, options?: any): AxiosPromise<OsidbApiV1FlawsCvssScoresCreate201Response> {
            return localVarFp.osidbApiV1FlawsCvssScoresCreate(bugzillaApiKey, flawId, flawCVSSPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Destroy the instance and proxy the delete to Bugzilla
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsCvssScoresDestroy(bugzillaApiKey: string, flawId: string, id: string, options?: any): AxiosPromise<AuthTokenCreate200ResponseAllOf> {
            return localVarFp.osidbApiV1FlawsCvssScoresDestroy(bugzillaApiKey, flawId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} [comment] 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {string} [cvssVersion] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {'NIST' | 'OSV' | 'RH'} [issuer] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {number} [score] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {string} [vector] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsCvssScoresList(flawId: string, comment?: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, cvssVersion?: string, excludeFields?: Array<string>, includeFields?: Array<string>, issuer?: 'NIST' | 'OSV' | 'RH', limit?: number, offset?: number, score?: number, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, vector?: string, options?: any): AxiosPromise<OsidbApiV1FlawsCvssScoresList200Response> {
            return localVarFp.osidbApiV1FlawsCvssScoresList(flawId, comment, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, cvssVersion, excludeFields, includeFields, issuer, limit, offset, score, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, vector, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} id 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsCvssScoresRetrieve(flawId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, options?: any): AxiosPromise<OsidbApiV1FlawsCvssScoresCreate201Response> {
            return localVarFp.osidbApiV1FlawsCvssScoresRetrieve(flawId, id, excludeFields, includeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId 
         * @param {string} id 
         * @param {FlawCVSSPut} flawCVSSPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsCvssScoresUpdate(bugzillaApiKey: string, flawId: string, id: string, flawCVSSPut: FlawCVSSPut, options?: any): AxiosPromise<OsidbApiV1FlawsCvssScoresCreate201Response> {
            return localVarFp.osidbApiV1FlawsCvssScoresUpdate(bugzillaApiKey, flawId, id, flawCVSSPut, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [acknowledgmentsAffiliation] 
         * @param {string} [acknowledgmentsCreatedDt] 
         * @param {string} [acknowledgmentsCreatedDtDate] 
         * @param {string} [acknowledgmentsCreatedDtDateGte] 
         * @param {string} [acknowledgmentsCreatedDtDateLte] 
         * @param {string} [acknowledgmentsCreatedDtGt] 
         * @param {string} [acknowledgmentsCreatedDtGte] 
         * @param {string} [acknowledgmentsCreatedDtLt] 
         * @param {string} [acknowledgmentsCreatedDtLte] 
         * @param {boolean} [acknowledgmentsFromUpstream] 
         * @param {string} [acknowledgmentsName] 
         * @param {string} [acknowledgmentsUpdatedDt] 
         * @param {string} [acknowledgmentsUpdatedDtDate] 
         * @param {string} [acknowledgmentsUpdatedDtDateGte] 
         * @param {string} [acknowledgmentsUpdatedDtDateLte] 
         * @param {string} [acknowledgmentsUpdatedDtGt] 
         * @param {string} [acknowledgmentsUpdatedDtGte] 
         * @param {string} [acknowledgmentsUpdatedDtLt] 
         * @param {string} [acknowledgmentsUpdatedDtLte] 
         * @param {string} [acknowledgmentsUuid] 
         * @param {'' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED'} [affectsAffectedness] 
         * @param {string} [affectsCreatedDt] 
         * @param {string} [affectsCreatedDtDate] 
         * @param {string} [affectsCreatedDtDateGte] 
         * @param {string} [affectsCreatedDtDateLte] 
         * @param {string} [affectsCreatedDtGt] 
         * @param {string} [affectsCreatedDtGte] 
         * @param {string} [affectsCreatedDtLt] 
         * @param {string} [affectsCreatedDtLte] 
         * @param {boolean} [affectsEmbargoed] 
         * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [affectsImpact] 
         * @param {string} [affectsPsComponent] 
         * @param {string} [affectsPsModule] 
         * @param {'' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT'} [affectsResolution] 
         * @param {string} [affectsTrackersCreatedDt] 
         * @param {string} [affectsTrackersCreatedDtDate] 
         * @param {string} [affectsTrackersCreatedDtDateGte] 
         * @param {string} [affectsTrackersCreatedDtDateLte] 
         * @param {string} [affectsTrackersCreatedDtGt] 
         * @param {string} [affectsTrackersCreatedDtGte] 
         * @param {string} [affectsTrackersCreatedDtLt] 
         * @param {string} [affectsTrackersCreatedDtLte] 
         * @param {boolean} [affectsTrackersEmbargoed] 
         * @param {string} [affectsTrackersErrataAdvisoryName] 
         * @param {number} [affectsTrackersErrataEtId] 
         * @param {string} [affectsTrackersErrataShippedDt] 
         * @param {string} [affectsTrackersErrataShippedDtDate] 
         * @param {string} [affectsTrackersErrataShippedDtDateGte] 
         * @param {string} [affectsTrackersErrataShippedDtDateLte] 
         * @param {string} [affectsTrackersErrataShippedDtGt] 
         * @param {string} [affectsTrackersErrataShippedDtGte] 
         * @param {string} [affectsTrackersErrataShippedDtLt] 
         * @param {string} [affectsTrackersErrataShippedDtLte] 
         * @param {string} [affectsTrackersExternalSystemId] 
         * @param {string} [affectsTrackersPsUpdateStream] 
         * @param {string} [affectsTrackersResolution] 
         * @param {string} [affectsTrackersStatus] 
         * @param {'BUGZILLA' | 'JIRA'} [affectsTrackersType] 
         * @param {string} [affectsTrackersUpdatedDt] 
         * @param {string} [affectsTrackersUpdatedDtDate] 
         * @param {string} [affectsTrackersUpdatedDtDateGte] 
         * @param {string} [affectsTrackersUpdatedDtDateLte] 
         * @param {string} [affectsTrackersUpdatedDtGt] 
         * @param {string} [affectsTrackersUpdatedDtGte] 
         * @param {string} [affectsTrackersUpdatedDtLt] 
         * @param {string} [affectsTrackersUpdatedDtLte] 
         * @param {string} [affectsTrackersUuid] 
         * @param {string} [affectsUpdatedDt] 
         * @param {string} [affectsUpdatedDtDate] 
         * @param {string} [affectsUpdatedDtDateGte] 
         * @param {string} [affectsUpdatedDtDateLte] 
         * @param {string} [affectsUpdatedDtGt] 
         * @param {string} [affectsUpdatedDtGte] 
         * @param {string} [affectsUpdatedDtLt] 
         * @param {string} [affectsUpdatedDtLte] 
         * @param {string} [affectsUuid] 
         * @param {number} [bzId] 
         * @param {string} [changedAfter] 
         * @param {string} [changedBefore] 
         * @param {string} [commentZero] 
         * @param {Array<string>} [components] Multiple values may be separated by commas.
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {string} [cveDescription] 
         * @param {boolean} [cveDescriptionIsempty] 
         * @param {Array<string>} [cveId] Multiple values may be separated by commas.
         * @param {boolean} [cveIdIsempty] 
         * @param {boolean} [cvss2NistIsempty] 
         * @param {boolean} [cvss2RhIsempty] 
         * @param {boolean} [cvss3NistIsempty] 
         * @param {boolean} [cvss3RhIsempty] 
         * @param {boolean} [cvss4NistIsempty] 
         * @param {boolean} [cvss4RhIsempty] 
         * @param {string} [cvssScoresComment] 
         * @param {string} [cvssScoresCreatedDt] 
         * @param {string} [cvssScoresCreatedDtDate] 
         * @param {string} [cvssScoresCreatedDtDateGte] 
         * @param {string} [cvssScoresCreatedDtDateLte] 
         * @param {string} [cvssScoresCreatedDtGt] 
         * @param {string} [cvssScoresCreatedDtGte] 
         * @param {string} [cvssScoresCreatedDtLt] 
         * @param {string} [cvssScoresCreatedDtLte] 
         * @param {string} [cvssScoresCvssVersion] 
         * @param {'NIST' | 'OSV' | 'RH'} [cvssScoresIssuer] 
         * @param {number} [cvssScoresScore] 
         * @param {string} [cvssScoresUpdatedDt] 
         * @param {string} [cvssScoresUpdatedDtDate] 
         * @param {string} [cvssScoresUpdatedDtDateGte] 
         * @param {string} [cvssScoresUpdatedDtDateLte] 
         * @param {string} [cvssScoresUpdatedDtGt] 
         * @param {string} [cvssScoresUpdatedDtGte] 
         * @param {string} [cvssScoresUpdatedDtLt] 
         * @param {string} [cvssScoresUpdatedDtLte] 
         * @param {string} [cvssScoresUuid] 
         * @param {string} [cvssScoresVector] 
         * @param {string} [cweId] 
         * @param {boolean} [cweIdIsempty] 
         * @param {boolean} [embargoed] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [impact] 
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [majorIncidentStartDt] 
         * @param {string} [majorIncidentStartDtDate] 
         * @param {string} [majorIncidentStartDtDateGte] 
         * @param {string} [majorIncidentStartDtDateLte] 
         * @param {string} [majorIncidentStartDtGt] 
         * @param {string} [majorIncidentStartDtGte] 
         * @param {string} [majorIncidentStartDtLt] 
         * @param {string} [majorIncidentStartDtLte] 
         * @param {'' | 'APPROVED' | 'CISA_APPROVED' | 'INVALID' | 'REJECTED' | 'REQUESTED'} [majorIncidentState] 
         * @param {boolean} [mitigationIsempty] 
         * @param {'' | 'APPROVED' | 'REJECTED' | 'REQUESTED'} [nistCvssValidation] 
         * @param {number} [offset] The initial index from which to return the results.
         * @param {Array<'-acknowledgments__affiliation' | '-acknowledgments__created_dt' | '-acknowledgments__from_upstream' | '-acknowledgments__name' | '-acknowledgments__updated_dt' | '-acknowledgments__uuid' | '-affects__affectedness' | '-affects__created_dt' | '-affects__impact' | '-affects__ps_component' | '-affects__ps_module' | '-affects__resolution' | '-affects__trackers__created_dt' | '-affects__trackers__errata__advisory_name' | '-affects__trackers__errata__et_id' | '-affects__trackers__errata__shipped_dt' | '-affects__trackers__external_system_id' | '-affects__trackers__ps_update_stream' | '-affects__trackers__resolution' | '-affects__trackers__status' | '-affects__trackers__type' | '-affects__trackers__updated_dt' | '-affects__trackers__uuid' | '-affects__updated_dt' | '-affects__uuid' | '-bz_id' | '-comment_zero' | '-components' | '-created_dt' | '-cve_description' | '-cve_id' | '-cvss_scores__comment' | '-cvss_scores__created_dt' | '-cvss_scores__issuer' | '-cvss_scores__score' | '-cvss_scores__updated_dt' | '-cvss_scores__uuid' | '-cvss_scores__vector' | '-cwe_id' | '-embargoed' | '-impact' | '-major_incident_start_dt' | '-major_incident_state' | '-nist_cvss_validation' | '-owner' | '-references__created_dt' | '-references__description' | '-references__type' | '-references__updated_dt' | '-references__url' | '-references__uuid' | '-reported_dt' | '-requires_cve_description' | '-source' | '-statement' | '-team_id' | '-title' | '-unembargo_dt' | '-updated_dt' | '-uuid' | '-workflow_state' | 'acknowledgments__affiliation' | 'acknowledgments__created_dt' | 'acknowledgments__from_upstream' | 'acknowledgments__name' | 'acknowledgments__updated_dt' | 'acknowledgments__uuid' | 'affects__affectedness' | 'affects__created_dt' | 'affects__impact' | 'affects__ps_component' | 'affects__ps_module' | 'affects__resolution' | 'affects__trackers__created_dt' | 'affects__trackers__errata__advisory_name' | 'affects__trackers__errata__et_id' | 'affects__trackers__errata__shipped_dt' | 'affects__trackers__external_system_id' | 'affects__trackers__ps_update_stream' | 'affects__trackers__resolution' | 'affects__trackers__status' | 'affects__trackers__type' | 'affects__trackers__updated_dt' | 'affects__trackers__uuid' | 'affects__updated_dt' | 'affects__uuid' | 'bz_id' | 'comment_zero' | 'components' | 'created_dt' | 'cve_description' | 'cve_id' | 'cvss_scores__comment' | 'cvss_scores__created_dt' | 'cvss_scores__issuer' | 'cvss_scores__score' | 'cvss_scores__updated_dt' | 'cvss_scores__uuid' | 'cvss_scores__vector' | 'cwe_id' | 'embargoed' | 'impact' | 'major_incident_start_dt' | 'major_incident_state' | 'nist_cvss_validation' | 'owner' | 'references__created_dt' | 'references__description' | 'references__type' | 'references__updated_dt' | 'references__url' | 'references__uuid' | 'reported_dt' | 'requires_cve_description' | 'source' | 'statement' | 'team_id' | 'title' | 'unembargo_dt' | 'updated_dt' | 'uuid' | 'workflow_state'>} [order] Ordering
         * @param {string} [owner] 
         * @param {boolean} [ownerIsempty] 
         * @param {string} [referencesCreatedDt] 
         * @param {string} [referencesCreatedDtDate] 
         * @param {string} [referencesCreatedDtDateGte] 
         * @param {string} [referencesCreatedDtDateLte] 
         * @param {string} [referencesCreatedDtGt] 
         * @param {string} [referencesCreatedDtGte] 
         * @param {string} [referencesCreatedDtLt] 
         * @param {string} [referencesCreatedDtLte] 
         * @param {string} [referencesDescription] 
         * @param {'ARTICLE' | 'EXTERNAL' | 'SOURCE'} [referencesType] 
         * @param {string} [referencesUpdatedDt] 
         * @param {string} [referencesUpdatedDtDate] 
         * @param {string} [referencesUpdatedDtDateGte] 
         * @param {string} [referencesUpdatedDtDateLte] 
         * @param {string} [referencesUpdatedDtGt] 
         * @param {string} [referencesUpdatedDtGte] 
         * @param {string} [referencesUpdatedDtLt] 
         * @param {string} [referencesUpdatedDtLte] 
         * @param {string} [referencesUrl] 
         * @param {string} [referencesUuid] 
         * @param {string} [reportedDt] 
         * @param {string} [reportedDtDate] 
         * @param {string} [reportedDtDateGte] 
         * @param {string} [reportedDtDateLte] 
         * @param {string} [reportedDtGt] 
         * @param {string} [reportedDtGte] 
         * @param {string} [reportedDtLt] 
         * @param {string} [reportedDtLte] 
         * @param {'' | 'APPROVED' | 'REJECTED' | 'REQUESTED'} [requiresCveDescription] 
         * @param {string} [search] 
         * @param {'' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'NVD' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'OSV' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF'} [source] 
         * @param {string} [statement] 
         * @param {boolean} [statementIsempty] 
         * @param {string} [teamId] 
         * @param {string} [title] 
         * @param {Array<string>} [trackerIds] Filter only Flaws which are related to specified Trackers (through Affects). Multiple tracker IDs may be separated by commas. Also only Affects that have the specified Trackers related will be shown.
         * @param {string} [unembargoDt] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {Array<'' | 'DONE' | 'NEW' | 'PRE_SECONDARY_ASSESSMENT' | 'REJECTED' | 'SECONDARY_ASSESSMENT' | 'TRIAGE'>} [workflowState] Multiple values may be separated by commas.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsList(acknowledgmentsAffiliation?: string, acknowledgmentsCreatedDt?: string, acknowledgmentsCreatedDtDate?: string, acknowledgmentsCreatedDtDateGte?: string, acknowledgmentsCreatedDtDateLte?: string, acknowledgmentsCreatedDtGt?: string, acknowledgmentsCreatedDtGte?: string, acknowledgmentsCreatedDtLt?: string, acknowledgmentsCreatedDtLte?: string, acknowledgmentsFromUpstream?: boolean, acknowledgmentsName?: string, acknowledgmentsUpdatedDt?: string, acknowledgmentsUpdatedDtDate?: string, acknowledgmentsUpdatedDtDateGte?: string, acknowledgmentsUpdatedDtDateLte?: string, acknowledgmentsUpdatedDtGt?: string, acknowledgmentsUpdatedDtGte?: string, acknowledgmentsUpdatedDtLt?: string, acknowledgmentsUpdatedDtLte?: string, acknowledgmentsUuid?: string, affectsAffectedness?: '' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED', affectsCreatedDt?: string, affectsCreatedDtDate?: string, affectsCreatedDtDateGte?: string, affectsCreatedDtDateLte?: string, affectsCreatedDtGt?: string, affectsCreatedDtGte?: string, affectsCreatedDtLt?: string, affectsCreatedDtLte?: string, affectsEmbargoed?: boolean, affectsImpact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', affectsPsComponent?: string, affectsPsModule?: string, affectsResolution?: '' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT', affectsTrackersCreatedDt?: string, affectsTrackersCreatedDtDate?: string, affectsTrackersCreatedDtDateGte?: string, affectsTrackersCreatedDtDateLte?: string, affectsTrackersCreatedDtGt?: string, affectsTrackersCreatedDtGte?: string, affectsTrackersCreatedDtLt?: string, affectsTrackersCreatedDtLte?: string, affectsTrackersEmbargoed?: boolean, affectsTrackersErrataAdvisoryName?: string, affectsTrackersErrataEtId?: number, affectsTrackersErrataShippedDt?: string, affectsTrackersErrataShippedDtDate?: string, affectsTrackersErrataShippedDtDateGte?: string, affectsTrackersErrataShippedDtDateLte?: string, affectsTrackersErrataShippedDtGt?: string, affectsTrackersErrataShippedDtGte?: string, affectsTrackersErrataShippedDtLt?: string, affectsTrackersErrataShippedDtLte?: string, affectsTrackersExternalSystemId?: string, affectsTrackersPsUpdateStream?: string, affectsTrackersResolution?: string, affectsTrackersStatus?: string, affectsTrackersType?: 'BUGZILLA' | 'JIRA', affectsTrackersUpdatedDt?: string, affectsTrackersUpdatedDtDate?: string, affectsTrackersUpdatedDtDateGte?: string, affectsTrackersUpdatedDtDateLte?: string, affectsTrackersUpdatedDtGt?: string, affectsTrackersUpdatedDtGte?: string, affectsTrackersUpdatedDtLt?: string, affectsTrackersUpdatedDtLte?: string, affectsTrackersUuid?: string, affectsUpdatedDt?: string, affectsUpdatedDtDate?: string, affectsUpdatedDtDateGte?: string, affectsUpdatedDtDateLte?: string, affectsUpdatedDtGt?: string, affectsUpdatedDtGte?: string, affectsUpdatedDtLt?: string, affectsUpdatedDtLte?: string, affectsUuid?: string, bzId?: number, changedAfter?: string, changedBefore?: string, commentZero?: string, components?: Array<string>, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, cveDescription?: string, cveDescriptionIsempty?: boolean, cveId?: Array<string>, cveIdIsempty?: boolean, cvss2NistIsempty?: boolean, cvss2RhIsempty?: boolean, cvss3NistIsempty?: boolean, cvss3RhIsempty?: boolean, cvss4NistIsempty?: boolean, cvss4RhIsempty?: boolean, cvssScoresComment?: string, cvssScoresCreatedDt?: string, cvssScoresCreatedDtDate?: string, cvssScoresCreatedDtDateGte?: string, cvssScoresCreatedDtDateLte?: string, cvssScoresCreatedDtGt?: string, cvssScoresCreatedDtGte?: string, cvssScoresCreatedDtLt?: string, cvssScoresCreatedDtLte?: string, cvssScoresCvssVersion?: string, cvssScoresIssuer?: 'NIST' | 'OSV' | 'RH', cvssScoresScore?: number, cvssScoresUpdatedDt?: string, cvssScoresUpdatedDtDate?: string, cvssScoresUpdatedDtDateGte?: string, cvssScoresUpdatedDtDateLte?: string, cvssScoresUpdatedDtGt?: string, cvssScoresUpdatedDtGte?: string, cvssScoresUpdatedDtLt?: string, cvssScoresUpdatedDtLte?: string, cvssScoresUuid?: string, cvssScoresVector?: string, cweId?: string, cweIdIsempty?: boolean, embargoed?: boolean, excludeFields?: Array<string>, impact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', includeFields?: Array<string>, includeMetaAttr?: Array<string>, limit?: number, majorIncidentStartDt?: string, majorIncidentStartDtDate?: string, majorIncidentStartDtDateGte?: string, majorIncidentStartDtDateLte?: string, majorIncidentStartDtGt?: string, majorIncidentStartDtGte?: string, majorIncidentStartDtLt?: string, majorIncidentStartDtLte?: string, majorIncidentState?: '' | 'APPROVED' | 'CISA_APPROVED' | 'INVALID' | 'REJECTED' | 'REQUESTED', mitigationIsempty?: boolean, nistCvssValidation?: '' | 'APPROVED' | 'REJECTED' | 'REQUESTED', offset?: number, order?: Array<'-acknowledgments__affiliation' | '-acknowledgments__created_dt' | '-acknowledgments__from_upstream' | '-acknowledgments__name' | '-acknowledgments__updated_dt' | '-acknowledgments__uuid' | '-affects__affectedness' | '-affects__created_dt' | '-affects__impact' | '-affects__ps_component' | '-affects__ps_module' | '-affects__resolution' | '-affects__trackers__created_dt' | '-affects__trackers__errata__advisory_name' | '-affects__trackers__errata__et_id' | '-affects__trackers__errata__shipped_dt' | '-affects__trackers__external_system_id' | '-affects__trackers__ps_update_stream' | '-affects__trackers__resolution' | '-affects__trackers__status' | '-affects__trackers__type' | '-affects__trackers__updated_dt' | '-affects__trackers__uuid' | '-affects__updated_dt' | '-affects__uuid' | '-bz_id' | '-comment_zero' | '-components' | '-created_dt' | '-cve_description' | '-cve_id' | '-cvss_scores__comment' | '-cvss_scores__created_dt' | '-cvss_scores__issuer' | '-cvss_scores__score' | '-cvss_scores__updated_dt' | '-cvss_scores__uuid' | '-cvss_scores__vector' | '-cwe_id' | '-embargoed' | '-impact' | '-major_incident_start_dt' | '-major_incident_state' | '-nist_cvss_validation' | '-owner' | '-references__created_dt' | '-references__description' | '-references__type' | '-references__updated_dt' | '-references__url' | '-references__uuid' | '-reported_dt' | '-requires_cve_description' | '-source' | '-statement' | '-team_id' | '-title' | '-unembargo_dt' | '-updated_dt' | '-uuid' | '-workflow_state' | 'acknowledgments__affiliation' | 'acknowledgments__created_dt' | 'acknowledgments__from_upstream' | 'acknowledgments__name' | 'acknowledgments__updated_dt' | 'acknowledgments__uuid' | 'affects__affectedness' | 'affects__created_dt' | 'affects__impact' | 'affects__ps_component' | 'affects__ps_module' | 'affects__resolution' | 'affects__trackers__created_dt' | 'affects__trackers__errata__advisory_name' | 'affects__trackers__errata__et_id' | 'affects__trackers__errata__shipped_dt' | 'affects__trackers__external_system_id' | 'affects__trackers__ps_update_stream' | 'affects__trackers__resolution' | 'affects__trackers__status' | 'affects__trackers__type' | 'affects__trackers__updated_dt' | 'affects__trackers__uuid' | 'affects__updated_dt' | 'affects__uuid' | 'bz_id' | 'comment_zero' | 'components' | 'created_dt' | 'cve_description' | 'cve_id' | 'cvss_scores__comment' | 'cvss_scores__created_dt' | 'cvss_scores__issuer' | 'cvss_scores__score' | 'cvss_scores__updated_dt' | 'cvss_scores__uuid' | 'cvss_scores__vector' | 'cwe_id' | 'embargoed' | 'impact' | 'major_incident_start_dt' | 'major_incident_state' | 'nist_cvss_validation' | 'owner' | 'references__created_dt' | 'references__description' | 'references__type' | 'references__updated_dt' | 'references__url' | 'references__uuid' | 'reported_dt' | 'requires_cve_description' | 'source' | 'statement' | 'team_id' | 'title' | 'unembargo_dt' | 'updated_dt' | 'uuid' | 'workflow_state'>, owner?: string, ownerIsempty?: boolean, referencesCreatedDt?: string, referencesCreatedDtDate?: string, referencesCreatedDtDateGte?: string, referencesCreatedDtDateLte?: string, referencesCreatedDtGt?: string, referencesCreatedDtGte?: string, referencesCreatedDtLt?: string, referencesCreatedDtLte?: string, referencesDescription?: string, referencesType?: 'ARTICLE' | 'EXTERNAL' | 'SOURCE', referencesUpdatedDt?: string, referencesUpdatedDtDate?: string, referencesUpdatedDtDateGte?: string, referencesUpdatedDtDateLte?: string, referencesUpdatedDtGt?: string, referencesUpdatedDtGte?: string, referencesUpdatedDtLt?: string, referencesUpdatedDtLte?: string, referencesUrl?: string, referencesUuid?: string, reportedDt?: string, reportedDtDate?: string, reportedDtDateGte?: string, reportedDtDateLte?: string, reportedDtGt?: string, reportedDtGte?: string, reportedDtLt?: string, reportedDtLte?: string, requiresCveDescription?: '' | 'APPROVED' | 'REJECTED' | 'REQUESTED', search?: string, source?: '' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'NVD' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'OSV' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF', statement?: string, statementIsempty?: boolean, teamId?: string, title?: string, trackerIds?: Array<string>, unembargoDt?: string, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, workflowState?: Array<'' | 'DONE' | 'NEW' | 'PRE_SECONDARY_ASSESSMENT' | 'REJECTED' | 'SECONDARY_ASSESSMENT' | 'TRIAGE'>, options?: any): AxiosPromise<OsidbApiV1FlawsList200Response> {
            return localVarFp.osidbApiV1FlawsList(acknowledgmentsAffiliation, acknowledgmentsCreatedDt, acknowledgmentsCreatedDtDate, acknowledgmentsCreatedDtDateGte, acknowledgmentsCreatedDtDateLte, acknowledgmentsCreatedDtGt, acknowledgmentsCreatedDtGte, acknowledgmentsCreatedDtLt, acknowledgmentsCreatedDtLte, acknowledgmentsFromUpstream, acknowledgmentsName, acknowledgmentsUpdatedDt, acknowledgmentsUpdatedDtDate, acknowledgmentsUpdatedDtDateGte, acknowledgmentsUpdatedDtDateLte, acknowledgmentsUpdatedDtGt, acknowledgmentsUpdatedDtGte, acknowledgmentsUpdatedDtLt, acknowledgmentsUpdatedDtLte, acknowledgmentsUuid, affectsAffectedness, affectsCreatedDt, affectsCreatedDtDate, affectsCreatedDtDateGte, affectsCreatedDtDateLte, affectsCreatedDtGt, affectsCreatedDtGte, affectsCreatedDtLt, affectsCreatedDtLte, affectsEmbargoed, affectsImpact, affectsPsComponent, affectsPsModule, affectsResolution, affectsTrackersCreatedDt, affectsTrackersCreatedDtDate, affectsTrackersCreatedDtDateGte, affectsTrackersCreatedDtDateLte, affectsTrackersCreatedDtGt, affectsTrackersCreatedDtGte, affectsTrackersCreatedDtLt, affectsTrackersCreatedDtLte, affectsTrackersEmbargoed, affectsTrackersErrataAdvisoryName, affectsTrackersErrataEtId, affectsTrackersErrataShippedDt, affectsTrackersErrataShippedDtDate, affectsTrackersErrataShippedDtDateGte, affectsTrackersErrataShippedDtDateLte, affectsTrackersErrataShippedDtGt, affectsTrackersErrataShippedDtGte, affectsTrackersErrataShippedDtLt, affectsTrackersErrataShippedDtLte, affectsTrackersExternalSystemId, affectsTrackersPsUpdateStream, affectsTrackersResolution, affectsTrackersStatus, affectsTrackersType, affectsTrackersUpdatedDt, affectsTrackersUpdatedDtDate, affectsTrackersUpdatedDtDateGte, affectsTrackersUpdatedDtDateLte, affectsTrackersUpdatedDtGt, affectsTrackersUpdatedDtGte, affectsTrackersUpdatedDtLt, affectsTrackersUpdatedDtLte, affectsTrackersUuid, affectsUpdatedDt, affectsUpdatedDtDate, affectsUpdatedDtDateGte, affectsUpdatedDtDateLte, affectsUpdatedDtGt, affectsUpdatedDtGte, affectsUpdatedDtLt, affectsUpdatedDtLte, affectsUuid, bzId, changedAfter, changedBefore, commentZero, components, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, cveDescription, cveDescriptionIsempty, cveId, cveIdIsempty, cvss2NistIsempty, cvss2RhIsempty, cvss3NistIsempty, cvss3RhIsempty, cvss4NistIsempty, cvss4RhIsempty, cvssScoresComment, cvssScoresCreatedDt, cvssScoresCreatedDtDate, cvssScoresCreatedDtDateGte, cvssScoresCreatedDtDateLte, cvssScoresCreatedDtGt, cvssScoresCreatedDtGte, cvssScoresCreatedDtLt, cvssScoresCreatedDtLte, cvssScoresCvssVersion, cvssScoresIssuer, cvssScoresScore, cvssScoresUpdatedDt, cvssScoresUpdatedDtDate, cvssScoresUpdatedDtDateGte, cvssScoresUpdatedDtDateLte, cvssScoresUpdatedDtGt, cvssScoresUpdatedDtGte, cvssScoresUpdatedDtLt, cvssScoresUpdatedDtLte, cvssScoresUuid, cvssScoresVector, cweId, cweIdIsempty, embargoed, excludeFields, impact, includeFields, includeMetaAttr, limit, majorIncidentStartDt, majorIncidentStartDtDate, majorIncidentStartDtDateGte, majorIncidentStartDtDateLte, majorIncidentStartDtGt, majorIncidentStartDtGte, majorIncidentStartDtLt, majorIncidentStartDtLte, majorIncidentState, mitigationIsempty, nistCvssValidation, offset, order, owner, ownerIsempty, referencesCreatedDt, referencesCreatedDtDate, referencesCreatedDtDateGte, referencesCreatedDtDateLte, referencesCreatedDtGt, referencesCreatedDtGte, referencesCreatedDtLt, referencesCreatedDtLte, referencesDescription, referencesType, referencesUpdatedDt, referencesUpdatedDtDate, referencesUpdatedDtDateGte, referencesUpdatedDtDateLte, referencesUpdatedDtGt, referencesUpdatedDtGte, referencesUpdatedDtLt, referencesUpdatedDtLte, referencesUrl, referencesUuid, reportedDt, reportedDtDate, reportedDtDateGte, reportedDtDateLte, reportedDtGt, reportedDtGte, reportedDtLt, reportedDtLte, requiresCveDescription, search, source, statement, statementIsempty, teamId, title, trackerIds, unembargoDt, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, workflowState, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId 
         * @param {FlawPackageVersionPost} flawPackageVersionPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsPackageVersionsCreate(bugzillaApiKey: string, flawId: string, flawPackageVersionPost: FlawPackageVersionPost, options?: any): AxiosPromise<OsidbApiV1FlawsPackageVersionsCreate201Response> {
            return localVarFp.osidbApiV1FlawsPackageVersionsCreate(bugzillaApiKey, flawId, flawPackageVersionPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Destroy the instance and proxy the delete to Bugzilla
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsPackageVersionsDestroy(bugzillaApiKey: string, flawId: string, id: string, options?: any): AxiosPromise<AuthTokenCreate200ResponseAllOf> {
            return localVarFp.osidbApiV1FlawsPackageVersionsDestroy(bugzillaApiKey, flawId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [_package] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {string} [versionsVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsPackageVersionsList(flawId: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, excludeFields?: Array<string>, includeFields?: Array<string>, limit?: number, offset?: number, _package?: string, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, versionsVersion?: string, options?: any): AxiosPromise<OsidbApiV1FlawsPackageVersionsList200Response> {
            return localVarFp.osidbApiV1FlawsPackageVersionsList(flawId, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, excludeFields, includeFields, limit, offset, _package, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, versionsVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} id 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsPackageVersionsRetrieve(flawId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, options?: any): AxiosPromise<OsidbApiV1FlawsPackageVersionsCreate201Response> {
            return localVarFp.osidbApiV1FlawsPackageVersionsRetrieve(flawId, id, excludeFields, includeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId 
         * @param {string} id 
         * @param {FlawPackageVersionPut} flawPackageVersionPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsPackageVersionsUpdate(bugzillaApiKey: string, flawId: string, id: string, flawPackageVersionPut: FlawPackageVersionPut, options?: any): AxiosPromise<OsidbApiV1FlawsPackageVersionsCreate201Response> {
            return localVarFp.osidbApiV1FlawsPackageVersionsUpdate(bugzillaApiKey, flawId, id, flawPackageVersionPut, options).then((request) => request(axios, basePath));
        },
        /**
         * workflow promotion API endpoint  try to adjust workflow classification of flaw to the next state available return its workflow:state classification or errors if not possible to promote
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {string} flawId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsPromoteCreate(bugzillaApiKey: string, jiraApiKey: string, flawId: string, options?: any): AxiosPromise<AuthTokenCreate200ResponseAllOf> {
            return localVarFp.osidbApiV1FlawsPromoteCreate(bugzillaApiKey, jiraApiKey, flawId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId 
         * @param {FlawReferencePost} flawReferencePost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsReferencesCreate(bugzillaApiKey: string, flawId: string, flawReferencePost: FlawReferencePost, options?: any): AxiosPromise<OsidbApiV1FlawsReferencesCreate201Response> {
            return localVarFp.osidbApiV1FlawsReferencesCreate(bugzillaApiKey, flawId, flawReferencePost, options).then((request) => request(axios, basePath));
        },
        /**
         * Destroy the instance and proxy the delete to Bugzilla
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsReferencesDestroy(bugzillaApiKey: string, flawId: string, id: string, options?: any): AxiosPromise<AuthTokenCreate200ResponseAllOf> {
            return localVarFp.osidbApiV1FlawsReferencesDestroy(bugzillaApiKey, flawId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {string} [description] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {'ARTICLE' | 'EXTERNAL' | 'SOURCE'} [type] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [url] 
         * @param {string} [uuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsReferencesList(flawId: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, description?: string, excludeFields?: Array<string>, includeFields?: Array<string>, limit?: number, offset?: number, type?: 'ARTICLE' | 'EXTERNAL' | 'SOURCE', updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, url?: string, uuid?: string, options?: any): AxiosPromise<OsidbApiV1FlawsReferencesList200Response> {
            return localVarFp.osidbApiV1FlawsReferencesList(flawId, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, description, excludeFields, includeFields, limit, offset, type, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, url, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} flawId 
         * @param {string} id 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsReferencesRetrieve(flawId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, options?: any): AxiosPromise<OsidbApiV1FlawsReferencesCreate201Response> {
            return localVarFp.osidbApiV1FlawsReferencesRetrieve(flawId, id, excludeFields, includeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} flawId 
         * @param {string} id 
         * @param {FlawReferencePut} flawReferencePut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsReferencesUpdate(bugzillaApiKey: string, flawId: string, id: string, flawReferencePut: FlawReferencePut, options?: any): AxiosPromise<OsidbApiV1FlawsReferencesCreate201Response> {
            return localVarFp.osidbApiV1FlawsReferencesUpdate(bugzillaApiKey, flawId, id, flawReferencePut, options).then((request) => request(axios, basePath));
        },
        /**
         * workflow promotion API endpoint  try to reject a flaw / task
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {string} flawId 
         * @param {Reject} reject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsRejectCreate(bugzillaApiKey: string, jiraApiKey: string, flawId: string, reject: Reject, options?: any): AxiosPromise<AuthTokenCreate200ResponseAllOf> {
            return localVarFp.osidbApiV1FlawsRejectCreate(bugzillaApiKey, jiraApiKey, flawId, reject, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {Array<string>} [trackerIds] Filter only Flaws which are related to specified Trackers (through Affects). Multiple tracker IDs may be separated by commas. Also only Affects that have the specified Trackers related will be shown.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsRetrieve(id: string, excludeFields?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, trackerIds?: Array<string>, options?: any): AxiosPromise<OsidbApiV1FlawsCreate201Response> {
            return localVarFp.osidbApiV1FlawsRetrieve(id, excludeFields, includeFields, includeMetaAttr, trackerIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {string} id A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
         * @param {Flaw} flaw 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1FlawsUpdate(bugzillaApiKey: string, jiraApiKey: string, id: string, flaw: Flaw, options?: any): AxiosPromise<OsidbApiV1FlawsCreate201Response> {
            return localVarFp.osidbApiV1FlawsUpdate(bugzillaApiKey, jiraApiKey, id, flaw, options).then((request) => request(axios, basePath));
        },
        /**
         * HTTP get /manifest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1ManifestRetrieve(options?: any): AxiosPromise<AuthTokenCreate200ResponseAllOf> {
            return localVarFp.osidbApiV1ManifestRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {'json' | 'yaml'} [format] 
         * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1SchemaRetrieve(format?: 'json' | 'yaml', lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.osidbApiV1SchemaRetrieve(format, lang, options).then((request) => request(axios, basePath));
        },
        /**
         * HTTP get /status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1StatusRetrieve(options?: any): AxiosPromise<OsidbApiV1StatusRetrieve200Response> {
            return localVarFp.osidbApiV1StatusRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {TrackerPost} trackerPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1TrackersCreate(bugzillaApiKey: string, jiraApiKey: string, trackerPost: TrackerPost, options?: any): AxiosPromise<OsidbApiV1TrackersCreate201Response> {
            return localVarFp.osidbApiV1TrackersCreate(bugzillaApiKey, jiraApiKey, trackerPost, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {'' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED'} [affectsAffectedness] 
         * @param {string} [affectsCreatedDt] 
         * @param {string} [affectsCreatedDtDate] 
         * @param {string} [affectsCreatedDtDateGte] 
         * @param {string} [affectsCreatedDtDateLte] 
         * @param {string} [affectsCreatedDtGt] 
         * @param {string} [affectsCreatedDtGte] 
         * @param {string} [affectsCreatedDtLt] 
         * @param {string} [affectsCreatedDtLte] 
         * @param {boolean} [affectsEmbargoed] 
         * @param {Array<string>} [affectsFlawComponents] Multiple values may be separated by commas.
         * @param {string} [affectsFlawCreatedDt] 
         * @param {string} [affectsFlawCreatedDtDate] 
         * @param {string} [affectsFlawCreatedDtDateGte] 
         * @param {string} [affectsFlawCreatedDtDateLte] 
         * @param {string} [affectsFlawCreatedDtGt] 
         * @param {string} [affectsFlawCreatedDtGte] 
         * @param {string} [affectsFlawCreatedDtLt] 
         * @param {string} [affectsFlawCreatedDtLte] 
         * @param {string} [affectsFlawCveId] 
         * @param {string} [affectsFlawCweId] 
         * @param {boolean} [affectsFlawEmbargoed] 
         * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [affectsFlawImpact] 
         * @param {string} [affectsFlawReportedDt] 
         * @param {string} [affectsFlawReportedDtDate] 
         * @param {string} [affectsFlawReportedDtDateGte] 
         * @param {string} [affectsFlawReportedDtDateLte] 
         * @param {string} [affectsFlawReportedDtGt] 
         * @param {string} [affectsFlawReportedDtGte] 
         * @param {string} [affectsFlawReportedDtLt] 
         * @param {string} [affectsFlawReportedDtLte] 
         * @param {'' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'NVD' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'OSV' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF'} [affectsFlawSource] 
         * @param {string} [affectsFlawUnembargoDt] 
         * @param {string} [affectsFlawUpdatedDt] 
         * @param {string} [affectsFlawUpdatedDtDate] 
         * @param {string} [affectsFlawUpdatedDtDateGte] 
         * @param {string} [affectsFlawUpdatedDtDateLte] 
         * @param {string} [affectsFlawUpdatedDtGt] 
         * @param {string} [affectsFlawUpdatedDtGte] 
         * @param {string} [affectsFlawUpdatedDtLt] 
         * @param {string} [affectsFlawUpdatedDtLte] 
         * @param {string} [affectsFlawUuid] 
         * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [affectsImpact] 
         * @param {string} [affectsPsComponent] 
         * @param {string} [affectsPsModule] 
         * @param {'' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT'} [affectsResolution] 
         * @param {string} [affectsUpdatedDt] 
         * @param {string} [affectsUpdatedDtDate] 
         * @param {string} [affectsUpdatedDtDateGte] 
         * @param {string} [affectsUpdatedDtDateLte] 
         * @param {string} [affectsUpdatedDtGt] 
         * @param {string} [affectsUpdatedDtGte] 
         * @param {string} [affectsUpdatedDtLt] 
         * @param {string} [affectsUpdatedDtLte] 
         * @param {string} [affectsUuid] 
         * @param {string} [createdDt] 
         * @param {string} [createdDtDate] 
         * @param {string} [createdDtDateGte] 
         * @param {string} [createdDtDateLte] 
         * @param {string} [createdDtGt] 
         * @param {string} [createdDtGte] 
         * @param {string} [createdDtLt] 
         * @param {string} [createdDtLte] 
         * @param {boolean} [embargoed] 
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {string} [externalSystemId] 
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {Array<'-affects__affectedness' | '-affects__created_dt' | '-affects__embargoed' | '-affects__flaw__components' | '-affects__flaw__created_dt' | '-affects__flaw__cve_id' | '-affects__flaw__cwe_id' | '-affects__flaw__embargoed' | '-affects__flaw__impact' | '-affects__flaw__reported_dt' | '-affects__flaw__source' | '-affects__flaw__unembargo_dt' | '-affects__flaw__updated_dt' | '-affects__flaw__uuid' | '-affects__impact' | '-affects__ps_component' | '-affects__ps_module' | '-affects__resolution' | '-affects__updated_dt' | '-affects__uuid' | '-created_dt' | '-embargoed' | '-external_system_id' | '-ps_update_stream' | '-resolution' | '-status' | '-type' | '-updated_dt' | '-uuid' | 'affects__affectedness' | 'affects__created_dt' | 'affects__embargoed' | 'affects__flaw__components' | 'affects__flaw__created_dt' | 'affects__flaw__cve_id' | 'affects__flaw__cwe_id' | 'affects__flaw__embargoed' | 'affects__flaw__impact' | 'affects__flaw__reported_dt' | 'affects__flaw__source' | 'affects__flaw__unembargo_dt' | 'affects__flaw__updated_dt' | 'affects__flaw__uuid' | 'affects__impact' | 'affects__ps_component' | 'affects__ps_module' | 'affects__resolution' | 'affects__updated_dt' | 'affects__uuid' | 'created_dt' | 'embargoed' | 'external_system_id' | 'ps_update_stream' | 'resolution' | 'status' | 'type' | 'updated_dt' | 'uuid'>} [order] Ordering
         * @param {string} [psUpdateStream] 
         * @param {string} [resolution] 
         * @param {string} [status] 
         * @param {'BUGZILLA' | 'JIRA'} [type] 
         * @param {string} [updatedDt] 
         * @param {string} [updatedDtDate] 
         * @param {string} [updatedDtDateGte] 
         * @param {string} [updatedDtDateLte] 
         * @param {string} [updatedDtGt] 
         * @param {string} [updatedDtGte] 
         * @param {string} [updatedDtLt] 
         * @param {string} [updatedDtLte] 
         * @param {string} [uuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1TrackersList(affectsAffectedness?: '' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED', affectsCreatedDt?: string, affectsCreatedDtDate?: string, affectsCreatedDtDateGte?: string, affectsCreatedDtDateLte?: string, affectsCreatedDtGt?: string, affectsCreatedDtGte?: string, affectsCreatedDtLt?: string, affectsCreatedDtLte?: string, affectsEmbargoed?: boolean, affectsFlawComponents?: Array<string>, affectsFlawCreatedDt?: string, affectsFlawCreatedDtDate?: string, affectsFlawCreatedDtDateGte?: string, affectsFlawCreatedDtDateLte?: string, affectsFlawCreatedDtGt?: string, affectsFlawCreatedDtGte?: string, affectsFlawCreatedDtLt?: string, affectsFlawCreatedDtLte?: string, affectsFlawCveId?: string, affectsFlawCweId?: string, affectsFlawEmbargoed?: boolean, affectsFlawImpact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', affectsFlawReportedDt?: string, affectsFlawReportedDtDate?: string, affectsFlawReportedDtDateGte?: string, affectsFlawReportedDtDateLte?: string, affectsFlawReportedDtGt?: string, affectsFlawReportedDtGte?: string, affectsFlawReportedDtLt?: string, affectsFlawReportedDtLte?: string, affectsFlawSource?: '' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'NVD' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'OSV' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF', affectsFlawUnembargoDt?: string, affectsFlawUpdatedDt?: string, affectsFlawUpdatedDtDate?: string, affectsFlawUpdatedDtDateGte?: string, affectsFlawUpdatedDtDateLte?: string, affectsFlawUpdatedDtGt?: string, affectsFlawUpdatedDtGte?: string, affectsFlawUpdatedDtLt?: string, affectsFlawUpdatedDtLte?: string, affectsFlawUuid?: string, affectsImpact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', affectsPsComponent?: string, affectsPsModule?: string, affectsResolution?: '' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT', affectsUpdatedDt?: string, affectsUpdatedDtDate?: string, affectsUpdatedDtDateGte?: string, affectsUpdatedDtDateLte?: string, affectsUpdatedDtGt?: string, affectsUpdatedDtGte?: string, affectsUpdatedDtLt?: string, affectsUpdatedDtLte?: string, affectsUuid?: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, embargoed?: boolean, excludeFields?: Array<string>, externalSystemId?: string, includeFields?: Array<string>, includeMetaAttr?: Array<string>, limit?: number, offset?: number, order?: Array<'-affects__affectedness' | '-affects__created_dt' | '-affects__embargoed' | '-affects__flaw__components' | '-affects__flaw__created_dt' | '-affects__flaw__cve_id' | '-affects__flaw__cwe_id' | '-affects__flaw__embargoed' | '-affects__flaw__impact' | '-affects__flaw__reported_dt' | '-affects__flaw__source' | '-affects__flaw__unembargo_dt' | '-affects__flaw__updated_dt' | '-affects__flaw__uuid' | '-affects__impact' | '-affects__ps_component' | '-affects__ps_module' | '-affects__resolution' | '-affects__updated_dt' | '-affects__uuid' | '-created_dt' | '-embargoed' | '-external_system_id' | '-ps_update_stream' | '-resolution' | '-status' | '-type' | '-updated_dt' | '-uuid' | 'affects__affectedness' | 'affects__created_dt' | 'affects__embargoed' | 'affects__flaw__components' | 'affects__flaw__created_dt' | 'affects__flaw__cve_id' | 'affects__flaw__cwe_id' | 'affects__flaw__embargoed' | 'affects__flaw__impact' | 'affects__flaw__reported_dt' | 'affects__flaw__source' | 'affects__flaw__unembargo_dt' | 'affects__flaw__updated_dt' | 'affects__flaw__uuid' | 'affects__impact' | 'affects__ps_component' | 'affects__ps_module' | 'affects__resolution' | 'affects__updated_dt' | 'affects__uuid' | 'created_dt' | 'embargoed' | 'external_system_id' | 'ps_update_stream' | 'resolution' | 'status' | 'type' | 'updated_dt' | 'uuid'>, psUpdateStream?: string, resolution?: string, status?: string, type?: 'BUGZILLA' | 'JIRA', updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, options?: any): AxiosPromise<OsidbApiV1TrackersList200Response> {
            return localVarFp.osidbApiV1TrackersList(affectsAffectedness, affectsCreatedDt, affectsCreatedDtDate, affectsCreatedDtDateGte, affectsCreatedDtDateLte, affectsCreatedDtGt, affectsCreatedDtGte, affectsCreatedDtLt, affectsCreatedDtLte, affectsEmbargoed, affectsFlawComponents, affectsFlawCreatedDt, affectsFlawCreatedDtDate, affectsFlawCreatedDtDateGte, affectsFlawCreatedDtDateLte, affectsFlawCreatedDtGt, affectsFlawCreatedDtGte, affectsFlawCreatedDtLt, affectsFlawCreatedDtLte, affectsFlawCveId, affectsFlawCweId, affectsFlawEmbargoed, affectsFlawImpact, affectsFlawReportedDt, affectsFlawReportedDtDate, affectsFlawReportedDtDateGte, affectsFlawReportedDtDateLte, affectsFlawReportedDtGt, affectsFlawReportedDtGte, affectsFlawReportedDtLt, affectsFlawReportedDtLte, affectsFlawSource, affectsFlawUnembargoDt, affectsFlawUpdatedDt, affectsFlawUpdatedDtDate, affectsFlawUpdatedDtDateGte, affectsFlawUpdatedDtDateLte, affectsFlawUpdatedDtGt, affectsFlawUpdatedDtGte, affectsFlawUpdatedDtLt, affectsFlawUpdatedDtLte, affectsFlawUuid, affectsImpact, affectsPsComponent, affectsPsModule, affectsResolution, affectsUpdatedDt, affectsUpdatedDtDate, affectsUpdatedDtDateGte, affectsUpdatedDtDateLte, affectsUpdatedDtGt, affectsUpdatedDtGte, affectsUpdatedDtLt, affectsUpdatedDtLte, affectsUuid, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, embargoed, excludeFields, externalSystemId, includeFields, includeMetaAttr, limit, offset, order, psUpdateStream, resolution, status, type, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid A UUID string identifying this Tracker.
         * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
         * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1TrackersRetrieve(uuid: string, excludeFields?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, options?: any): AxiosPromise<OsidbApiV1TrackersCreate201Response> {
            return localVarFp.osidbApiV1TrackersRetrieve(uuid, excludeFields, includeFields, includeMetaAttr, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
         * @param {string} jiraApiKey User generated api key for Jira authentication.
         * @param {string} uuid A UUID string identifying this Tracker.
         * @param {Tracker} tracker 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbApiV1TrackersUpdate(bugzillaApiKey: string, jiraApiKey: string, uuid: string, tracker: Tracker, options?: any): AxiosPromise<OsidbApiV1TrackersCreate201Response> {
            return localVarFp.osidbApiV1TrackersUpdate(bugzillaApiKey, jiraApiKey, uuid, tracker, options).then((request) => request(axios, basePath));
        },
        /**
         * unauthenticated view providing healthcheck on osidb service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbHealthyRetrieve(options?: any): AxiosPromise<AuthTokenCreate200ResponseAllOf> {
            return localVarFp.osidbHealthyRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * View that provides information about the currently logged-in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osidbWhoamiRetrieve(options?: any): AxiosPromise<OsidbWhoamiRetrieve200Response> {
            return localVarFp.osidbWhoamiRetrieve(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OsidbApi - object-oriented interface
 * @export
 * @class OsidbApi
 * @extends {BaseAPI}
 */
export class OsidbApi extends BaseAPI {
    /**
     * Bulk create endpoint. Expects a list of dict Affect objects.
     * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
     * @param {Array<AffectPost>} affectPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1AffectsBulkCreate(bugzillaApiKey: string, affectPost: Array<AffectPost>, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1AffectsBulkCreate(bugzillaApiKey, affectPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Bulk delete endpoint. Expects a list of Affect uuids.
     * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1AffectsBulkDestroy(bugzillaApiKey: string, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1AffectsBulkDestroy(bugzillaApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Bulk update endpoint. Expects a list of dict Affect objects.
     * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
     * @param {string} jiraApiKey User generated api key for Jira authentication.
     * @param {Array<AffectBulkPut>} affectBulkPut 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1AffectsBulkUpdate(bugzillaApiKey: string, jiraApiKey: string, affectBulkPut: Array<AffectBulkPut>, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1AffectsBulkUpdate(bugzillaApiKey, jiraApiKey, affectBulkPut, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
     * @param {string} jiraApiKey User generated api key for Jira authentication.
     * @param {AffectPost} affectPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1AffectsCreate(bugzillaApiKey: string, jiraApiKey: string, affectPost: AffectPost, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1AffectsCreate(bugzillaApiKey, jiraApiKey, affectPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
     * @param {string} affectId 
     * @param {AffectCVSSPost} affectCVSSPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1AffectsCvssScoresCreate(bugzillaApiKey: string, affectId: string, affectCVSSPost: AffectCVSSPost, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1AffectsCvssScoresCreate(bugzillaApiKey, affectId, affectCVSSPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Destroy the instance and proxy the delete to Bugzilla.
     * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
     * @param {string} affectId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1AffectsCvssScoresDestroy(bugzillaApiKey: string, affectId: string, id: string, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1AffectsCvssScoresDestroy(bugzillaApiKey, affectId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} affectId 
     * @param {string} [comment] 
     * @param {string} [createdDt] 
     * @param {string} [createdDtDate] 
     * @param {string} [createdDtDateGte] 
     * @param {string} [createdDtDateLte] 
     * @param {string} [createdDtGt] 
     * @param {string} [createdDtGte] 
     * @param {string} [createdDtLt] 
     * @param {string} [createdDtLte] 
     * @param {string} [cvssVersion] 
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {'NIST' | 'OSV' | 'RH'} [issuer] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {number} [score] 
     * @param {string} [updatedDt] 
     * @param {string} [updatedDtDate] 
     * @param {string} [updatedDtDateGte] 
     * @param {string} [updatedDtDateLte] 
     * @param {string} [updatedDtGt] 
     * @param {string} [updatedDtGte] 
     * @param {string} [updatedDtLt] 
     * @param {string} [updatedDtLte] 
     * @param {string} [uuid] 
     * @param {string} [vector] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1AffectsCvssScoresList(affectId: string, comment?: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, cvssVersion?: string, excludeFields?: Array<string>, includeFields?: Array<string>, issuer?: 'NIST' | 'OSV' | 'RH', limit?: number, offset?: number, score?: number, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, vector?: string, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1AffectsCvssScoresList(affectId, comment, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, cvssVersion, excludeFields, includeFields, issuer, limit, offset, score, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, vector, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} affectId 
     * @param {string} id 
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1AffectsCvssScoresRetrieve(affectId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1AffectsCvssScoresRetrieve(affectId, id, excludeFields, includeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
     * @param {string} affectId 
     * @param {string} id 
     * @param {AffectCVSSPut} affectCVSSPut 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1AffectsCvssScoresUpdate(bugzillaApiKey: string, affectId: string, id: string, affectCVSSPut: AffectCVSSPut, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1AffectsCvssScoresUpdate(bugzillaApiKey, affectId, id, affectCVSSPut, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Destroy the instance and proxy the delete to Bugzilla
     * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
     * @param {string} uuid A UUID string identifying this Affect.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1AffectsDestroy(bugzillaApiKey: string, uuid: string, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1AffectsDestroy(bugzillaApiKey, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {'' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED'} [affectedness] 
     * @param {string} [createdDt] 
     * @param {string} [createdDtDate] 
     * @param {string} [createdDtDateGte] 
     * @param {string} [createdDtDateLte] 
     * @param {string} [createdDtGt] 
     * @param {string} [createdDtGte] 
     * @param {string} [createdDtLt] 
     * @param {string} [createdDtLte] 
     * @param {string} [cvssScoresComment] 
     * @param {string} [cvssScoresCreatedDt] 
     * @param {string} [cvssScoresCreatedDtDate] 
     * @param {string} [cvssScoresCreatedDtDateGte] 
     * @param {string} [cvssScoresCreatedDtDateLte] 
     * @param {string} [cvssScoresCreatedDtGt] 
     * @param {string} [cvssScoresCreatedDtGte] 
     * @param {string} [cvssScoresCreatedDtLt] 
     * @param {string} [cvssScoresCreatedDtLte] 
     * @param {string} [cvssScoresCvssVersion] 
     * @param {'NIST' | 'OSV' | 'RH'} [cvssScoresIssuer] 
     * @param {number} [cvssScoresScore] 
     * @param {string} [cvssScoresUpdatedDt] 
     * @param {string} [cvssScoresUpdatedDtDate] 
     * @param {string} [cvssScoresUpdatedDtDateGte] 
     * @param {string} [cvssScoresUpdatedDtDateLte] 
     * @param {string} [cvssScoresUpdatedDtGt] 
     * @param {string} [cvssScoresUpdatedDtGte] 
     * @param {string} [cvssScoresUpdatedDtLt] 
     * @param {string} [cvssScoresUpdatedDtLte] 
     * @param {string} [cvssScoresUuid] 
     * @param {string} [cvssScoresVector] 
     * @param {boolean} [embargoed] 
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [flawComponents] Multiple values may be separated by commas.
     * @param {string} [flawCreatedDt] 
     * @param {string} [flawCreatedDtDate] 
     * @param {string} [flawCreatedDtDateGte] 
     * @param {string} [flawCreatedDtDateLte] 
     * @param {string} [flawCreatedDtGt] 
     * @param {string} [flawCreatedDtGte] 
     * @param {string} [flawCreatedDtLt] 
     * @param {string} [flawCreatedDtLte] 
     * @param {string} [flawCveId] 
     * @param {string} [flawCweId] 
     * @param {boolean} [flawEmbargoed] 
     * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [flawImpact] 
     * @param {string} [flawReportedDt] 
     * @param {string} [flawReportedDtDate] 
     * @param {string} [flawReportedDtDateGte] 
     * @param {string} [flawReportedDtDateLte] 
     * @param {string} [flawReportedDtGt] 
     * @param {string} [flawReportedDtGte] 
     * @param {string} [flawReportedDtLt] 
     * @param {string} [flawReportedDtLte] 
     * @param {'' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'NVD' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'OSV' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF'} [flawSource] 
     * @param {string} [flawUnembargoDt] 
     * @param {string} [flawUpdatedDt] 
     * @param {string} [flawUpdatedDtDate] 
     * @param {string} [flawUpdatedDtDateGte] 
     * @param {string} [flawUpdatedDtDateLte] 
     * @param {string} [flawUpdatedDtGt] 
     * @param {string} [flawUpdatedDtGte] 
     * @param {string} [flawUpdatedDtLt] 
     * @param {string} [flawUpdatedDtLte] 
     * @param {string} [flawUuid] 
     * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [impact] 
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {Array<'-affectedness' | '-created_dt' | '-cvss_scores__comment' | '-cvss_scores__created_dt' | '-cvss_scores__cvss_version' | '-cvss_scores__issuer' | '-cvss_scores__score' | '-cvss_scores__updated_dt' | '-cvss_scores__uuid' | '-cvss_scores__vector' | '-embargoed' | '-flaw__components' | '-flaw__created_dt' | '-flaw__cve_id' | '-flaw__cwe_id' | '-flaw__embargoed' | '-flaw__impact' | '-flaw__reported_dt' | '-flaw__source' | '-flaw__unembargo_dt' | '-flaw__updated_dt' | '-flaw__uuid' | '-impact' | '-ps_component' | '-ps_module' | '-resolution' | '-trackers__created_dt' | '-trackers__embargoed' | '-trackers__external_system_id' | '-trackers__ps_update_stream' | '-trackers__resolution' | '-trackers__status' | '-trackers__type' | '-trackers__updated_dt' | '-trackers__uuid' | '-updated_dt' | '-uuid' | 'affectedness' | 'created_dt' | 'cvss_scores__comment' | 'cvss_scores__created_dt' | 'cvss_scores__cvss_version' | 'cvss_scores__issuer' | 'cvss_scores__score' | 'cvss_scores__updated_dt' | 'cvss_scores__uuid' | 'cvss_scores__vector' | 'embargoed' | 'flaw__components' | 'flaw__created_dt' | 'flaw__cve_id' | 'flaw__cwe_id' | 'flaw__embargoed' | 'flaw__impact' | 'flaw__reported_dt' | 'flaw__source' | 'flaw__unembargo_dt' | 'flaw__updated_dt' | 'flaw__uuid' | 'impact' | 'ps_component' | 'ps_module' | 'resolution' | 'trackers__created_dt' | 'trackers__embargoed' | 'trackers__external_system_id' | 'trackers__ps_update_stream' | 'trackers__resolution' | 'trackers__status' | 'trackers__type' | 'trackers__updated_dt' | 'trackers__uuid' | 'updated_dt' | 'uuid'>} [order] Ordering
     * @param {string} [psComponent] 
     * @param {string} [psModule] 
     * @param {'' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT'} [resolution] 
     * @param {string} [trackersCreatedDt] 
     * @param {string} [trackersCreatedDtDate] 
     * @param {string} [trackersCreatedDtDateGte] 
     * @param {string} [trackersCreatedDtDateLte] 
     * @param {string} [trackersCreatedDtGt] 
     * @param {string} [trackersCreatedDtGte] 
     * @param {string} [trackersCreatedDtLt] 
     * @param {string} [trackersCreatedDtLte] 
     * @param {boolean} [trackersEmbargoed] 
     * @param {string} [trackersExternalSystemId] 
     * @param {string} [trackersPsUpdateStream] 
     * @param {string} [trackersResolution] 
     * @param {string} [trackersStatus] 
     * @param {'BUGZILLA' | 'JIRA'} [trackersType] 
     * @param {string} [trackersUpdatedDt] 
     * @param {string} [trackersUpdatedDtDate] 
     * @param {string} [trackersUpdatedDtDateGte] 
     * @param {string} [trackersUpdatedDtDateLte] 
     * @param {string} [trackersUpdatedDtGt] 
     * @param {string} [trackersUpdatedDtGte] 
     * @param {string} [trackersUpdatedDtLt] 
     * @param {string} [trackersUpdatedDtLte] 
     * @param {string} [trackersUuid] 
     * @param {string} [updatedDt] 
     * @param {string} [updatedDtDate] 
     * @param {string} [updatedDtDateGte] 
     * @param {string} [updatedDtDateLte] 
     * @param {string} [updatedDtGt] 
     * @param {string} [updatedDtGte] 
     * @param {string} [updatedDtLt] 
     * @param {string} [updatedDtLte] 
     * @param {string} [uuid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1AffectsList(affectedness?: '' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED', createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, cvssScoresComment?: string, cvssScoresCreatedDt?: string, cvssScoresCreatedDtDate?: string, cvssScoresCreatedDtDateGte?: string, cvssScoresCreatedDtDateLte?: string, cvssScoresCreatedDtGt?: string, cvssScoresCreatedDtGte?: string, cvssScoresCreatedDtLt?: string, cvssScoresCreatedDtLte?: string, cvssScoresCvssVersion?: string, cvssScoresIssuer?: 'NIST' | 'OSV' | 'RH', cvssScoresScore?: number, cvssScoresUpdatedDt?: string, cvssScoresUpdatedDtDate?: string, cvssScoresUpdatedDtDateGte?: string, cvssScoresUpdatedDtDateLte?: string, cvssScoresUpdatedDtGt?: string, cvssScoresUpdatedDtGte?: string, cvssScoresUpdatedDtLt?: string, cvssScoresUpdatedDtLte?: string, cvssScoresUuid?: string, cvssScoresVector?: string, embargoed?: boolean, excludeFields?: Array<string>, flawComponents?: Array<string>, flawCreatedDt?: string, flawCreatedDtDate?: string, flawCreatedDtDateGte?: string, flawCreatedDtDateLte?: string, flawCreatedDtGt?: string, flawCreatedDtGte?: string, flawCreatedDtLt?: string, flawCreatedDtLte?: string, flawCveId?: string, flawCweId?: string, flawEmbargoed?: boolean, flawImpact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', flawReportedDt?: string, flawReportedDtDate?: string, flawReportedDtDateGte?: string, flawReportedDtDateLte?: string, flawReportedDtGt?: string, flawReportedDtGte?: string, flawReportedDtLt?: string, flawReportedDtLte?: string, flawSource?: '' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'NVD' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'OSV' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF', flawUnembargoDt?: string, flawUpdatedDt?: string, flawUpdatedDtDate?: string, flawUpdatedDtDateGte?: string, flawUpdatedDtDateLte?: string, flawUpdatedDtGt?: string, flawUpdatedDtGte?: string, flawUpdatedDtLt?: string, flawUpdatedDtLte?: string, flawUuid?: string, impact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', includeFields?: Array<string>, includeMetaAttr?: Array<string>, limit?: number, offset?: number, order?: Array<'-affectedness' | '-created_dt' | '-cvss_scores__comment' | '-cvss_scores__created_dt' | '-cvss_scores__cvss_version' | '-cvss_scores__issuer' | '-cvss_scores__score' | '-cvss_scores__updated_dt' | '-cvss_scores__uuid' | '-cvss_scores__vector' | '-embargoed' | '-flaw__components' | '-flaw__created_dt' | '-flaw__cve_id' | '-flaw__cwe_id' | '-flaw__embargoed' | '-flaw__impact' | '-flaw__reported_dt' | '-flaw__source' | '-flaw__unembargo_dt' | '-flaw__updated_dt' | '-flaw__uuid' | '-impact' | '-ps_component' | '-ps_module' | '-resolution' | '-trackers__created_dt' | '-trackers__embargoed' | '-trackers__external_system_id' | '-trackers__ps_update_stream' | '-trackers__resolution' | '-trackers__status' | '-trackers__type' | '-trackers__updated_dt' | '-trackers__uuid' | '-updated_dt' | '-uuid' | 'affectedness' | 'created_dt' | 'cvss_scores__comment' | 'cvss_scores__created_dt' | 'cvss_scores__cvss_version' | 'cvss_scores__issuer' | 'cvss_scores__score' | 'cvss_scores__updated_dt' | 'cvss_scores__uuid' | 'cvss_scores__vector' | 'embargoed' | 'flaw__components' | 'flaw__created_dt' | 'flaw__cve_id' | 'flaw__cwe_id' | 'flaw__embargoed' | 'flaw__impact' | 'flaw__reported_dt' | 'flaw__source' | 'flaw__unembargo_dt' | 'flaw__updated_dt' | 'flaw__uuid' | 'impact' | 'ps_component' | 'ps_module' | 'resolution' | 'trackers__created_dt' | 'trackers__embargoed' | 'trackers__external_system_id' | 'trackers__ps_update_stream' | 'trackers__resolution' | 'trackers__status' | 'trackers__type' | 'trackers__updated_dt' | 'trackers__uuid' | 'updated_dt' | 'uuid'>, psComponent?: string, psModule?: string, resolution?: '' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT', trackersCreatedDt?: string, trackersCreatedDtDate?: string, trackersCreatedDtDateGte?: string, trackersCreatedDtDateLte?: string, trackersCreatedDtGt?: string, trackersCreatedDtGte?: string, trackersCreatedDtLt?: string, trackersCreatedDtLte?: string, trackersEmbargoed?: boolean, trackersExternalSystemId?: string, trackersPsUpdateStream?: string, trackersResolution?: string, trackersStatus?: string, trackersType?: 'BUGZILLA' | 'JIRA', trackersUpdatedDt?: string, trackersUpdatedDtDate?: string, trackersUpdatedDtDateGte?: string, trackersUpdatedDtDateLte?: string, trackersUpdatedDtGt?: string, trackersUpdatedDtGte?: string, trackersUpdatedDtLt?: string, trackersUpdatedDtLte?: string, trackersUuid?: string, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1AffectsList(affectedness, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, cvssScoresComment, cvssScoresCreatedDt, cvssScoresCreatedDtDate, cvssScoresCreatedDtDateGte, cvssScoresCreatedDtDateLte, cvssScoresCreatedDtGt, cvssScoresCreatedDtGte, cvssScoresCreatedDtLt, cvssScoresCreatedDtLte, cvssScoresCvssVersion, cvssScoresIssuer, cvssScoresScore, cvssScoresUpdatedDt, cvssScoresUpdatedDtDate, cvssScoresUpdatedDtDateGte, cvssScoresUpdatedDtDateLte, cvssScoresUpdatedDtGt, cvssScoresUpdatedDtGte, cvssScoresUpdatedDtLt, cvssScoresUpdatedDtLte, cvssScoresUuid, cvssScoresVector, embargoed, excludeFields, flawComponents, flawCreatedDt, flawCreatedDtDate, flawCreatedDtDateGte, flawCreatedDtDateLte, flawCreatedDtGt, flawCreatedDtGte, flawCreatedDtLt, flawCreatedDtLte, flawCveId, flawCweId, flawEmbargoed, flawImpact, flawReportedDt, flawReportedDtDate, flawReportedDtDateGte, flawReportedDtDateLte, flawReportedDtGt, flawReportedDtGte, flawReportedDtLt, flawReportedDtLte, flawSource, flawUnembargoDt, flawUpdatedDt, flawUpdatedDtDate, flawUpdatedDtDateGte, flawUpdatedDtDateLte, flawUpdatedDtGt, flawUpdatedDtGte, flawUpdatedDtLt, flawUpdatedDtLte, flawUuid, impact, includeFields, includeMetaAttr, limit, offset, order, psComponent, psModule, resolution, trackersCreatedDt, trackersCreatedDtDate, trackersCreatedDtDateGte, trackersCreatedDtDateLte, trackersCreatedDtGt, trackersCreatedDtGte, trackersCreatedDtLt, trackersCreatedDtLte, trackersEmbargoed, trackersExternalSystemId, trackersPsUpdateStream, trackersResolution, trackersStatus, trackersType, trackersUpdatedDt, trackersUpdatedDtDate, trackersUpdatedDtDateGte, trackersUpdatedDtDateLte, trackersUpdatedDtGt, trackersUpdatedDtGte, trackersUpdatedDtLt, trackersUpdatedDtLte, trackersUuid, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid A UUID string identifying this Affect.
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1AffectsRetrieve(uuid: string, excludeFields?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1AffectsRetrieve(uuid, excludeFields, includeFields, includeMetaAttr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
     * @param {string} jiraApiKey User generated api key for Jira authentication.
     * @param {string} uuid A UUID string identifying this Affect.
     * @param {Affect} affect 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1AffectsUpdate(bugzillaApiKey: string, jiraApiKey: string, uuid: string, affect: Affect, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1AffectsUpdate(bugzillaApiKey, jiraApiKey, uuid, affect, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List existing alerts for all models.
     * @param {'ERROR' | 'WARNING'} [alertType] 
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] Retrieve only Alerts with the specified name, which is given by the model\&#39;s validation process.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {'affect' | 'affectcvss' | 'flaw' | 'flawacknowledgment' | 'flawcomment' | 'flawcvss' | 'flawreference' | 'package' | 'snippet' | 'tracker'} [parentModel] Retrieve only Alerts related to the specified model, e.g. flaw or affect.
     * @param {string} [parentUuid] Retrieve only Alerts related to a model with the given UUID.
     * @param {string} [uuid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1AlertsList(alertType?: 'ERROR' | 'WARNING', excludeFields?: Array<string>, includeFields?: Array<string>, limit?: number, name?: string, offset?: number, parentModel?: 'affect' | 'affectcvss' | 'flaw' | 'flawacknowledgment' | 'flawcomment' | 'flawcvss' | 'flawreference' | 'package' | 'snippet' | 'tracker', parentUuid?: string, uuid?: string, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1AlertsList(alertType, excludeFields, includeFields, limit, name, offset, parentModel, parentUuid, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid A UUID string identifying this alert.
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1AlertsRetrieve(uuid: string, excludeFields?: Array<string>, includeFields?: Array<string>, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1AlertsRetrieve(uuid, excludeFields, includeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * basic view of audit history events
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [pghCreatedAt] 
     * @param {string} [pghLabel] 
     * @param {string} [pghObjModel] 
     * @param {string} [pghSlug] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1AuditList(limit?: number, offset?: number, pghCreatedAt?: string, pghLabel?: string, pghObjModel?: string, pghSlug?: string, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1AuditList(limit, offset, pghCreatedAt, pghLabel, pghObjModel, pghSlug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * basic view of audit history events
     * @param {string} pghSlug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1AuditRetrieve(pghSlug: string, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1AuditRetrieve(pghSlug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * basic view of audit history events
     * @param {string} pghSlug 
     * @param {Audit} audit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1AuditUpdate(pghSlug: string, audit: Audit, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1AuditUpdate(pghSlug, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
     * @param {string} flawId 
     * @param {FlawAcknowledgmentPost} flawAcknowledgmentPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsAcknowledgmentsCreate(bugzillaApiKey: string, flawId: string, flawAcknowledgmentPost: FlawAcknowledgmentPost, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsAcknowledgmentsCreate(bugzillaApiKey, flawId, flawAcknowledgmentPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Destroy the instance and proxy the delete to Bugzilla
     * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
     * @param {string} flawId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsAcknowledgmentsDestroy(bugzillaApiKey: string, flawId: string, id: string, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsAcknowledgmentsDestroy(bugzillaApiKey, flawId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} flawId 
     * @param {string} [affiliation] 
     * @param {string} [createdDt] 
     * @param {string} [createdDtDate] 
     * @param {string} [createdDtDateGte] 
     * @param {string} [createdDtDateLte] 
     * @param {string} [createdDtGt] 
     * @param {string} [createdDtGte] 
     * @param {string} [createdDtLt] 
     * @param {string} [createdDtLte] 
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {boolean} [fromUpstream] 
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] 
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [updatedDt] 
     * @param {string} [updatedDtDate] 
     * @param {string} [updatedDtDateGte] 
     * @param {string} [updatedDtDateLte] 
     * @param {string} [updatedDtGt] 
     * @param {string} [updatedDtGte] 
     * @param {string} [updatedDtLt] 
     * @param {string} [updatedDtLte] 
     * @param {string} [uuid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsAcknowledgmentsList(flawId: string, affiliation?: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, excludeFields?: Array<string>, fromUpstream?: boolean, includeFields?: Array<string>, limit?: number, name?: string, offset?: number, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsAcknowledgmentsList(flawId, affiliation, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, excludeFields, fromUpstream, includeFields, limit, name, offset, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} flawId 
     * @param {string} id 
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsAcknowledgmentsRetrieve(flawId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsAcknowledgmentsRetrieve(flawId, id, excludeFields, includeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
     * @param {string} flawId 
     * @param {string} id 
     * @param {FlawAcknowledgmentPut} flawAcknowledgmentPut 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsAcknowledgmentsUpdate(bugzillaApiKey: string, flawId: string, id: string, flawAcknowledgmentPut: FlawAcknowledgmentPut, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsAcknowledgmentsUpdate(bugzillaApiKey, flawId, id, flawAcknowledgmentPut, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new comment for a given flaw. Beware that freshly created comments are not guaranteed to keep their original UUIDs, especially if multiple comments are created simultaneously.
     * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
     * @param {string} flawId A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
     * @param {FlawCommentPost} flawCommentPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsCommentsCreate(bugzillaApiKey: string, flawId: string, flawCommentPost: FlawCommentPost, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsCommentsCreate(bugzillaApiKey, flawId, flawCommentPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List existing comments for a given flaw. Beware that freshly created comments are not guaranteed to keep their original UUIDs, especially if multiple comments are created simultaneously.
     * @param {string} flawId A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
     * @param {string} [creator] 
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {string} [externalSystemId] 
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {number} [order] Retrieve only FlawComment resource with the specified order number. Regular flaw comments are numbered from 1 up.
     * @param {string} [uuid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsCommentsList(flawId: string, creator?: string, excludeFields?: Array<string>, externalSystemId?: string, includeFields?: Array<string>, limit?: number, offset?: number, order?: number, uuid?: string, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsCommentsList(flawId, creator, excludeFields, externalSystemId, includeFields, limit, offset, order, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single existing comments for a given flaw. Beware that freshly created comments are not guaranteed to keep their original UUIDs, especially if multiple comments are created simultaneously.
     * @param {string} commentId A string representing the internal OSIDB UUID of the FlawComment resource.
     * @param {string} flawId A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsCommentsRetrieve(commentId: string, flawId: string, excludeFields?: Array<string>, includeFields?: Array<string>, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsCommentsRetrieve(commentId, flawId, excludeFields, includeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
     * @param {string} jiraApiKey User generated api key for Jira authentication.
     * @param {FlawPost} flawPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsCreate(bugzillaApiKey: string, jiraApiKey: string, flawPost: FlawPost, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsCreate(bugzillaApiKey, jiraApiKey, flawPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
     * @param {string} flawId 
     * @param {FlawCVSSPost} flawCVSSPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsCvssScoresCreate(bugzillaApiKey: string, flawId: string, flawCVSSPost: FlawCVSSPost, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsCvssScoresCreate(bugzillaApiKey, flawId, flawCVSSPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Destroy the instance and proxy the delete to Bugzilla
     * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
     * @param {string} flawId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsCvssScoresDestroy(bugzillaApiKey: string, flawId: string, id: string, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsCvssScoresDestroy(bugzillaApiKey, flawId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} flawId 
     * @param {string} [comment] 
     * @param {string} [createdDt] 
     * @param {string} [createdDtDate] 
     * @param {string} [createdDtDateGte] 
     * @param {string} [createdDtDateLte] 
     * @param {string} [createdDtGt] 
     * @param {string} [createdDtGte] 
     * @param {string} [createdDtLt] 
     * @param {string} [createdDtLte] 
     * @param {string} [cvssVersion] 
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {'NIST' | 'OSV' | 'RH'} [issuer] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {number} [score] 
     * @param {string} [updatedDt] 
     * @param {string} [updatedDtDate] 
     * @param {string} [updatedDtDateGte] 
     * @param {string} [updatedDtDateLte] 
     * @param {string} [updatedDtGt] 
     * @param {string} [updatedDtGte] 
     * @param {string} [updatedDtLt] 
     * @param {string} [updatedDtLte] 
     * @param {string} [uuid] 
     * @param {string} [vector] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsCvssScoresList(flawId: string, comment?: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, cvssVersion?: string, excludeFields?: Array<string>, includeFields?: Array<string>, issuer?: 'NIST' | 'OSV' | 'RH', limit?: number, offset?: number, score?: number, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, vector?: string, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsCvssScoresList(flawId, comment, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, cvssVersion, excludeFields, includeFields, issuer, limit, offset, score, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, vector, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} flawId 
     * @param {string} id 
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsCvssScoresRetrieve(flawId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsCvssScoresRetrieve(flawId, id, excludeFields, includeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
     * @param {string} flawId 
     * @param {string} id 
     * @param {FlawCVSSPut} flawCVSSPut 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsCvssScoresUpdate(bugzillaApiKey: string, flawId: string, id: string, flawCVSSPut: FlawCVSSPut, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsCvssScoresUpdate(bugzillaApiKey, flawId, id, flawCVSSPut, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [acknowledgmentsAffiliation] 
     * @param {string} [acknowledgmentsCreatedDt] 
     * @param {string} [acknowledgmentsCreatedDtDate] 
     * @param {string} [acknowledgmentsCreatedDtDateGte] 
     * @param {string} [acknowledgmentsCreatedDtDateLte] 
     * @param {string} [acknowledgmentsCreatedDtGt] 
     * @param {string} [acknowledgmentsCreatedDtGte] 
     * @param {string} [acknowledgmentsCreatedDtLt] 
     * @param {string} [acknowledgmentsCreatedDtLte] 
     * @param {boolean} [acknowledgmentsFromUpstream] 
     * @param {string} [acknowledgmentsName] 
     * @param {string} [acknowledgmentsUpdatedDt] 
     * @param {string} [acknowledgmentsUpdatedDtDate] 
     * @param {string} [acknowledgmentsUpdatedDtDateGte] 
     * @param {string} [acknowledgmentsUpdatedDtDateLte] 
     * @param {string} [acknowledgmentsUpdatedDtGt] 
     * @param {string} [acknowledgmentsUpdatedDtGte] 
     * @param {string} [acknowledgmentsUpdatedDtLt] 
     * @param {string} [acknowledgmentsUpdatedDtLte] 
     * @param {string} [acknowledgmentsUuid] 
     * @param {'' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED'} [affectsAffectedness] 
     * @param {string} [affectsCreatedDt] 
     * @param {string} [affectsCreatedDtDate] 
     * @param {string} [affectsCreatedDtDateGte] 
     * @param {string} [affectsCreatedDtDateLte] 
     * @param {string} [affectsCreatedDtGt] 
     * @param {string} [affectsCreatedDtGte] 
     * @param {string} [affectsCreatedDtLt] 
     * @param {string} [affectsCreatedDtLte] 
     * @param {boolean} [affectsEmbargoed] 
     * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [affectsImpact] 
     * @param {string} [affectsPsComponent] 
     * @param {string} [affectsPsModule] 
     * @param {'' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT'} [affectsResolution] 
     * @param {string} [affectsTrackersCreatedDt] 
     * @param {string} [affectsTrackersCreatedDtDate] 
     * @param {string} [affectsTrackersCreatedDtDateGte] 
     * @param {string} [affectsTrackersCreatedDtDateLte] 
     * @param {string} [affectsTrackersCreatedDtGt] 
     * @param {string} [affectsTrackersCreatedDtGte] 
     * @param {string} [affectsTrackersCreatedDtLt] 
     * @param {string} [affectsTrackersCreatedDtLte] 
     * @param {boolean} [affectsTrackersEmbargoed] 
     * @param {string} [affectsTrackersErrataAdvisoryName] 
     * @param {number} [affectsTrackersErrataEtId] 
     * @param {string} [affectsTrackersErrataShippedDt] 
     * @param {string} [affectsTrackersErrataShippedDtDate] 
     * @param {string} [affectsTrackersErrataShippedDtDateGte] 
     * @param {string} [affectsTrackersErrataShippedDtDateLte] 
     * @param {string} [affectsTrackersErrataShippedDtGt] 
     * @param {string} [affectsTrackersErrataShippedDtGte] 
     * @param {string} [affectsTrackersErrataShippedDtLt] 
     * @param {string} [affectsTrackersErrataShippedDtLte] 
     * @param {string} [affectsTrackersExternalSystemId] 
     * @param {string} [affectsTrackersPsUpdateStream] 
     * @param {string} [affectsTrackersResolution] 
     * @param {string} [affectsTrackersStatus] 
     * @param {'BUGZILLA' | 'JIRA'} [affectsTrackersType] 
     * @param {string} [affectsTrackersUpdatedDt] 
     * @param {string} [affectsTrackersUpdatedDtDate] 
     * @param {string} [affectsTrackersUpdatedDtDateGte] 
     * @param {string} [affectsTrackersUpdatedDtDateLte] 
     * @param {string} [affectsTrackersUpdatedDtGt] 
     * @param {string} [affectsTrackersUpdatedDtGte] 
     * @param {string} [affectsTrackersUpdatedDtLt] 
     * @param {string} [affectsTrackersUpdatedDtLte] 
     * @param {string} [affectsTrackersUuid] 
     * @param {string} [affectsUpdatedDt] 
     * @param {string} [affectsUpdatedDtDate] 
     * @param {string} [affectsUpdatedDtDateGte] 
     * @param {string} [affectsUpdatedDtDateLte] 
     * @param {string} [affectsUpdatedDtGt] 
     * @param {string} [affectsUpdatedDtGte] 
     * @param {string} [affectsUpdatedDtLt] 
     * @param {string} [affectsUpdatedDtLte] 
     * @param {string} [affectsUuid] 
     * @param {number} [bzId] 
     * @param {string} [changedAfter] 
     * @param {string} [changedBefore] 
     * @param {string} [commentZero] 
     * @param {Array<string>} [components] Multiple values may be separated by commas.
     * @param {string} [createdDt] 
     * @param {string} [createdDtDate] 
     * @param {string} [createdDtDateGte] 
     * @param {string} [createdDtDateLte] 
     * @param {string} [createdDtGt] 
     * @param {string} [createdDtGte] 
     * @param {string} [createdDtLt] 
     * @param {string} [createdDtLte] 
     * @param {string} [cveDescription] 
     * @param {boolean} [cveDescriptionIsempty] 
     * @param {Array<string>} [cveId] Multiple values may be separated by commas.
     * @param {boolean} [cveIdIsempty] 
     * @param {boolean} [cvss2NistIsempty] 
     * @param {boolean} [cvss2RhIsempty] 
     * @param {boolean} [cvss3NistIsempty] 
     * @param {boolean} [cvss3RhIsempty] 
     * @param {boolean} [cvss4NistIsempty] 
     * @param {boolean} [cvss4RhIsempty] 
     * @param {string} [cvssScoresComment] 
     * @param {string} [cvssScoresCreatedDt] 
     * @param {string} [cvssScoresCreatedDtDate] 
     * @param {string} [cvssScoresCreatedDtDateGte] 
     * @param {string} [cvssScoresCreatedDtDateLte] 
     * @param {string} [cvssScoresCreatedDtGt] 
     * @param {string} [cvssScoresCreatedDtGte] 
     * @param {string} [cvssScoresCreatedDtLt] 
     * @param {string} [cvssScoresCreatedDtLte] 
     * @param {string} [cvssScoresCvssVersion] 
     * @param {'NIST' | 'OSV' | 'RH'} [cvssScoresIssuer] 
     * @param {number} [cvssScoresScore] 
     * @param {string} [cvssScoresUpdatedDt] 
     * @param {string} [cvssScoresUpdatedDtDate] 
     * @param {string} [cvssScoresUpdatedDtDateGte] 
     * @param {string} [cvssScoresUpdatedDtDateLte] 
     * @param {string} [cvssScoresUpdatedDtGt] 
     * @param {string} [cvssScoresUpdatedDtGte] 
     * @param {string} [cvssScoresUpdatedDtLt] 
     * @param {string} [cvssScoresUpdatedDtLte] 
     * @param {string} [cvssScoresUuid] 
     * @param {string} [cvssScoresVector] 
     * @param {string} [cweId] 
     * @param {boolean} [cweIdIsempty] 
     * @param {boolean} [embargoed] 
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [impact] 
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [majorIncidentStartDt] 
     * @param {string} [majorIncidentStartDtDate] 
     * @param {string} [majorIncidentStartDtDateGte] 
     * @param {string} [majorIncidentStartDtDateLte] 
     * @param {string} [majorIncidentStartDtGt] 
     * @param {string} [majorIncidentStartDtGte] 
     * @param {string} [majorIncidentStartDtLt] 
     * @param {string} [majorIncidentStartDtLte] 
     * @param {'' | 'APPROVED' | 'CISA_APPROVED' | 'INVALID' | 'REJECTED' | 'REQUESTED'} [majorIncidentState] 
     * @param {boolean} [mitigationIsempty] 
     * @param {'' | 'APPROVED' | 'REJECTED' | 'REQUESTED'} [nistCvssValidation] 
     * @param {number} [offset] The initial index from which to return the results.
     * @param {Array<'-acknowledgments__affiliation' | '-acknowledgments__created_dt' | '-acknowledgments__from_upstream' | '-acknowledgments__name' | '-acknowledgments__updated_dt' | '-acknowledgments__uuid' | '-affects__affectedness' | '-affects__created_dt' | '-affects__impact' | '-affects__ps_component' | '-affects__ps_module' | '-affects__resolution' | '-affects__trackers__created_dt' | '-affects__trackers__errata__advisory_name' | '-affects__trackers__errata__et_id' | '-affects__trackers__errata__shipped_dt' | '-affects__trackers__external_system_id' | '-affects__trackers__ps_update_stream' | '-affects__trackers__resolution' | '-affects__trackers__status' | '-affects__trackers__type' | '-affects__trackers__updated_dt' | '-affects__trackers__uuid' | '-affects__updated_dt' | '-affects__uuid' | '-bz_id' | '-comment_zero' | '-components' | '-created_dt' | '-cve_description' | '-cve_id' | '-cvss_scores__comment' | '-cvss_scores__created_dt' | '-cvss_scores__issuer' | '-cvss_scores__score' | '-cvss_scores__updated_dt' | '-cvss_scores__uuid' | '-cvss_scores__vector' | '-cwe_id' | '-embargoed' | '-impact' | '-major_incident_start_dt' | '-major_incident_state' | '-nist_cvss_validation' | '-owner' | '-references__created_dt' | '-references__description' | '-references__type' | '-references__updated_dt' | '-references__url' | '-references__uuid' | '-reported_dt' | '-requires_cve_description' | '-source' | '-statement' | '-team_id' | '-title' | '-unembargo_dt' | '-updated_dt' | '-uuid' | '-workflow_state' | 'acknowledgments__affiliation' | 'acknowledgments__created_dt' | 'acknowledgments__from_upstream' | 'acknowledgments__name' | 'acknowledgments__updated_dt' | 'acknowledgments__uuid' | 'affects__affectedness' | 'affects__created_dt' | 'affects__impact' | 'affects__ps_component' | 'affects__ps_module' | 'affects__resolution' | 'affects__trackers__created_dt' | 'affects__trackers__errata__advisory_name' | 'affects__trackers__errata__et_id' | 'affects__trackers__errata__shipped_dt' | 'affects__trackers__external_system_id' | 'affects__trackers__ps_update_stream' | 'affects__trackers__resolution' | 'affects__trackers__status' | 'affects__trackers__type' | 'affects__trackers__updated_dt' | 'affects__trackers__uuid' | 'affects__updated_dt' | 'affects__uuid' | 'bz_id' | 'comment_zero' | 'components' | 'created_dt' | 'cve_description' | 'cve_id' | 'cvss_scores__comment' | 'cvss_scores__created_dt' | 'cvss_scores__issuer' | 'cvss_scores__score' | 'cvss_scores__updated_dt' | 'cvss_scores__uuid' | 'cvss_scores__vector' | 'cwe_id' | 'embargoed' | 'impact' | 'major_incident_start_dt' | 'major_incident_state' | 'nist_cvss_validation' | 'owner' | 'references__created_dt' | 'references__description' | 'references__type' | 'references__updated_dt' | 'references__url' | 'references__uuid' | 'reported_dt' | 'requires_cve_description' | 'source' | 'statement' | 'team_id' | 'title' | 'unembargo_dt' | 'updated_dt' | 'uuid' | 'workflow_state'>} [order] Ordering
     * @param {string} [owner] 
     * @param {boolean} [ownerIsempty] 
     * @param {string} [referencesCreatedDt] 
     * @param {string} [referencesCreatedDtDate] 
     * @param {string} [referencesCreatedDtDateGte] 
     * @param {string} [referencesCreatedDtDateLte] 
     * @param {string} [referencesCreatedDtGt] 
     * @param {string} [referencesCreatedDtGte] 
     * @param {string} [referencesCreatedDtLt] 
     * @param {string} [referencesCreatedDtLte] 
     * @param {string} [referencesDescription] 
     * @param {'ARTICLE' | 'EXTERNAL' | 'SOURCE'} [referencesType] 
     * @param {string} [referencesUpdatedDt] 
     * @param {string} [referencesUpdatedDtDate] 
     * @param {string} [referencesUpdatedDtDateGte] 
     * @param {string} [referencesUpdatedDtDateLte] 
     * @param {string} [referencesUpdatedDtGt] 
     * @param {string} [referencesUpdatedDtGte] 
     * @param {string} [referencesUpdatedDtLt] 
     * @param {string} [referencesUpdatedDtLte] 
     * @param {string} [referencesUrl] 
     * @param {string} [referencesUuid] 
     * @param {string} [reportedDt] 
     * @param {string} [reportedDtDate] 
     * @param {string} [reportedDtDateGte] 
     * @param {string} [reportedDtDateLte] 
     * @param {string} [reportedDtGt] 
     * @param {string} [reportedDtGte] 
     * @param {string} [reportedDtLt] 
     * @param {string} [reportedDtLte] 
     * @param {'' | 'APPROVED' | 'REJECTED' | 'REQUESTED'} [requiresCveDescription] 
     * @param {string} [search] 
     * @param {'' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'NVD' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'OSV' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF'} [source] 
     * @param {string} [statement] 
     * @param {boolean} [statementIsempty] 
     * @param {string} [teamId] 
     * @param {string} [title] 
     * @param {Array<string>} [trackerIds] Filter only Flaws which are related to specified Trackers (through Affects). Multiple tracker IDs may be separated by commas. Also only Affects that have the specified Trackers related will be shown.
     * @param {string} [unembargoDt] 
     * @param {string} [updatedDt] 
     * @param {string} [updatedDtDate] 
     * @param {string} [updatedDtDateGte] 
     * @param {string} [updatedDtDateLte] 
     * @param {string} [updatedDtGt] 
     * @param {string} [updatedDtGte] 
     * @param {string} [updatedDtLt] 
     * @param {string} [updatedDtLte] 
     * @param {string} [uuid] 
     * @param {Array<'' | 'DONE' | 'NEW' | 'PRE_SECONDARY_ASSESSMENT' | 'REJECTED' | 'SECONDARY_ASSESSMENT' | 'TRIAGE'>} [workflowState] Multiple values may be separated by commas.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsList(acknowledgmentsAffiliation?: string, acknowledgmentsCreatedDt?: string, acknowledgmentsCreatedDtDate?: string, acknowledgmentsCreatedDtDateGte?: string, acknowledgmentsCreatedDtDateLte?: string, acknowledgmentsCreatedDtGt?: string, acknowledgmentsCreatedDtGte?: string, acknowledgmentsCreatedDtLt?: string, acknowledgmentsCreatedDtLte?: string, acknowledgmentsFromUpstream?: boolean, acknowledgmentsName?: string, acknowledgmentsUpdatedDt?: string, acknowledgmentsUpdatedDtDate?: string, acknowledgmentsUpdatedDtDateGte?: string, acknowledgmentsUpdatedDtDateLte?: string, acknowledgmentsUpdatedDtGt?: string, acknowledgmentsUpdatedDtGte?: string, acknowledgmentsUpdatedDtLt?: string, acknowledgmentsUpdatedDtLte?: string, acknowledgmentsUuid?: string, affectsAffectedness?: '' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED', affectsCreatedDt?: string, affectsCreatedDtDate?: string, affectsCreatedDtDateGte?: string, affectsCreatedDtDateLte?: string, affectsCreatedDtGt?: string, affectsCreatedDtGte?: string, affectsCreatedDtLt?: string, affectsCreatedDtLte?: string, affectsEmbargoed?: boolean, affectsImpact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', affectsPsComponent?: string, affectsPsModule?: string, affectsResolution?: '' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT', affectsTrackersCreatedDt?: string, affectsTrackersCreatedDtDate?: string, affectsTrackersCreatedDtDateGte?: string, affectsTrackersCreatedDtDateLte?: string, affectsTrackersCreatedDtGt?: string, affectsTrackersCreatedDtGte?: string, affectsTrackersCreatedDtLt?: string, affectsTrackersCreatedDtLte?: string, affectsTrackersEmbargoed?: boolean, affectsTrackersErrataAdvisoryName?: string, affectsTrackersErrataEtId?: number, affectsTrackersErrataShippedDt?: string, affectsTrackersErrataShippedDtDate?: string, affectsTrackersErrataShippedDtDateGte?: string, affectsTrackersErrataShippedDtDateLte?: string, affectsTrackersErrataShippedDtGt?: string, affectsTrackersErrataShippedDtGte?: string, affectsTrackersErrataShippedDtLt?: string, affectsTrackersErrataShippedDtLte?: string, affectsTrackersExternalSystemId?: string, affectsTrackersPsUpdateStream?: string, affectsTrackersResolution?: string, affectsTrackersStatus?: string, affectsTrackersType?: 'BUGZILLA' | 'JIRA', affectsTrackersUpdatedDt?: string, affectsTrackersUpdatedDtDate?: string, affectsTrackersUpdatedDtDateGte?: string, affectsTrackersUpdatedDtDateLte?: string, affectsTrackersUpdatedDtGt?: string, affectsTrackersUpdatedDtGte?: string, affectsTrackersUpdatedDtLt?: string, affectsTrackersUpdatedDtLte?: string, affectsTrackersUuid?: string, affectsUpdatedDt?: string, affectsUpdatedDtDate?: string, affectsUpdatedDtDateGte?: string, affectsUpdatedDtDateLte?: string, affectsUpdatedDtGt?: string, affectsUpdatedDtGte?: string, affectsUpdatedDtLt?: string, affectsUpdatedDtLte?: string, affectsUuid?: string, bzId?: number, changedAfter?: string, changedBefore?: string, commentZero?: string, components?: Array<string>, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, cveDescription?: string, cveDescriptionIsempty?: boolean, cveId?: Array<string>, cveIdIsempty?: boolean, cvss2NistIsempty?: boolean, cvss2RhIsempty?: boolean, cvss3NistIsempty?: boolean, cvss3RhIsempty?: boolean, cvss4NistIsempty?: boolean, cvss4RhIsempty?: boolean, cvssScoresComment?: string, cvssScoresCreatedDt?: string, cvssScoresCreatedDtDate?: string, cvssScoresCreatedDtDateGte?: string, cvssScoresCreatedDtDateLte?: string, cvssScoresCreatedDtGt?: string, cvssScoresCreatedDtGte?: string, cvssScoresCreatedDtLt?: string, cvssScoresCreatedDtLte?: string, cvssScoresCvssVersion?: string, cvssScoresIssuer?: 'NIST' | 'OSV' | 'RH', cvssScoresScore?: number, cvssScoresUpdatedDt?: string, cvssScoresUpdatedDtDate?: string, cvssScoresUpdatedDtDateGte?: string, cvssScoresUpdatedDtDateLte?: string, cvssScoresUpdatedDtGt?: string, cvssScoresUpdatedDtGte?: string, cvssScoresUpdatedDtLt?: string, cvssScoresUpdatedDtLte?: string, cvssScoresUuid?: string, cvssScoresVector?: string, cweId?: string, cweIdIsempty?: boolean, embargoed?: boolean, excludeFields?: Array<string>, impact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', includeFields?: Array<string>, includeMetaAttr?: Array<string>, limit?: number, majorIncidentStartDt?: string, majorIncidentStartDtDate?: string, majorIncidentStartDtDateGte?: string, majorIncidentStartDtDateLte?: string, majorIncidentStartDtGt?: string, majorIncidentStartDtGte?: string, majorIncidentStartDtLt?: string, majorIncidentStartDtLte?: string, majorIncidentState?: '' | 'APPROVED' | 'CISA_APPROVED' | 'INVALID' | 'REJECTED' | 'REQUESTED', mitigationIsempty?: boolean, nistCvssValidation?: '' | 'APPROVED' | 'REJECTED' | 'REQUESTED', offset?: number, order?: Array<'-acknowledgments__affiliation' | '-acknowledgments__created_dt' | '-acknowledgments__from_upstream' | '-acknowledgments__name' | '-acknowledgments__updated_dt' | '-acknowledgments__uuid' | '-affects__affectedness' | '-affects__created_dt' | '-affects__impact' | '-affects__ps_component' | '-affects__ps_module' | '-affects__resolution' | '-affects__trackers__created_dt' | '-affects__trackers__errata__advisory_name' | '-affects__trackers__errata__et_id' | '-affects__trackers__errata__shipped_dt' | '-affects__trackers__external_system_id' | '-affects__trackers__ps_update_stream' | '-affects__trackers__resolution' | '-affects__trackers__status' | '-affects__trackers__type' | '-affects__trackers__updated_dt' | '-affects__trackers__uuid' | '-affects__updated_dt' | '-affects__uuid' | '-bz_id' | '-comment_zero' | '-components' | '-created_dt' | '-cve_description' | '-cve_id' | '-cvss_scores__comment' | '-cvss_scores__created_dt' | '-cvss_scores__issuer' | '-cvss_scores__score' | '-cvss_scores__updated_dt' | '-cvss_scores__uuid' | '-cvss_scores__vector' | '-cwe_id' | '-embargoed' | '-impact' | '-major_incident_start_dt' | '-major_incident_state' | '-nist_cvss_validation' | '-owner' | '-references__created_dt' | '-references__description' | '-references__type' | '-references__updated_dt' | '-references__url' | '-references__uuid' | '-reported_dt' | '-requires_cve_description' | '-source' | '-statement' | '-team_id' | '-title' | '-unembargo_dt' | '-updated_dt' | '-uuid' | '-workflow_state' | 'acknowledgments__affiliation' | 'acknowledgments__created_dt' | 'acknowledgments__from_upstream' | 'acknowledgments__name' | 'acknowledgments__updated_dt' | 'acknowledgments__uuid' | 'affects__affectedness' | 'affects__created_dt' | 'affects__impact' | 'affects__ps_component' | 'affects__ps_module' | 'affects__resolution' | 'affects__trackers__created_dt' | 'affects__trackers__errata__advisory_name' | 'affects__trackers__errata__et_id' | 'affects__trackers__errata__shipped_dt' | 'affects__trackers__external_system_id' | 'affects__trackers__ps_update_stream' | 'affects__trackers__resolution' | 'affects__trackers__status' | 'affects__trackers__type' | 'affects__trackers__updated_dt' | 'affects__trackers__uuid' | 'affects__updated_dt' | 'affects__uuid' | 'bz_id' | 'comment_zero' | 'components' | 'created_dt' | 'cve_description' | 'cve_id' | 'cvss_scores__comment' | 'cvss_scores__created_dt' | 'cvss_scores__issuer' | 'cvss_scores__score' | 'cvss_scores__updated_dt' | 'cvss_scores__uuid' | 'cvss_scores__vector' | 'cwe_id' | 'embargoed' | 'impact' | 'major_incident_start_dt' | 'major_incident_state' | 'nist_cvss_validation' | 'owner' | 'references__created_dt' | 'references__description' | 'references__type' | 'references__updated_dt' | 'references__url' | 'references__uuid' | 'reported_dt' | 'requires_cve_description' | 'source' | 'statement' | 'team_id' | 'title' | 'unembargo_dt' | 'updated_dt' | 'uuid' | 'workflow_state'>, owner?: string, ownerIsempty?: boolean, referencesCreatedDt?: string, referencesCreatedDtDate?: string, referencesCreatedDtDateGte?: string, referencesCreatedDtDateLte?: string, referencesCreatedDtGt?: string, referencesCreatedDtGte?: string, referencesCreatedDtLt?: string, referencesCreatedDtLte?: string, referencesDescription?: string, referencesType?: 'ARTICLE' | 'EXTERNAL' | 'SOURCE', referencesUpdatedDt?: string, referencesUpdatedDtDate?: string, referencesUpdatedDtDateGte?: string, referencesUpdatedDtDateLte?: string, referencesUpdatedDtGt?: string, referencesUpdatedDtGte?: string, referencesUpdatedDtLt?: string, referencesUpdatedDtLte?: string, referencesUrl?: string, referencesUuid?: string, reportedDt?: string, reportedDtDate?: string, reportedDtDateGte?: string, reportedDtDateLte?: string, reportedDtGt?: string, reportedDtGte?: string, reportedDtLt?: string, reportedDtLte?: string, requiresCveDescription?: '' | 'APPROVED' | 'REJECTED' | 'REQUESTED', search?: string, source?: '' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'NVD' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'OSV' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF', statement?: string, statementIsempty?: boolean, teamId?: string, title?: string, trackerIds?: Array<string>, unembargoDt?: string, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, workflowState?: Array<'' | 'DONE' | 'NEW' | 'PRE_SECONDARY_ASSESSMENT' | 'REJECTED' | 'SECONDARY_ASSESSMENT' | 'TRIAGE'>, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsList(acknowledgmentsAffiliation, acknowledgmentsCreatedDt, acknowledgmentsCreatedDtDate, acknowledgmentsCreatedDtDateGte, acknowledgmentsCreatedDtDateLte, acknowledgmentsCreatedDtGt, acknowledgmentsCreatedDtGte, acknowledgmentsCreatedDtLt, acknowledgmentsCreatedDtLte, acknowledgmentsFromUpstream, acknowledgmentsName, acknowledgmentsUpdatedDt, acknowledgmentsUpdatedDtDate, acknowledgmentsUpdatedDtDateGte, acknowledgmentsUpdatedDtDateLte, acknowledgmentsUpdatedDtGt, acknowledgmentsUpdatedDtGte, acknowledgmentsUpdatedDtLt, acknowledgmentsUpdatedDtLte, acknowledgmentsUuid, affectsAffectedness, affectsCreatedDt, affectsCreatedDtDate, affectsCreatedDtDateGte, affectsCreatedDtDateLte, affectsCreatedDtGt, affectsCreatedDtGte, affectsCreatedDtLt, affectsCreatedDtLte, affectsEmbargoed, affectsImpact, affectsPsComponent, affectsPsModule, affectsResolution, affectsTrackersCreatedDt, affectsTrackersCreatedDtDate, affectsTrackersCreatedDtDateGte, affectsTrackersCreatedDtDateLte, affectsTrackersCreatedDtGt, affectsTrackersCreatedDtGte, affectsTrackersCreatedDtLt, affectsTrackersCreatedDtLte, affectsTrackersEmbargoed, affectsTrackersErrataAdvisoryName, affectsTrackersErrataEtId, affectsTrackersErrataShippedDt, affectsTrackersErrataShippedDtDate, affectsTrackersErrataShippedDtDateGte, affectsTrackersErrataShippedDtDateLte, affectsTrackersErrataShippedDtGt, affectsTrackersErrataShippedDtGte, affectsTrackersErrataShippedDtLt, affectsTrackersErrataShippedDtLte, affectsTrackersExternalSystemId, affectsTrackersPsUpdateStream, affectsTrackersResolution, affectsTrackersStatus, affectsTrackersType, affectsTrackersUpdatedDt, affectsTrackersUpdatedDtDate, affectsTrackersUpdatedDtDateGte, affectsTrackersUpdatedDtDateLte, affectsTrackersUpdatedDtGt, affectsTrackersUpdatedDtGte, affectsTrackersUpdatedDtLt, affectsTrackersUpdatedDtLte, affectsTrackersUuid, affectsUpdatedDt, affectsUpdatedDtDate, affectsUpdatedDtDateGte, affectsUpdatedDtDateLte, affectsUpdatedDtGt, affectsUpdatedDtGte, affectsUpdatedDtLt, affectsUpdatedDtLte, affectsUuid, bzId, changedAfter, changedBefore, commentZero, components, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, cveDescription, cveDescriptionIsempty, cveId, cveIdIsempty, cvss2NistIsempty, cvss2RhIsempty, cvss3NistIsempty, cvss3RhIsempty, cvss4NistIsempty, cvss4RhIsempty, cvssScoresComment, cvssScoresCreatedDt, cvssScoresCreatedDtDate, cvssScoresCreatedDtDateGte, cvssScoresCreatedDtDateLte, cvssScoresCreatedDtGt, cvssScoresCreatedDtGte, cvssScoresCreatedDtLt, cvssScoresCreatedDtLte, cvssScoresCvssVersion, cvssScoresIssuer, cvssScoresScore, cvssScoresUpdatedDt, cvssScoresUpdatedDtDate, cvssScoresUpdatedDtDateGte, cvssScoresUpdatedDtDateLte, cvssScoresUpdatedDtGt, cvssScoresUpdatedDtGte, cvssScoresUpdatedDtLt, cvssScoresUpdatedDtLte, cvssScoresUuid, cvssScoresVector, cweId, cweIdIsempty, embargoed, excludeFields, impact, includeFields, includeMetaAttr, limit, majorIncidentStartDt, majorIncidentStartDtDate, majorIncidentStartDtDateGte, majorIncidentStartDtDateLte, majorIncidentStartDtGt, majorIncidentStartDtGte, majorIncidentStartDtLt, majorIncidentStartDtLte, majorIncidentState, mitigationIsempty, nistCvssValidation, offset, order, owner, ownerIsempty, referencesCreatedDt, referencesCreatedDtDate, referencesCreatedDtDateGte, referencesCreatedDtDateLte, referencesCreatedDtGt, referencesCreatedDtGte, referencesCreatedDtLt, referencesCreatedDtLte, referencesDescription, referencesType, referencesUpdatedDt, referencesUpdatedDtDate, referencesUpdatedDtDateGte, referencesUpdatedDtDateLte, referencesUpdatedDtGt, referencesUpdatedDtGte, referencesUpdatedDtLt, referencesUpdatedDtLte, referencesUrl, referencesUuid, reportedDt, reportedDtDate, reportedDtDateGte, reportedDtDateLte, reportedDtGt, reportedDtGte, reportedDtLt, reportedDtLte, requiresCveDescription, search, source, statement, statementIsempty, teamId, title, trackerIds, unembargoDt, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, workflowState, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
     * @param {string} flawId 
     * @param {FlawPackageVersionPost} flawPackageVersionPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsPackageVersionsCreate(bugzillaApiKey: string, flawId: string, flawPackageVersionPost: FlawPackageVersionPost, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsPackageVersionsCreate(bugzillaApiKey, flawId, flawPackageVersionPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Destroy the instance and proxy the delete to Bugzilla
     * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
     * @param {string} flawId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsPackageVersionsDestroy(bugzillaApiKey: string, flawId: string, id: string, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsPackageVersionsDestroy(bugzillaApiKey, flawId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} flawId 
     * @param {string} [createdDt] 
     * @param {string} [createdDtDate] 
     * @param {string} [createdDtDateGte] 
     * @param {string} [createdDtDateLte] 
     * @param {string} [createdDtGt] 
     * @param {string} [createdDtGte] 
     * @param {string} [createdDtLt] 
     * @param {string} [createdDtLte] 
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [_package] 
     * @param {string} [updatedDt] 
     * @param {string} [updatedDtDate] 
     * @param {string} [updatedDtDateGte] 
     * @param {string} [updatedDtDateLte] 
     * @param {string} [updatedDtGt] 
     * @param {string} [updatedDtGte] 
     * @param {string} [updatedDtLt] 
     * @param {string} [updatedDtLte] 
     * @param {string} [uuid] 
     * @param {string} [versionsVersion] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsPackageVersionsList(flawId: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, excludeFields?: Array<string>, includeFields?: Array<string>, limit?: number, offset?: number, _package?: string, updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, versionsVersion?: string, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsPackageVersionsList(flawId, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, excludeFields, includeFields, limit, offset, _package, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, versionsVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} flawId 
     * @param {string} id 
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsPackageVersionsRetrieve(flawId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsPackageVersionsRetrieve(flawId, id, excludeFields, includeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
     * @param {string} flawId 
     * @param {string} id 
     * @param {FlawPackageVersionPut} flawPackageVersionPut 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsPackageVersionsUpdate(bugzillaApiKey: string, flawId: string, id: string, flawPackageVersionPut: FlawPackageVersionPut, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsPackageVersionsUpdate(bugzillaApiKey, flawId, id, flawPackageVersionPut, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * workflow promotion API endpoint  try to adjust workflow classification of flaw to the next state available return its workflow:state classification or errors if not possible to promote
     * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
     * @param {string} jiraApiKey User generated api key for Jira authentication.
     * @param {string} flawId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsPromoteCreate(bugzillaApiKey: string, jiraApiKey: string, flawId: string, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsPromoteCreate(bugzillaApiKey, jiraApiKey, flawId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
     * @param {string} flawId 
     * @param {FlawReferencePost} flawReferencePost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsReferencesCreate(bugzillaApiKey: string, flawId: string, flawReferencePost: FlawReferencePost, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsReferencesCreate(bugzillaApiKey, flawId, flawReferencePost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Destroy the instance and proxy the delete to Bugzilla
     * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
     * @param {string} flawId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsReferencesDestroy(bugzillaApiKey: string, flawId: string, id: string, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsReferencesDestroy(bugzillaApiKey, flawId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} flawId 
     * @param {string} [createdDt] 
     * @param {string} [createdDtDate] 
     * @param {string} [createdDtDateGte] 
     * @param {string} [createdDtDateLte] 
     * @param {string} [createdDtGt] 
     * @param {string} [createdDtGte] 
     * @param {string} [createdDtLt] 
     * @param {string} [createdDtLte] 
     * @param {string} [description] 
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {'ARTICLE' | 'EXTERNAL' | 'SOURCE'} [type] 
     * @param {string} [updatedDt] 
     * @param {string} [updatedDtDate] 
     * @param {string} [updatedDtDateGte] 
     * @param {string} [updatedDtDateLte] 
     * @param {string} [updatedDtGt] 
     * @param {string} [updatedDtGte] 
     * @param {string} [updatedDtLt] 
     * @param {string} [updatedDtLte] 
     * @param {string} [url] 
     * @param {string} [uuid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsReferencesList(flawId: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, description?: string, excludeFields?: Array<string>, includeFields?: Array<string>, limit?: number, offset?: number, type?: 'ARTICLE' | 'EXTERNAL' | 'SOURCE', updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, url?: string, uuid?: string, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsReferencesList(flawId, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, description, excludeFields, includeFields, limit, offset, type, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, url, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} flawId 
     * @param {string} id 
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsReferencesRetrieve(flawId: string, id: string, excludeFields?: Array<string>, includeFields?: Array<string>, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsReferencesRetrieve(flawId, id, excludeFields, includeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
     * @param {string} flawId 
     * @param {string} id 
     * @param {FlawReferencePut} flawReferencePut 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsReferencesUpdate(bugzillaApiKey: string, flawId: string, id: string, flawReferencePut: FlawReferencePut, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsReferencesUpdate(bugzillaApiKey, flawId, id, flawReferencePut, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * workflow promotion API endpoint  try to reject a flaw / task
     * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
     * @param {string} jiraApiKey User generated api key for Jira authentication.
     * @param {string} flawId 
     * @param {Reject} reject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsRejectCreate(bugzillaApiKey: string, jiraApiKey: string, flawId: string, reject: Reject, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsRejectCreate(bugzillaApiKey, jiraApiKey, flawId, reject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
     * @param {Array<string>} [trackerIds] Filter only Flaws which are related to specified Trackers (through Affects). Multiple tracker IDs may be separated by commas. Also only Affects that have the specified Trackers related will be shown.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsRetrieve(id: string, excludeFields?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, trackerIds?: Array<string>, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsRetrieve(id, excludeFields, includeFields, includeMetaAttr, trackerIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
     * @param {string} jiraApiKey User generated api key for Jira authentication.
     * @param {string} id A string representing either the internal OSIDB UUID of the Flaw resource or the CVE number corresponding to a Flaw
     * @param {Flaw} flaw 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1FlawsUpdate(bugzillaApiKey: string, jiraApiKey: string, id: string, flaw: Flaw, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1FlawsUpdate(bugzillaApiKey, jiraApiKey, id, flaw, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HTTP get /manifest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1ManifestRetrieve(options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1ManifestRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
     * @param {'json' | 'yaml'} [format] 
     * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1SchemaRetrieve(format?: 'json' | 'yaml', lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1SchemaRetrieve(format, lang, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HTTP get /status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1StatusRetrieve(options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1StatusRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
     * @param {string} jiraApiKey User generated api key for Jira authentication.
     * @param {TrackerPost} trackerPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1TrackersCreate(bugzillaApiKey: string, jiraApiKey: string, trackerPost: TrackerPost, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1TrackersCreate(bugzillaApiKey, jiraApiKey, trackerPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {'' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED'} [affectsAffectedness] 
     * @param {string} [affectsCreatedDt] 
     * @param {string} [affectsCreatedDtDate] 
     * @param {string} [affectsCreatedDtDateGte] 
     * @param {string} [affectsCreatedDtDateLte] 
     * @param {string} [affectsCreatedDtGt] 
     * @param {string} [affectsCreatedDtGte] 
     * @param {string} [affectsCreatedDtLt] 
     * @param {string} [affectsCreatedDtLte] 
     * @param {boolean} [affectsEmbargoed] 
     * @param {Array<string>} [affectsFlawComponents] Multiple values may be separated by commas.
     * @param {string} [affectsFlawCreatedDt] 
     * @param {string} [affectsFlawCreatedDtDate] 
     * @param {string} [affectsFlawCreatedDtDateGte] 
     * @param {string} [affectsFlawCreatedDtDateLte] 
     * @param {string} [affectsFlawCreatedDtGt] 
     * @param {string} [affectsFlawCreatedDtGte] 
     * @param {string} [affectsFlawCreatedDtLt] 
     * @param {string} [affectsFlawCreatedDtLte] 
     * @param {string} [affectsFlawCveId] 
     * @param {string} [affectsFlawCweId] 
     * @param {boolean} [affectsFlawEmbargoed] 
     * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [affectsFlawImpact] 
     * @param {string} [affectsFlawReportedDt] 
     * @param {string} [affectsFlawReportedDtDate] 
     * @param {string} [affectsFlawReportedDtDateGte] 
     * @param {string} [affectsFlawReportedDtDateLte] 
     * @param {string} [affectsFlawReportedDtGt] 
     * @param {string} [affectsFlawReportedDtGte] 
     * @param {string} [affectsFlawReportedDtLt] 
     * @param {string} [affectsFlawReportedDtLte] 
     * @param {'' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'NVD' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'OSV' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF'} [affectsFlawSource] 
     * @param {string} [affectsFlawUnembargoDt] 
     * @param {string} [affectsFlawUpdatedDt] 
     * @param {string} [affectsFlawUpdatedDtDate] 
     * @param {string} [affectsFlawUpdatedDtDateGte] 
     * @param {string} [affectsFlawUpdatedDtDateLte] 
     * @param {string} [affectsFlawUpdatedDtGt] 
     * @param {string} [affectsFlawUpdatedDtGte] 
     * @param {string} [affectsFlawUpdatedDtLt] 
     * @param {string} [affectsFlawUpdatedDtLte] 
     * @param {string} [affectsFlawUuid] 
     * @param {'' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE'} [affectsImpact] 
     * @param {string} [affectsPsComponent] 
     * @param {string} [affectsPsModule] 
     * @param {'' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT'} [affectsResolution] 
     * @param {string} [affectsUpdatedDt] 
     * @param {string} [affectsUpdatedDtDate] 
     * @param {string} [affectsUpdatedDtDateGte] 
     * @param {string} [affectsUpdatedDtDateLte] 
     * @param {string} [affectsUpdatedDtGt] 
     * @param {string} [affectsUpdatedDtGte] 
     * @param {string} [affectsUpdatedDtLt] 
     * @param {string} [affectsUpdatedDtLte] 
     * @param {string} [affectsUuid] 
     * @param {string} [createdDt] 
     * @param {string} [createdDtDate] 
     * @param {string} [createdDtDateGte] 
     * @param {string} [createdDtDateLte] 
     * @param {string} [createdDtGt] 
     * @param {string} [createdDtGte] 
     * @param {string} [createdDtLt] 
     * @param {string} [createdDtLte] 
     * @param {boolean} [embargoed] 
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {string} [externalSystemId] 
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {Array<'-affects__affectedness' | '-affects__created_dt' | '-affects__embargoed' | '-affects__flaw__components' | '-affects__flaw__created_dt' | '-affects__flaw__cve_id' | '-affects__flaw__cwe_id' | '-affects__flaw__embargoed' | '-affects__flaw__impact' | '-affects__flaw__reported_dt' | '-affects__flaw__source' | '-affects__flaw__unembargo_dt' | '-affects__flaw__updated_dt' | '-affects__flaw__uuid' | '-affects__impact' | '-affects__ps_component' | '-affects__ps_module' | '-affects__resolution' | '-affects__updated_dt' | '-affects__uuid' | '-created_dt' | '-embargoed' | '-external_system_id' | '-ps_update_stream' | '-resolution' | '-status' | '-type' | '-updated_dt' | '-uuid' | 'affects__affectedness' | 'affects__created_dt' | 'affects__embargoed' | 'affects__flaw__components' | 'affects__flaw__created_dt' | 'affects__flaw__cve_id' | 'affects__flaw__cwe_id' | 'affects__flaw__embargoed' | 'affects__flaw__impact' | 'affects__flaw__reported_dt' | 'affects__flaw__source' | 'affects__flaw__unembargo_dt' | 'affects__flaw__updated_dt' | 'affects__flaw__uuid' | 'affects__impact' | 'affects__ps_component' | 'affects__ps_module' | 'affects__resolution' | 'affects__updated_dt' | 'affects__uuid' | 'created_dt' | 'embargoed' | 'external_system_id' | 'ps_update_stream' | 'resolution' | 'status' | 'type' | 'updated_dt' | 'uuid'>} [order] Ordering
     * @param {string} [psUpdateStream] 
     * @param {string} [resolution] 
     * @param {string} [status] 
     * @param {'BUGZILLA' | 'JIRA'} [type] 
     * @param {string} [updatedDt] 
     * @param {string} [updatedDtDate] 
     * @param {string} [updatedDtDateGte] 
     * @param {string} [updatedDtDateLte] 
     * @param {string} [updatedDtGt] 
     * @param {string} [updatedDtGte] 
     * @param {string} [updatedDtLt] 
     * @param {string} [updatedDtLte] 
     * @param {string} [uuid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1TrackersList(affectsAffectedness?: '' | 'AFFECTED' | 'NEW' | 'NOTAFFECTED', affectsCreatedDt?: string, affectsCreatedDtDate?: string, affectsCreatedDtDateGte?: string, affectsCreatedDtDateLte?: string, affectsCreatedDtGt?: string, affectsCreatedDtGte?: string, affectsCreatedDtLt?: string, affectsCreatedDtLte?: string, affectsEmbargoed?: boolean, affectsFlawComponents?: Array<string>, affectsFlawCreatedDt?: string, affectsFlawCreatedDtDate?: string, affectsFlawCreatedDtDateGte?: string, affectsFlawCreatedDtDateLte?: string, affectsFlawCreatedDtGt?: string, affectsFlawCreatedDtGte?: string, affectsFlawCreatedDtLt?: string, affectsFlawCreatedDtLte?: string, affectsFlawCveId?: string, affectsFlawCweId?: string, affectsFlawEmbargoed?: boolean, affectsFlawImpact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', affectsFlawReportedDt?: string, affectsFlawReportedDtDate?: string, affectsFlawReportedDtDateGte?: string, affectsFlawReportedDtDateLte?: string, affectsFlawReportedDtGt?: string, affectsFlawReportedDtGte?: string, affectsFlawReportedDtLt?: string, affectsFlawReportedDtLte?: string, affectsFlawSource?: '' | 'ADOBE' | 'APPLE' | 'ASF' | 'BIND' | 'BK' | 'BUGTRAQ' | 'BUGZILLA' | 'CERT' | 'CERTIFI' | 'CORELABS' | 'CUSTOMER' | 'CVE' | 'DAILYDAVE' | 'DEBIAN' | 'DISTROS' | 'FEDORA' | 'FETCHMAIL' | 'FREEDESKTOP' | 'FREERADIUS' | 'FRSIRT' | 'FULLDISCLOSURE' | 'GAIM' | 'GENTOO' | 'GENTOOBZ' | 'GIT' | 'GNOME' | 'GNUPG' | 'GOOGLE' | 'HP' | 'HW_VENDOR' | 'IBM' | 'IDEFENSE' | 'INTERNET' | 'ISC' | 'ISEC' | 'IT' | 'JBOSS' | 'JPCERT' | 'KERNELBUGZILLA' | 'KERNELSEC' | 'LKML' | 'LWN' | 'MACROMEDIA' | 'MAGEIA' | 'MAILINGLIST' | 'MILW0RM' | 'MIT' | 'MITRE' | 'MOZILLA' | 'MUTTDEV' | 'NETDEV' | 'NISCC' | 'NVD' | 'OCERT' | 'OPENOFFICE' | 'OPENSSL' | 'OPENSUSE' | 'ORACLE' | 'OSS' | 'OSSSECURITY' | 'OSV' | 'PHP' | 'PIDGIN' | 'POSTGRESQL' | 'PRESS' | 'REAL' | 'REDHAT' | 'RESEARCHER' | 'RT' | 'SAMBA' | 'SECALERT' | 'SECUNIA' | 'SECURITYFOCUS' | 'SKO' | 'SQUID' | 'SQUIRRELMAIL' | 'SUN' | 'SUNSOLVE' | 'SUSE' | 'TWITTER' | 'UBUNTU' | 'UPSTREAM' | 'VENDORSEC' | 'VULNWATCH' | 'WIRESHARK' | 'XCHAT' | 'XEN' | 'XPDF', affectsFlawUnembargoDt?: string, affectsFlawUpdatedDt?: string, affectsFlawUpdatedDtDate?: string, affectsFlawUpdatedDtDateGte?: string, affectsFlawUpdatedDtDateLte?: string, affectsFlawUpdatedDtGt?: string, affectsFlawUpdatedDtGte?: string, affectsFlawUpdatedDtLt?: string, affectsFlawUpdatedDtLte?: string, affectsFlawUuid?: string, affectsImpact?: '' | 'CRITICAL' | 'IMPORTANT' | 'LOW' | 'MODERATE', affectsPsComponent?: string, affectsPsModule?: string, affectsResolution?: '' | 'DEFER' | 'DELEGATED' | 'FIX' | 'OOSS' | 'WONTFIX' | 'WONTREPORT', affectsUpdatedDt?: string, affectsUpdatedDtDate?: string, affectsUpdatedDtDateGte?: string, affectsUpdatedDtDateLte?: string, affectsUpdatedDtGt?: string, affectsUpdatedDtGte?: string, affectsUpdatedDtLt?: string, affectsUpdatedDtLte?: string, affectsUuid?: string, createdDt?: string, createdDtDate?: string, createdDtDateGte?: string, createdDtDateLte?: string, createdDtGt?: string, createdDtGte?: string, createdDtLt?: string, createdDtLte?: string, embargoed?: boolean, excludeFields?: Array<string>, externalSystemId?: string, includeFields?: Array<string>, includeMetaAttr?: Array<string>, limit?: number, offset?: number, order?: Array<'-affects__affectedness' | '-affects__created_dt' | '-affects__embargoed' | '-affects__flaw__components' | '-affects__flaw__created_dt' | '-affects__flaw__cve_id' | '-affects__flaw__cwe_id' | '-affects__flaw__embargoed' | '-affects__flaw__impact' | '-affects__flaw__reported_dt' | '-affects__flaw__source' | '-affects__flaw__unembargo_dt' | '-affects__flaw__updated_dt' | '-affects__flaw__uuid' | '-affects__impact' | '-affects__ps_component' | '-affects__ps_module' | '-affects__resolution' | '-affects__updated_dt' | '-affects__uuid' | '-created_dt' | '-embargoed' | '-external_system_id' | '-ps_update_stream' | '-resolution' | '-status' | '-type' | '-updated_dt' | '-uuid' | 'affects__affectedness' | 'affects__created_dt' | 'affects__embargoed' | 'affects__flaw__components' | 'affects__flaw__created_dt' | 'affects__flaw__cve_id' | 'affects__flaw__cwe_id' | 'affects__flaw__embargoed' | 'affects__flaw__impact' | 'affects__flaw__reported_dt' | 'affects__flaw__source' | 'affects__flaw__unembargo_dt' | 'affects__flaw__updated_dt' | 'affects__flaw__uuid' | 'affects__impact' | 'affects__ps_component' | 'affects__ps_module' | 'affects__resolution' | 'affects__updated_dt' | 'affects__uuid' | 'created_dt' | 'embargoed' | 'external_system_id' | 'ps_update_stream' | 'resolution' | 'status' | 'type' | 'updated_dt' | 'uuid'>, psUpdateStream?: string, resolution?: string, status?: string, type?: 'BUGZILLA' | 'JIRA', updatedDt?: string, updatedDtDate?: string, updatedDtDateGte?: string, updatedDtDateLte?: string, updatedDtGt?: string, updatedDtGte?: string, updatedDtLt?: string, updatedDtLte?: string, uuid?: string, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1TrackersList(affectsAffectedness, affectsCreatedDt, affectsCreatedDtDate, affectsCreatedDtDateGte, affectsCreatedDtDateLte, affectsCreatedDtGt, affectsCreatedDtGte, affectsCreatedDtLt, affectsCreatedDtLte, affectsEmbargoed, affectsFlawComponents, affectsFlawCreatedDt, affectsFlawCreatedDtDate, affectsFlawCreatedDtDateGte, affectsFlawCreatedDtDateLte, affectsFlawCreatedDtGt, affectsFlawCreatedDtGte, affectsFlawCreatedDtLt, affectsFlawCreatedDtLte, affectsFlawCveId, affectsFlawCweId, affectsFlawEmbargoed, affectsFlawImpact, affectsFlawReportedDt, affectsFlawReportedDtDate, affectsFlawReportedDtDateGte, affectsFlawReportedDtDateLte, affectsFlawReportedDtGt, affectsFlawReportedDtGte, affectsFlawReportedDtLt, affectsFlawReportedDtLte, affectsFlawSource, affectsFlawUnembargoDt, affectsFlawUpdatedDt, affectsFlawUpdatedDtDate, affectsFlawUpdatedDtDateGte, affectsFlawUpdatedDtDateLte, affectsFlawUpdatedDtGt, affectsFlawUpdatedDtGte, affectsFlawUpdatedDtLt, affectsFlawUpdatedDtLte, affectsFlawUuid, affectsImpact, affectsPsComponent, affectsPsModule, affectsResolution, affectsUpdatedDt, affectsUpdatedDtDate, affectsUpdatedDtDateGte, affectsUpdatedDtDateLte, affectsUpdatedDtGt, affectsUpdatedDtGte, affectsUpdatedDtLt, affectsUpdatedDtLte, affectsUuid, createdDt, createdDtDate, createdDtDateGte, createdDtDateLte, createdDtGt, createdDtGte, createdDtLt, createdDtLte, embargoed, excludeFields, externalSystemId, includeFields, includeMetaAttr, limit, offset, order, psUpdateStream, resolution, status, type, updatedDt, updatedDtDate, updatedDtDateGte, updatedDtDateLte, updatedDtGt, updatedDtGte, updatedDtLt, updatedDtLte, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid A UUID string identifying this Tracker.
     * @param {Array<string>} [excludeFields] Exclude specified fields from the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;exclude_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeFields] Include only specified fields in the response. Multiple values may be separated by commas. Dot notation can be used to filter on related model fields. Example: &#x60;include_fields&#x3D;field,related_model_field.field&#x60;
     * @param {Array<string>} [includeMetaAttr] Specify which keys from meta_attr field should be retrieved, multiple values may be separated by commas. Dot notation can be used to specify meta_attr keys on related models. Example: &#x60;include_meta_attr&#x3D;key,related_model.key&#x60;Use wildcards eg. &#x60;include_meta_attr&#x3D;*,related_model.*&#x60; for retrieving all the keys from meta_attr. Omit this parameter to not include meta_attr fields at all. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1TrackersRetrieve(uuid: string, excludeFields?: Array<string>, includeFields?: Array<string>, includeMetaAttr?: Array<string>, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1TrackersRetrieve(uuid, excludeFields, includeFields, includeMetaAttr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bugzillaApiKey User generated api key for Bugzilla authentication.
     * @param {string} jiraApiKey User generated api key for Jira authentication.
     * @param {string} uuid A UUID string identifying this Tracker.
     * @param {Tracker} tracker 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbApiV1TrackersUpdate(bugzillaApiKey: string, jiraApiKey: string, uuid: string, tracker: Tracker, options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbApiV1TrackersUpdate(bugzillaApiKey, jiraApiKey, uuid, tracker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * unauthenticated view providing healthcheck on osidb service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbHealthyRetrieve(options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbHealthyRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * View that provides information about the currently logged-in user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsidbApi
     */
    public osidbWhoamiRetrieve(options?: AxiosRequestConfig) {
        return OsidbApiFp(this.configuration).osidbWhoamiRetrieve(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TrackersApi - axios parameter creator
 * @export
 */
export const TrackersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Given a list of flaws, generates a list of suggested trackers to file.
         * @param {FlawUUIDList} flawUUIDList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackersApiV1FileCreate: async (flawUUIDList: FlawUUIDList, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flawUUIDList' is not null or undefined
            assertParamExists('trackersApiV1FileCreate', 'flawUUIDList', flawUUIDList)
            const localVarPath = `/trackers/api/v1/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flawUUIDList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrackersApi - functional programming interface
 * @export
 */
export const TrackersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TrackersApiAxiosParamCreator(configuration)
    return {
        /**
         * Given a list of flaws, generates a list of suggested trackers to file.
         * @param {FlawUUIDList} flawUUIDList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackersApiV1FileCreate(flawUUIDList: FlawUUIDList, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackersApiV1FileCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackersApiV1FileCreate(flawUUIDList, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TrackersApi - factory interface
 * @export
 */
export const TrackersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TrackersApiFp(configuration)
    return {
        /**
         * Given a list of flaws, generates a list of suggested trackers to file.
         * @param {FlawUUIDList} flawUUIDList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackersApiV1FileCreate(flawUUIDList: FlawUUIDList, options?: any): AxiosPromise<TrackersApiV1FileCreate200Response> {
            return localVarFp.trackersApiV1FileCreate(flawUUIDList, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TrackersApi - object-oriented interface
 * @export
 * @class TrackersApi
 * @extends {BaseAPI}
 */
export class TrackersApi extends BaseAPI {
    /**
     * Given a list of flaws, generates a list of suggested trackers to file.
     * @param {FlawUUIDList} flawUUIDList 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackersApi
     */
    public trackersApiV1FileCreate(flawUUIDList: FlawUUIDList, options?: AxiosRequestConfig) {
        return TrackersApiFp(this.configuration).trackersApiV1FileCreate(flawUUIDList, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WorkflowsApi - axios parameter creator
 * @export
 */
export const WorkflowsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * workflow adjustion API endpoint  adjust workflow classification of flaw identified by UUID or CVE and return its workflow:state classification (new if changed and old otherwise)  adjust operation is idempotent so when the classification is already adjusted running it results in no operation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowsApiV1WorkflowsAdjustCreate: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workflowsApiV1WorkflowsAdjustCreate', 'id', id)
            const localVarPath = `/workflows/api/v1/workflows/{id}/adjust`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * workflow info API endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowsApiV1WorkflowsRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/workflows/api/v1/workflows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * workflow classification API endpoint  for flaw identified by UUID or CVE returns its workflow:state classification  params:      verbose - return also workflows with flaw classification               which represents the reasoning of the result
         * @param {string} id 
         * @param {boolean} [verbose] Return also workflows with flaw classification which represents the reasoning of the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowsApiV1WorkflowsRetrieve2: async (id: string, verbose?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workflowsApiV1WorkflowsRetrieve2', 'id', id)
            const localVarPath = `/workflows/api/v1/workflows/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (verbose !== undefined) {
                localVarQueryParameter['verbose'] = verbose;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * unauthenticated health check API endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowsHealthyRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/workflows/healthy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * index API endpoint listing available API endpoints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowsRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/workflows/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OsidbTokenAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowsApi - functional programming interface
 * @export
 */
export const WorkflowsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkflowsApiAxiosParamCreator(configuration)
    return {
        /**
         * workflow adjustion API endpoint  adjust workflow classification of flaw identified by UUID or CVE and return its workflow:state classification (new if changed and old otherwise)  adjust operation is idempotent so when the classification is already adjusted running it results in no operation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workflowsApiV1WorkflowsAdjustCreate(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200ResponseAllOf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workflowsApiV1WorkflowsAdjustCreate(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * workflow info API endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workflowsApiV1WorkflowsRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200ResponseAllOf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workflowsApiV1WorkflowsRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * workflow classification API endpoint  for flaw identified by UUID or CVE returns its workflow:state classification  params:      verbose - return also workflows with flaw classification               which represents the reasoning of the result
         * @param {string} id 
         * @param {boolean} [verbose] Return also workflows with flaw classification which represents the reasoning of the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workflowsApiV1WorkflowsRetrieve2(id: string, verbose?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200ResponseAllOf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workflowsApiV1WorkflowsRetrieve2(id, verbose, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * unauthenticated health check API endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workflowsHealthyRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200ResponseAllOf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workflowsHealthyRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * index API endpoint listing available API endpoints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workflowsRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenCreate200ResponseAllOf>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workflowsRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorkflowsApi - factory interface
 * @export
 */
export const WorkflowsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkflowsApiFp(configuration)
    return {
        /**
         * workflow adjustion API endpoint  adjust workflow classification of flaw identified by UUID or CVE and return its workflow:state classification (new if changed and old otherwise)  adjust operation is idempotent so when the classification is already adjusted running it results in no operation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowsApiV1WorkflowsAdjustCreate(id: string, options?: any): AxiosPromise<AuthTokenCreate200ResponseAllOf> {
            return localVarFp.workflowsApiV1WorkflowsAdjustCreate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * workflow info API endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowsApiV1WorkflowsRetrieve(options?: any): AxiosPromise<AuthTokenCreate200ResponseAllOf> {
            return localVarFp.workflowsApiV1WorkflowsRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * workflow classification API endpoint  for flaw identified by UUID or CVE returns its workflow:state classification  params:      verbose - return also workflows with flaw classification               which represents the reasoning of the result
         * @param {string} id 
         * @param {boolean} [verbose] Return also workflows with flaw classification which represents the reasoning of the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowsApiV1WorkflowsRetrieve2(id: string, verbose?: boolean, options?: any): AxiosPromise<AuthTokenCreate200ResponseAllOf> {
            return localVarFp.workflowsApiV1WorkflowsRetrieve2(id, verbose, options).then((request) => request(axios, basePath));
        },
        /**
         * unauthenticated health check API endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowsHealthyRetrieve(options?: any): AxiosPromise<AuthTokenCreate200ResponseAllOf> {
            return localVarFp.workflowsHealthyRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * index API endpoint listing available API endpoints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowsRetrieve(options?: any): AxiosPromise<AuthTokenCreate200ResponseAllOf> {
            return localVarFp.workflowsRetrieve(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkflowsApi - object-oriented interface
 * @export
 * @class WorkflowsApi
 * @extends {BaseAPI}
 */
export class WorkflowsApi extends BaseAPI {
    /**
     * workflow adjustion API endpoint  adjust workflow classification of flaw identified by UUID or CVE and return its workflow:state classification (new if changed and old otherwise)  adjust operation is idempotent so when the classification is already adjusted running it results in no operation
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public workflowsApiV1WorkflowsAdjustCreate(id: string, options?: AxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).workflowsApiV1WorkflowsAdjustCreate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * workflow info API endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public workflowsApiV1WorkflowsRetrieve(options?: AxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).workflowsApiV1WorkflowsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * workflow classification API endpoint  for flaw identified by UUID or CVE returns its workflow:state classification  params:      verbose - return also workflows with flaw classification               which represents the reasoning of the result
     * @param {string} id 
     * @param {boolean} [verbose] Return also workflows with flaw classification which represents the reasoning of the result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public workflowsApiV1WorkflowsRetrieve2(id: string, verbose?: boolean, options?: AxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).workflowsApiV1WorkflowsRetrieve2(id, verbose, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * unauthenticated health check API endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public workflowsHealthyRetrieve(options?: AxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).workflowsHealthyRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * index API endpoint listing available API endpoints
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public workflowsRetrieve(options?: AxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).workflowsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }
}


