/**
 * This file is AUTO GENERATED by [msw-auto-mock](https://github.com/zoubingwu/msw-auto-mock)
 * Feel free to commit/edit it as you need.
 */
/* eslint-disable */
/* tslint:disable */
import { HttpResponse, http } from "msw";
import { faker } from "@faker-js/faker";

faker.seed(1);

const baseURL = "http://localhost:3000";
const MAX_ARRAY_LENGTH = 20;

let i = 0;
const next = () => {
  if (i === Number.MAX_SAFE_INTEGER - 1) {
    i = 0;
  }
  return i++;
};

export const handlers = [
  http.get(`${baseURL}/auth/token`, async () => {
    const resultArray = [
      [await getAuthTokenRetrieve200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/auth/token`, async () => {
    const resultArray = [
      [await getAuthTokenCreate200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/auth/token/refresh`, async () => {
    const resultArray = [
      [await getAuthTokenRefreshCreate200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/auth/token/verify`, async () => {
    const resultArray = [
      [await getAuthTokenVerifyCreate200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/osidb/api/v1/flaws`, async () => {
    const resultArray = [
      [await getOsidbApiV1FlawsList200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/osidb/api/v1/flaws`, async () => {
    const resultArray = [
      [await getOsidbApiV1FlawsCreate201Response(), { status: 201 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/osidb/api/v1/flaws/*/acknowledgments`, async () => {
    const resultArray = [
      [
        await getOsidbApiV1FlawsAcknowledgmentsList200Response(),
        { status: 200 },
      ],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/osidb/api/v1/flaws/*/acknowledgments`, async () => {
    const resultArray = [
      [
        await getOsidbApiV1FlawsAcknowledgmentsCreate201Response(),
        { status: 201 },
      ],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/osidb/api/v1/flaws/*/acknowledgments/*`, async () => {
    const resultArray = [
      [
        await getOsidbApiV1FlawsAcknowledgmentsRetrieve200Response(),
        { status: 200 },
      ],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.put(`${baseURL}/osidb/api/v1/flaws/*/acknowledgments/*`, async () => {
    const resultArray = [
      [
        await getOsidbApiV1FlawsAcknowledgmentsUpdate200Response(),
        { status: 200 },
      ],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.delete(`${baseURL}/osidb/api/v1/flaws/*/acknowledgments/*`, async () => {
    const resultArray = [
      [
        await getOsidbApiV1FlawsAcknowledgmentsDestroy200Response(),
        { status: 200 },
      ],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/osidb/api/v1/flaws/*/comments`, async () => {
    const resultArray = [
      [await getOsidbApiV1FlawsCommentsList200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/osidb/api/v1/flaws/*/comments`, async () => {
    const resultArray = [
      [await getOsidbApiV1FlawsCommentsCreate201Response(), { status: 201 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/osidb/api/v1/flaws/*/comments/*`, async () => {
    const resultArray = [
      [await getOsidbApiV1FlawsCommentsRetrieve200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/osidb/api/v1/flaws/*/cvss_scores`, async () => {
    const resultArray = [
      [await getOsidbApiV1FlawsCvssScoresList200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/osidb/api/v1/flaws/*/cvss_scores`, async () => {
    const resultArray = [
      [await getOsidbApiV1FlawsCvssScoresCreate201Response(), { status: 201 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/osidb/api/v1/flaws/*/cvss_scores/*`, async () => {
    const resultArray = [
      [
        await getOsidbApiV1FlawsCvssScoresRetrieve200Response(),
        { status: 200 },
      ],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.put(`${baseURL}/osidb/api/v1/flaws/*/cvss_scores/*`, async () => {
    const resultArray = [
      [await getOsidbApiV1FlawsCvssScoresUpdate200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.delete(`${baseURL}/osidb/api/v1/flaws/*/cvss_scores/*`, async () => {
    const resultArray = [
      [await getOsidbApiV1FlawsCvssScoresDestroy200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/osidb/api/v1/flaws/*/package_versions`, async () => {
    const resultArray = [
      [
        await getOsidbApiV1FlawsPackageVersionsList200Response(),
        { status: 200 },
      ],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/osidb/api/v1/flaws/*/package_versions`, async () => {
    const resultArray = [
      [
        await getOsidbApiV1FlawsPackageVersionsCreate201Response(),
        { status: 201 },
      ],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/osidb/api/v1/flaws/*/package_versions/*`, async () => {
    const resultArray = [
      [
        await getOsidbApiV1FlawsPackageVersionsRetrieve200Response(),
        { status: 200 },
      ],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.put(`${baseURL}/osidb/api/v1/flaws/*/package_versions/*`, async () => {
    const resultArray = [
      [
        await getOsidbApiV1FlawsPackageVersionsUpdate200Response(),
        { status: 200 },
      ],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.delete(
    `${baseURL}/osidb/api/v1/flaws/*/package_versions/*`,
    async () => {
      const resultArray = [
        [
          await getOsidbApiV1FlawsPackageVersionsDestroy200Response(),
          { status: 200 },
        ],
      ];

      return HttpResponse.json(...resultArray[next() % resultArray.length]);
    },
  ),
  http.post(`${baseURL}/osidb/api/v1/flaws/*/promote`, async () => {
    const resultArray = [
      [await getOsidbApiV1FlawsPromoteCreate200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/osidb/api/v1/flaws/*/references`, async () => {
    const resultArray = [
      [await getOsidbApiV1FlawsReferencesList200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/osidb/api/v1/flaws/*/references`, async () => {
    const resultArray = [
      [await getOsidbApiV1FlawsReferencesCreate201Response(), { status: 201 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/osidb/api/v1/flaws/*/references/*`, async () => {
    const resultArray = [
      [
        await getOsidbApiV1FlawsReferencesRetrieve200Response(),
        { status: 200 },
      ],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.put(`${baseURL}/osidb/api/v1/flaws/*/references/*`, async () => {
    const resultArray = [
      [await getOsidbApiV1FlawsReferencesUpdate200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.delete(`${baseURL}/osidb/api/v1/flaws/*/references/*`, async () => {
    const resultArray = [
      [await getOsidbApiV1FlawsReferencesDestroy200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/osidb/api/v1/flaws/*/reject`, async () => {
    const resultArray = [
      [await getOsidbApiV1FlawsRejectCreate200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/osidb/api/v1/flaws/*`, async () => {
    const resultArray = [
      [await getOsidbApiV1FlawsRetrieve200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.put(`${baseURL}/osidb/api/v1/flaws/*`, async () => {
    const resultArray = [
      [await getOsidbApiV1FlawsUpdate200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/osidb/api/v1/trackers`, async () => {
    const resultArray = [
      [await getOsidbApiV1TrackersList200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/osidb/api/v1/trackers`, async () => {
    const resultArray = [
      [await getOsidbApiV1TrackersCreate201Response(), { status: 201 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.get(`${baseURL}/osidb/api/v1/trackers/*`, async () => {
    const resultArray = [
      [await getOsidbApiV1TrackersRetrieve200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.put(`${baseURL}/osidb/api/v1/trackers/*`, async () => {
    const resultArray = [
      [await getOsidbApiV1TrackersUpdate200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
  http.post(`${baseURL}/trackers/api/v1/file`, async () => {
    const resultArray = [
      [await getTrackersApiV1FileCreate200Response(), { status: 200 }],
    ];

    return HttpResponse.json(...resultArray[next() % resultArray.length]);
  }),
];

export function getAuthTokenRetrieve200Response() {
  return {
    access: faker.lorem.words(),
    dt: faker.date.past(),
    env: faker.lorem.words(),
    refresh: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}

export function getAuthTokenCreate200Response() {
  return {
    username: faker.person.fullName(),
    password: faker.lorem.words(),
    access: faker.lorem.words(),
    refresh: faker.lorem.words(),
    dt: faker.date.past(),
    env: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}

export function getAuthTokenRefreshCreate200Response() {
  return {
    access: faker.lorem.words(),
    refresh: faker.lorem.words(),
    dt: faker.date.past(),
    env: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}

export function getAuthTokenVerifyCreate200Response() {
  return {
    token: faker.lorem.words(),
    dt: faker.date.past(),
    env: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}

export function getOsidbApiV1FlawsList200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?offset=400&limit=100",
    previous: "http://api.example.org/accounts/?offset=200&limit=100",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      uuid: faker.string.uuid(),
      cve_id: faker.lorem.words(),
      impact: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          "LOW",
          "MODERATE",
          "IMPORTANT",
          "CRITICAL",
        ]),
        faker.helpers.arrayElement([""]),
      ]),
      components: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.string.alpha({ length: { min: 0, max: 100 } })),
      title: faker.lorem.words(),
      trackers: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      comment_zero: faker.lorem.words(),
      cve_description: faker.lorem.words(),
      requires_cve_description: faker.helpers.arrayElement([
        faker.helpers.arrayElement(["REQUESTED", "APPROVED", "REJECTED"]),
        faker.helpers.arrayElement([""]),
      ]),
      statement: faker.lorem.words(),
      cwe_id: faker.string.alpha({ length: { min: 0, max: 255 } }),
      unembargo_dt: faker.date.past(),
      source: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          "ADOBE",
          "APPLE",
          "ASF",
          "BIND",
          "BK",
          "BUGTRAQ",
          "BUGZILLA",
          "CERT",
          "CERTIFI",
          "CORELABS",
          "CUSTOMER",
          "CVE",
          "CVEORG",
          "DAILYDAVE",
          "DEBIAN",
          "DISTROS",
          "FEDORA",
          "FETCHMAIL",
          "FREEDESKTOP",
          "FREERADIUS",
          "FRSIRT",
          "FULLDISCLOSURE",
          "GAIM",
          "GENTOO",
          "GENTOOBZ",
          "GIT",
          "GNOME",
          "GNUPG",
          "GOOGLE",
          "HP",
          "HW_VENDOR",
          "IBM",
          "IDEFENSE",
          "INTERNET",
          "ISC",
          "ISEC",
          "IT",
          "JBOSS",
          "JPCERT",
          "KERNELBUGZILLA",
          "KERNELSEC",
          "LKML",
          "LWN",
          "MACROMEDIA",
          "MAGEIA",
          "MAILINGLIST",
          "MILW0RM",
          "MIT",
          "MITRE",
          "MOZILLA",
          "MUTTDEV",
          "NETDEV",
          "NISCC",
          "NVD",
          "OCERT",
          "OPENOFFICE",
          "OPENSSL",
          "OPENSUSE",
          "ORACLE",
          "OSS",
          "OSSSECURITY",
          "OSV",
          "PHP",
          "PIDGIN",
          "POSTGRESQL",
          "PRESS",
          "REAL",
          "REDHAT",
          "RESEARCHER",
          "RT",
          "SAMBA",
          "SECALERT",
          "SECUNIA",
          "SECURITYFOCUS",
          "SKO",
          "SQUID",
          "SQUIRRELMAIL",
          "SUN",
          "SUNSOLVE",
          "SUSE",
          "TWITTER",
          "UBUNTU",
          "UPSTREAM",
          "VENDORSEC",
          "VULNWATCH",
          "WIRESHARK",
          "XCHAT",
          "XEN",
          "XPDF",
        ]),
        faker.helpers.arrayElement([""]),
      ]),
      reported_dt: faker.date.past(),
      mitigation: faker.lorem.words(),
      major_incident_state: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          "REQUESTED",
          "REJECTED",
          "APPROVED",
          "CISA_APPROVED",
          "INVALID",
        ]),
        faker.helpers.arrayElement([""]),
      ]),
      major_incident_start_dt: faker.date.past(),
      nist_cvss_validation: faker.helpers.arrayElement([
        faker.helpers.arrayElement(["REQUESTED", "APPROVED", "REJECTED"]),
        faker.helpers.arrayElement([""]),
      ]),
      affects: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        uuid: faker.string.uuid(),
        flaw: faker.string.uuid(),
        affectedness: faker.helpers.arrayElement([
          faker.helpers.arrayElement(["NEW", "AFFECTED", "NOTAFFECTED"]),
          faker.helpers.arrayElement([""]),
        ]),
        resolution: faker.helpers.arrayElement([
          faker.helpers.arrayElement([
            "FIX",
            "DEFER",
            "WONTFIX",
            "OOSS",
            "DELEGATED",
            "WONTREPORT",
          ]),
          faker.helpers.arrayElement([""]),
        ]),
        ps_module: faker.string.alpha({ length: { min: 0, max: 100 } }),
        ps_product: faker.lorem.words(),
        ps_component: faker.string.alpha({ length: { min: 0, max: 255 } }),
        impact: faker.helpers.arrayElement([
          faker.helpers.arrayElement([
            "LOW",
            "MODERATE",
            "IMPORTANT",
            "CRITICAL",
          ]),
          faker.helpers.arrayElement([""]),
        ]),
        trackers: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          affects: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => faker.string.uuid()),
          errata: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            et_id: faker.number.int(),
            advisory_name: faker.person.fullName(),
            shipped_dt: faker.date.past(),
            created_dt: faker.date.past(),
            updated_dt: faker.date.past(),
          })),
          external_system_id: faker.lorem.words(),
          meta_attr: {
            bz_id: faker.lorem.words(),
            owner: faker.lorem.words(),
            qe_owner: faker.lorem.words(),
            ps_component: faker.lorem.words(),
            ps_module: faker.lorem.words(),
            ps_update_stream: faker.lorem.words(),
            resolution: faker.lorem.words(),
            status: faker.lorem.words(),
          },
          ps_update_stream: faker.string.alpha({
            length: { min: 0, max: 100 },
          }),
          status: faker.lorem.words(),
          resolution: faker.lorem.words(),
          type: faker.helpers.arrayElement(["JIRA", "BUGZILLA"]),
          uuid: faker.string.uuid(),
          embargoed: faker.datatype.boolean(),
          alerts: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            uuid: faker.string.uuid(),
            name: faker.person.fullName(),
            description: faker.lorem.words(),
            alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
            resolution_steps: faker.lorem.words(),
            parent_uuid: faker.lorem.words(),
            parent_model: faker.lorem.words(),
          })),
          created_dt: faker.date.past(),
          updated_dt: faker.date.past(),
          sync_to_bz: faker.datatype.boolean(),
        })),
        meta_attr: {
          affectedness: faker.lorem.words(),
          component: faker.lorem.words(),
          impact: faker.lorem.words(),
          module_name: faker.person.fullName(),
          module_stream: faker.lorem.words(),
          ps_component: faker.lorem.words(),
          ps_module: faker.lorem.words(),
          ps_product: faker.lorem.words(),
          resolution: faker.lorem.words(),
        },
        delegated_resolution: faker.lorem.words(),
        cvss_scores: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          affect: faker.string.uuid(),
          comment: faker.lorem.words(),
          cvss_version: faker.helpers.arrayElement(["V2", "V3", "V4"]),
          issuer: faker.helpers.arrayElement(["CVEORG", "RH", "NIST", "OSV"]),
          score: faker.number.int(),
          uuid: faker.string.uuid(),
          vector: faker.string.alpha({ length: { min: 0, max: 200 } }),
          embargoed: faker.datatype.boolean(),
          alerts: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            uuid: faker.string.uuid(),
            name: faker.person.fullName(),
            description: faker.lorem.words(),
            alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
            resolution_steps: faker.lorem.words(),
            parent_uuid: faker.lorem.words(),
            parent_model: faker.lorem.words(),
          })),
          created_dt: faker.date.past(),
          updated_dt: faker.date.past(),
        })),
        embargoed: faker.datatype.boolean(),
        alerts: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          uuid: faker.string.uuid(),
          name: faker.person.fullName(),
          description: faker.lorem.words(),
          alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
          resolution_steps: faker.lorem.words(),
          parent_uuid: faker.lorem.words(),
          parent_model: faker.lorem.words(),
        })),
        created_dt: faker.date.past(),
        updated_dt: faker.date.past(),
      })),
      comments: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        uuid: faker.string.uuid(),
        text: faker.lorem.words(),
        external_system_id: faker.string.alpha({
          length: { min: 0, max: 100 },
        }),
        order: faker.number.int({ min: -2147483648, max: 2147483647 }),
        creator: faker.string.alpha({ length: { min: 0, max: 100 } }),
        is_private: faker.datatype.boolean(),
        alerts: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          uuid: faker.string.uuid(),
          name: faker.person.fullName(),
          description: faker.lorem.words(),
          alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
          resolution_steps: faker.lorem.words(),
          parent_uuid: faker.lorem.words(),
          parent_model: faker.lorem.words(),
        })),
        created_dt: faker.date.past(),
        updated_dt: faker.date.past(),
      })),
      meta_attr: {
        acknowledgments: faker.lorem.words(),
        acks_not_needed: faker.lorem.words(),
        affects: faker.lorem.words(),
        alias: faker.lorem.words(),
        bz_datascore: faker.lorem.words(),
        bz_id: faker.lorem.words(),
        checklists: faker.lorem.words(),
        classification: faker.lorem.words(),
        cwe: faker.lorem.words(),
        depends_on: faker.lorem.words(),
        impact: faker.lorem.words(),
        jira_trackers: faker.lorem.words(),
        mitigate: faker.lorem.words(),
        mitigation: faker.lorem.words(),
        public: faker.lorem.words(),
        references: faker.lorem.words(),
        related_cves: faker.lorem.words(),
        reported: faker.lorem.words(),
        source: faker.lorem.words(),
        statement: faker.lorem.words(),
        task_owner: faker.lorem.words(),
      },
      package_versions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        package: faker.string.alpha({ length: { min: 0, max: 2048 } }),
        versions: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          version: faker.string.alpha({ length: { min: 0, max: 1024 } }),
          status: faker.lorem.words(),
        })),
        alerts: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          uuid: faker.string.uuid(),
          name: faker.person.fullName(),
          description: faker.lorem.words(),
          alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
          resolution_steps: faker.lorem.words(),
          parent_uuid: faker.lorem.words(),
          parent_model: faker.lorem.words(),
        })),
      })),
      acknowledgments: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        name: faker.person.fullName(),
        affiliation: faker.string.alpha({ length: { min: 0, max: 255 } }),
        from_upstream: faker.datatype.boolean(),
        flaw: faker.string.uuid(),
        uuid: faker.string.uuid(),
        embargoed: faker.datatype.boolean(),
        alerts: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          uuid: faker.string.uuid(),
          name: faker.person.fullName(),
          description: faker.lorem.words(),
          alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
          resolution_steps: faker.lorem.words(),
          parent_uuid: faker.lorem.words(),
          parent_model: faker.lorem.words(),
        })),
        created_dt: faker.date.past(),
        updated_dt: faker.date.past(),
      })),
      references: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        description: faker.lorem.words(),
        flaw: faker.string.uuid(),
        type: faker.helpers.arrayElement(["ARTICLE", "EXTERNAL", "SOURCE"]),
        url: faker.internet.url(),
        uuid: faker.string.uuid(),
        embargoed: faker.datatype.boolean(),
        alerts: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          uuid: faker.string.uuid(),
          name: faker.person.fullName(),
          description: faker.lorem.words(),
          alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
          resolution_steps: faker.lorem.words(),
          parent_uuid: faker.lorem.words(),
          parent_model: faker.lorem.words(),
        })),
        created_dt: faker.date.past(),
        updated_dt: faker.date.past(),
      })),
      cvss_scores: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        flaw: faker.string.uuid(),
        comment: faker.lorem.words(),
        cvss_version: faker.helpers.arrayElement(["V2", "V3", "V4"]),
        issuer: faker.helpers.arrayElement(["CVEORG", "RH", "NIST", "OSV"]),
        score: faker.number.int(),
        uuid: faker.string.uuid(),
        vector: faker.string.alpha({ length: { min: 0, max: 200 } }),
        embargoed: faker.datatype.boolean(),
        alerts: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          uuid: faker.string.uuid(),
          name: faker.person.fullName(),
          description: faker.lorem.words(),
          alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
          resolution_steps: faker.lorem.words(),
          parent_uuid: faker.lorem.words(),
          parent_model: faker.lorem.words(),
        })),
        created_dt: faker.date.past(),
        updated_dt: faker.date.past(),
      })),
      embargoed: faker.datatype.boolean(),
      created_dt: faker.date.past(),
      updated_dt: faker.date.past(),
      classification: {
        workflow: faker.lorem.words(),
        state: faker.helpers.arrayElement([
          "",
          "NEW",
          "TRIAGE",
          "PRE_SECONDARY_ASSESSMENT",
          "SECONDARY_ASSESSMENT",
          "DONE",
          "REJECTED",
        ]),
      },
      group_key: faker.string.alpha({ length: { min: 0, max: 60 } }),
      owner: faker.string.alpha({ length: { min: 0, max: 60 } }),
      task_key: faker.string.alpha({ length: { min: 0, max: 60 } }),
      team_id: faker.string.alpha({ length: { min: 0, max: 8 } }),
      alerts: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        uuid: faker.string.uuid(),
        name: faker.person.fullName(),
        description: faker.lorem.words(),
        alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
        resolution_steps: faker.lorem.words(),
        parent_uuid: faker.lorem.words(),
        parent_model: faker.lorem.words(),
      })),
    })),
    dt: faker.date.past(),
    env: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}

export function getOsidbApiV1FlawsCreate201Response() {
  return {
    uuid: faker.string.uuid(),
    cve_id: faker.lorem.words(),
    impact: faker.helpers.arrayElement([
      faker.helpers.arrayElement(["LOW", "MODERATE", "IMPORTANT", "CRITICAL"]),
      faker.helpers.arrayElement([""]),
    ]),
    components: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.string.alpha({ length: { min: 0, max: 100 } })),
    title: faker.lorem.words(),
    trackers: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.words()),
    comment_zero: faker.lorem.words(),
    cve_description: faker.lorem.words(),
    requires_cve_description: faker.helpers.arrayElement([
      faker.helpers.arrayElement(["REQUESTED", "APPROVED", "REJECTED"]),
      faker.helpers.arrayElement([""]),
    ]),
    statement: faker.lorem.words(),
    cwe_id: faker.string.alpha({ length: { min: 0, max: 255 } }),
    unembargo_dt: faker.date.past(),
    source: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        "ADOBE",
        "APPLE",
        "ASF",
        "BIND",
        "BK",
        "BUGTRAQ",
        "BUGZILLA",
        "CERT",
        "CERTIFI",
        "CORELABS",
        "CUSTOMER",
        "CVE",
        "CVEORG",
        "DAILYDAVE",
        "DEBIAN",
        "DISTROS",
        "FEDORA",
        "FETCHMAIL",
        "FREEDESKTOP",
        "FREERADIUS",
        "FRSIRT",
        "FULLDISCLOSURE",
        "GAIM",
        "GENTOO",
        "GENTOOBZ",
        "GIT",
        "GNOME",
        "GNUPG",
        "GOOGLE",
        "HP",
        "HW_VENDOR",
        "IBM",
        "IDEFENSE",
        "INTERNET",
        "ISC",
        "ISEC",
        "IT",
        "JBOSS",
        "JPCERT",
        "KERNELBUGZILLA",
        "KERNELSEC",
        "LKML",
        "LWN",
        "MACROMEDIA",
        "MAGEIA",
        "MAILINGLIST",
        "MILW0RM",
        "MIT",
        "MITRE",
        "MOZILLA",
        "MUTTDEV",
        "NETDEV",
        "NISCC",
        "NVD",
        "OCERT",
        "OPENOFFICE",
        "OPENSSL",
        "OPENSUSE",
        "ORACLE",
        "OSS",
        "OSSSECURITY",
        "OSV",
        "PHP",
        "PIDGIN",
        "POSTGRESQL",
        "PRESS",
        "REAL",
        "REDHAT",
        "RESEARCHER",
        "RT",
        "SAMBA",
        "SECALERT",
        "SECUNIA",
        "SECURITYFOCUS",
        "SKO",
        "SQUID",
        "SQUIRRELMAIL",
        "SUN",
        "SUNSOLVE",
        "SUSE",
        "TWITTER",
        "UBUNTU",
        "UPSTREAM",
        "VENDORSEC",
        "VULNWATCH",
        "WIRESHARK",
        "XCHAT",
        "XEN",
        "XPDF",
      ]),
      faker.helpers.arrayElement([""]),
    ]),
    reported_dt: faker.date.past(),
    mitigation: faker.lorem.words(),
    major_incident_state: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        "REQUESTED",
        "REJECTED",
        "APPROVED",
        "CISA_APPROVED",
        "INVALID",
      ]),
      faker.helpers.arrayElement([""]),
    ]),
    major_incident_start_dt: faker.date.past(),
    nist_cvss_validation: faker.helpers.arrayElement([
      faker.helpers.arrayElement(["REQUESTED", "APPROVED", "REJECTED"]),
      faker.helpers.arrayElement([""]),
    ]),
    affects: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      uuid: faker.string.uuid(),
      flaw: faker.string.uuid(),
      affectedness: faker.helpers.arrayElement([
        faker.helpers.arrayElement(["NEW", "AFFECTED", "NOTAFFECTED"]),
        faker.helpers.arrayElement([""]),
      ]),
      resolution: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          "FIX",
          "DEFER",
          "WONTFIX",
          "OOSS",
          "DELEGATED",
          "WONTREPORT",
        ]),
        faker.helpers.arrayElement([""]),
      ]),
      ps_module: faker.string.alpha({ length: { min: 0, max: 100 } }),
      ps_product: faker.lorem.words(),
      ps_component: faker.string.alpha({ length: { min: 0, max: 255 } }),
      impact: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          "LOW",
          "MODERATE",
          "IMPORTANT",
          "CRITICAL",
        ]),
        faker.helpers.arrayElement([""]),
      ]),
      trackers: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        affects: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.string.uuid()),
        errata: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          et_id: faker.number.int(),
          advisory_name: faker.person.fullName(),
          shipped_dt: faker.date.past(),
          created_dt: faker.date.past(),
          updated_dt: faker.date.past(),
        })),
        external_system_id: faker.lorem.words(),
        meta_attr: {
          bz_id: faker.lorem.words(),
          owner: faker.lorem.words(),
          qe_owner: faker.lorem.words(),
          ps_component: faker.lorem.words(),
          ps_module: faker.lorem.words(),
          ps_update_stream: faker.lorem.words(),
          resolution: faker.lorem.words(),
          status: faker.lorem.words(),
        },
        ps_update_stream: faker.string.alpha({ length: { min: 0, max: 100 } }),
        status: faker.lorem.words(),
        resolution: faker.lorem.words(),
        type: faker.helpers.arrayElement(["JIRA", "BUGZILLA"]),
        uuid: faker.string.uuid(),
        embargoed: faker.datatype.boolean(),
        alerts: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          uuid: faker.string.uuid(),
          name: faker.person.fullName(),
          description: faker.lorem.words(),
          alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
          resolution_steps: faker.lorem.words(),
          parent_uuid: faker.lorem.words(),
          parent_model: faker.lorem.words(),
        })),
        created_dt: faker.date.past(),
        updated_dt: faker.date.past(),
        sync_to_bz: faker.datatype.boolean(),
      })),
      meta_attr: {
        affectedness: faker.lorem.words(),
        component: faker.lorem.words(),
        impact: faker.lorem.words(),
        module_name: faker.person.fullName(),
        module_stream: faker.lorem.words(),
        ps_component: faker.lorem.words(),
        ps_module: faker.lorem.words(),
        ps_product: faker.lorem.words(),
        resolution: faker.lorem.words(),
      },
      delegated_resolution: faker.lorem.words(),
      cvss_scores: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        affect: faker.string.uuid(),
        comment: faker.lorem.words(),
        cvss_version: faker.helpers.arrayElement(["V2", "V3", "V4"]),
        issuer: faker.helpers.arrayElement(["CVEORG", "RH", "NIST", "OSV"]),
        score: faker.number.int(),
        uuid: faker.string.uuid(),
        vector: faker.string.alpha({ length: { min: 0, max: 200 } }),
        embargoed: faker.datatype.boolean(),
        alerts: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          uuid: faker.string.uuid(),
          name: faker.person.fullName(),
          description: faker.lorem.words(),
          alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
          resolution_steps: faker.lorem.words(),
          parent_uuid: faker.lorem.words(),
          parent_model: faker.lorem.words(),
        })),
        created_dt: faker.date.past(),
        updated_dt: faker.date.past(),
      })),
      embargoed: faker.datatype.boolean(),
      alerts: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        uuid: faker.string.uuid(),
        name: faker.person.fullName(),
        description: faker.lorem.words(),
        alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
        resolution_steps: faker.lorem.words(),
        parent_uuid: faker.lorem.words(),
        parent_model: faker.lorem.words(),
      })),
      created_dt: faker.date.past(),
      updated_dt: faker.date.past(),
    })),
    comments: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      uuid: faker.string.uuid(),
      text: faker.lorem.words(),
      external_system_id: faker.string.alpha({ length: { min: 0, max: 100 } }),
      order: faker.number.int({ min: -2147483648, max: 2147483647 }),
      creator: faker.string.alpha({ length: { min: 0, max: 100 } }),
      is_private: faker.datatype.boolean(),
      alerts: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        uuid: faker.string.uuid(),
        name: faker.person.fullName(),
        description: faker.lorem.words(),
        alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
        resolution_steps: faker.lorem.words(),
        parent_uuid: faker.lorem.words(),
        parent_model: faker.lorem.words(),
      })),
      created_dt: faker.date.past(),
      updated_dt: faker.date.past(),
    })),
    meta_attr: {
      acknowledgments: faker.lorem.words(),
      acks_not_needed: faker.lorem.words(),
      affects: faker.lorem.words(),
      alias: faker.lorem.words(),
      bz_datascore: faker.lorem.words(),
      bz_id: faker.lorem.words(),
      checklists: faker.lorem.words(),
      classification: faker.lorem.words(),
      cwe: faker.lorem.words(),
      depends_on: faker.lorem.words(),
      impact: faker.lorem.words(),
      jira_trackers: faker.lorem.words(),
      mitigate: faker.lorem.words(),
      mitigation: faker.lorem.words(),
      public: faker.lorem.words(),
      references: faker.lorem.words(),
      related_cves: faker.lorem.words(),
      reported: faker.lorem.words(),
      source: faker.lorem.words(),
      statement: faker.lorem.words(),
      task_owner: faker.lorem.words(),
    },
    package_versions: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      package: faker.string.alpha({ length: { min: 0, max: 2048 } }),
      versions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        version: faker.string.alpha({ length: { min: 0, max: 1024 } }),
        status: faker.lorem.words(),
      })),
      alerts: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        uuid: faker.string.uuid(),
        name: faker.person.fullName(),
        description: faker.lorem.words(),
        alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
        resolution_steps: faker.lorem.words(),
        parent_uuid: faker.lorem.words(),
        parent_model: faker.lorem.words(),
      })),
    })),
    acknowledgments: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      name: faker.person.fullName(),
      affiliation: faker.string.alpha({ length: { min: 0, max: 255 } }),
      from_upstream: faker.datatype.boolean(),
      flaw: faker.string.uuid(),
      uuid: faker.string.uuid(),
      embargoed: faker.datatype.boolean(),
      alerts: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        uuid: faker.string.uuid(),
        name: faker.person.fullName(),
        description: faker.lorem.words(),
        alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
        resolution_steps: faker.lorem.words(),
        parent_uuid: faker.lorem.words(),
        parent_model: faker.lorem.words(),
      })),
      created_dt: faker.date.past(),
      updated_dt: faker.date.past(),
    })),
    references: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      description: faker.lorem.words(),
      flaw: faker.string.uuid(),
      type: faker.helpers.arrayElement(["ARTICLE", "EXTERNAL", "SOURCE"]),
      url: faker.internet.url(),
      uuid: faker.string.uuid(),
      embargoed: faker.datatype.boolean(),
      alerts: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        uuid: faker.string.uuid(),
        name: faker.person.fullName(),
        description: faker.lorem.words(),
        alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
        resolution_steps: faker.lorem.words(),
        parent_uuid: faker.lorem.words(),
        parent_model: faker.lorem.words(),
      })),
      created_dt: faker.date.past(),
      updated_dt: faker.date.past(),
    })),
    cvss_scores: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      flaw: faker.string.uuid(),
      comment: faker.lorem.words(),
      cvss_version: faker.helpers.arrayElement(["V2", "V3", "V4"]),
      issuer: faker.helpers.arrayElement(["CVEORG", "RH", "NIST", "OSV"]),
      score: faker.number.int(),
      uuid: faker.string.uuid(),
      vector: faker.string.alpha({ length: { min: 0, max: 200 } }),
      embargoed: faker.datatype.boolean(),
      alerts: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        uuid: faker.string.uuid(),
        name: faker.person.fullName(),
        description: faker.lorem.words(),
        alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
        resolution_steps: faker.lorem.words(),
        parent_uuid: faker.lorem.words(),
        parent_model: faker.lorem.words(),
      })),
      created_dt: faker.date.past(),
      updated_dt: faker.date.past(),
    })),
    embargoed: faker.datatype.boolean(),
    created_dt: faker.date.past(),
    updated_dt: faker.date.past(),
    classification: {
      workflow: faker.lorem.words(),
      state: faker.helpers.arrayElement([
        "",
        "NEW",
        "TRIAGE",
        "PRE_SECONDARY_ASSESSMENT",
        "SECONDARY_ASSESSMENT",
        "DONE",
        "REJECTED",
      ]),
    },
    group_key: faker.string.alpha({ length: { min: 0, max: 60 } }),
    owner: faker.string.alpha({ length: { min: 0, max: 60 } }),
    task_key: faker.string.alpha({ length: { min: 0, max: 60 } }),
    team_id: faker.string.alpha({ length: { min: 0, max: 8 } }),
    alerts: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      uuid: faker.string.uuid(),
      name: faker.person.fullName(),
      description: faker.lorem.words(),
      alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
      resolution_steps: faker.lorem.words(),
      parent_uuid: faker.lorem.words(),
      parent_model: faker.lorem.words(),
    })),
    dt: faker.date.past(),
    env: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}

export function getOsidbApiV1FlawsAcknowledgmentsList200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?offset=400&limit=100",
    previous: "http://api.example.org/accounts/?offset=200&limit=100",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      name: faker.person.fullName(),
      affiliation: faker.string.alpha({ length: { min: 0, max: 255 } }),
      from_upstream: faker.datatype.boolean(),
      flaw: faker.string.uuid(),
      uuid: faker.string.uuid(),
      embargoed: faker.datatype.boolean(),
      alerts: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        uuid: faker.string.uuid(),
        name: faker.person.fullName(),
        description: faker.lorem.words(),
        alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
        resolution_steps: faker.lorem.words(),
        parent_uuid: faker.lorem.words(),
        parent_model: faker.lorem.words(),
      })),
      created_dt: faker.date.past(),
      updated_dt: faker.date.past(),
    })),
    dt: faker.date.past(),
    env: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}

export function getOsidbApiV1FlawsAcknowledgmentsCreate201Response() {
  return {
    name: faker.person.fullName(),
    affiliation: faker.string.alpha({ length: { min: 0, max: 255 } }),
    from_upstream: faker.datatype.boolean(),
    flaw: faker.string.uuid(),
    uuid: faker.string.uuid(),
    embargoed: faker.datatype.boolean(),
    alerts: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      uuid: faker.string.uuid(),
      name: faker.person.fullName(),
      description: faker.lorem.words(),
      alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
      resolution_steps: faker.lorem.words(),
      parent_uuid: faker.lorem.words(),
      parent_model: faker.lorem.words(),
    })),
    created_dt: faker.date.past(),
    updated_dt: faker.date.past(),
    dt: faker.date.past(),
    env: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}

export function getOsidbApiV1FlawsAcknowledgmentsRetrieve200Response() {
  return {
    name: faker.person.fullName(),
    affiliation: faker.string.alpha({ length: { min: 0, max: 255 } }),
    from_upstream: faker.datatype.boolean(),
    flaw: faker.string.uuid(),
    uuid: faker.string.uuid(),
    embargoed: faker.datatype.boolean(),
    alerts: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      uuid: faker.string.uuid(),
      name: faker.person.fullName(),
      description: faker.lorem.words(),
      alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
      resolution_steps: faker.lorem.words(),
      parent_uuid: faker.lorem.words(),
      parent_model: faker.lorem.words(),
    })),
    created_dt: faker.date.past(),
    updated_dt: faker.date.past(),
    dt: faker.date.past(),
    env: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}

export function getOsidbApiV1FlawsAcknowledgmentsUpdate200Response() {
  return {
    name: faker.person.fullName(),
    affiliation: faker.string.alpha({ length: { min: 0, max: 255 } }),
    from_upstream: faker.datatype.boolean(),
    flaw: faker.string.uuid(),
    uuid: faker.string.uuid(),
    embargoed: faker.datatype.boolean(),
    alerts: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      uuid: faker.string.uuid(),
      name: faker.person.fullName(),
      description: faker.lorem.words(),
      alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
      resolution_steps: faker.lorem.words(),
      parent_uuid: faker.lorem.words(),
      parent_model: faker.lorem.words(),
    })),
    created_dt: faker.date.past(),
    updated_dt: faker.date.past(),
    dt: faker.date.past(),
    env: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}

export function getOsidbApiV1FlawsAcknowledgmentsDestroy200Response() {
  return {
    dt: faker.date.past(),
    env: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}

export function getOsidbApiV1FlawsCommentsList200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?offset=400&limit=100",
    previous: "http://api.example.org/accounts/?offset=200&limit=100",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      flaw: faker.string.uuid(),
      text: faker.lorem.words(),
      uuid: faker.string.uuid(),
      external_system_id: faker.lorem.words(),
      order: faker.number.int({ min: -2147483648, max: 2147483647 }),
      creator: faker.string.alpha({ length: { min: 0, max: 100 } }),
      is_private: faker.datatype.boolean(),
      alerts: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        uuid: faker.string.uuid(),
        name: faker.person.fullName(),
        description: faker.lorem.words(),
        alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
        resolution_steps: faker.lorem.words(),
        parent_uuid: faker.lorem.words(),
        parent_model: faker.lorem.words(),
      })),
      created_dt: faker.date.past(),
      updated_dt: faker.date.past(),
      embargoed: faker.datatype.boolean(),
    })),
    dt: faker.date.past(),
    env: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}

export function getOsidbApiV1FlawsCommentsCreate201Response() {
  return {
    flaw: faker.string.uuid(),
    text: faker.lorem.words(),
    uuid: faker.string.uuid(),
    external_system_id: faker.lorem.words(),
    order: faker.number.int({ min: -2147483648, max: 2147483647 }),
    creator: faker.string.alpha({ length: { min: 0, max: 100 } }),
    is_private: faker.datatype.boolean(),
    alerts: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      uuid: faker.string.uuid(),
      name: faker.person.fullName(),
      description: faker.lorem.words(),
      alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
      resolution_steps: faker.lorem.words(),
      parent_uuid: faker.lorem.words(),
      parent_model: faker.lorem.words(),
    })),
    created_dt: faker.date.past(),
    updated_dt: faker.date.past(),
    embargoed: faker.datatype.boolean(),
    dt: faker.date.past(),
    env: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}

export function getOsidbApiV1FlawsCommentsRetrieve200Response() {
  return {
    flaw: faker.string.uuid(),
    text: faker.lorem.words(),
    uuid: faker.string.uuid(),
    external_system_id: faker.lorem.words(),
    order: faker.number.int({ min: -2147483648, max: 2147483647 }),
    creator: faker.string.alpha({ length: { min: 0, max: 100 } }),
    is_private: faker.datatype.boolean(),
    alerts: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      uuid: faker.string.uuid(),
      name: faker.person.fullName(),
      description: faker.lorem.words(),
      alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
      resolution_steps: faker.lorem.words(),
      parent_uuid: faker.lorem.words(),
      parent_model: faker.lorem.words(),
    })),
    created_dt: faker.date.past(),
    updated_dt: faker.date.past(),
    embargoed: faker.datatype.boolean(),
    dt: faker.date.past(),
    env: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}

export function getOsidbApiV1FlawsCvssScoresList200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?offset=400&limit=100",
    previous: "http://api.example.org/accounts/?offset=200&limit=100",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      flaw: faker.string.uuid(),
      comment: faker.lorem.words(),
      cvss_version: faker.helpers.arrayElement(["V2", "V3", "V4"]),
      issuer: faker.helpers.arrayElement(["CVEORG", "RH", "NIST", "OSV"]),
      score: faker.number.int(),
      uuid: faker.string.uuid(),
      vector: faker.string.alpha({ length: { min: 0, max: 200 } }),
      embargoed: faker.datatype.boolean(),
      alerts: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        uuid: faker.string.uuid(),
        name: faker.person.fullName(),
        description: faker.lorem.words(),
        alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
        resolution_steps: faker.lorem.words(),
        parent_uuid: faker.lorem.words(),
        parent_model: faker.lorem.words(),
      })),
      created_dt: faker.date.past(),
      updated_dt: faker.date.past(),
    })),
    dt: faker.date.past(),
    env: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}

export function getOsidbApiV1FlawsCvssScoresCreate201Response() {
  return {
    flaw: faker.string.uuid(),
    comment: faker.lorem.words(),
    cvss_version: faker.helpers.arrayElement(["V2", "V3", "V4"]),
    issuer: faker.helpers.arrayElement(["CVEORG", "RH", "NIST", "OSV"]),
    score: faker.number.int(),
    uuid: faker.string.uuid(),
    vector: faker.string.alpha({ length: { min: 0, max: 200 } }),
    embargoed: faker.datatype.boolean(),
    alerts: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      uuid: faker.string.uuid(),
      name: faker.person.fullName(),
      description: faker.lorem.words(),
      alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
      resolution_steps: faker.lorem.words(),
      parent_uuid: faker.lorem.words(),
      parent_model: faker.lorem.words(),
    })),
    created_dt: faker.date.past(),
    updated_dt: faker.date.past(),
    dt: faker.date.past(),
    env: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}

export function getOsidbApiV1FlawsCvssScoresRetrieve200Response() {
  return {
    flaw: faker.string.uuid(),
    comment: faker.lorem.words(),
    cvss_version: faker.helpers.arrayElement(["V2", "V3", "V4"]),
    issuer: faker.helpers.arrayElement(["CVEORG", "RH", "NIST", "OSV"]),
    score: faker.number.int(),
    uuid: faker.string.uuid(),
    vector: faker.string.alpha({ length: { min: 0, max: 200 } }),
    embargoed: faker.datatype.boolean(),
    alerts: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      uuid: faker.string.uuid(),
      name: faker.person.fullName(),
      description: faker.lorem.words(),
      alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
      resolution_steps: faker.lorem.words(),
      parent_uuid: faker.lorem.words(),
      parent_model: faker.lorem.words(),
    })),
    created_dt: faker.date.past(),
    updated_dt: faker.date.past(),
    dt: faker.date.past(),
    env: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}

export function getOsidbApiV1FlawsCvssScoresUpdate200Response() {
  return {
    flaw: faker.string.uuid(),
    comment: faker.lorem.words(),
    cvss_version: faker.helpers.arrayElement(["V2", "V3", "V4"]),
    issuer: faker.helpers.arrayElement(["CVEORG", "RH", "NIST", "OSV"]),
    score: faker.number.int(),
    uuid: faker.string.uuid(),
    vector: faker.string.alpha({ length: { min: 0, max: 200 } }),
    embargoed: faker.datatype.boolean(),
    alerts: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      uuid: faker.string.uuid(),
      name: faker.person.fullName(),
      description: faker.lorem.words(),
      alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
      resolution_steps: faker.lorem.words(),
      parent_uuid: faker.lorem.words(),
      parent_model: faker.lorem.words(),
    })),
    created_dt: faker.date.past(),
    updated_dt: faker.date.past(),
    dt: faker.date.past(),
    env: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}

export function getOsidbApiV1FlawsCvssScoresDestroy200Response() {
  return {
    dt: faker.date.past(),
    env: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}

export function getOsidbApiV1FlawsPackageVersionsList200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?offset=400&limit=100",
    previous: "http://api.example.org/accounts/?offset=200&limit=100",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      package: faker.string.alpha({ length: { min: 0, max: 2048 } }),
      versions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        version: faker.string.alpha({ length: { min: 0, max: 1024 } }),
      })),
      flaw: faker.string.uuid(),
      uuid: faker.string.uuid(),
      embargoed: faker.datatype.boolean(),
      created_dt: faker.date.past(),
      updated_dt: faker.date.past(),
    })),
    dt: faker.date.past(),
    env: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}

export function getOsidbApiV1FlawsPackageVersionsCreate201Response() {
  return {
    package: faker.string.alpha({ length: { min: 0, max: 2048 } }),
    versions: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      version: faker.string.alpha({ length: { min: 0, max: 1024 } }),
    })),
    flaw: faker.string.uuid(),
    uuid: faker.string.uuid(),
    embargoed: faker.datatype.boolean(),
    created_dt: faker.date.past(),
    updated_dt: faker.date.past(),
    dt: faker.date.past(),
    env: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}

export function getOsidbApiV1FlawsPackageVersionsRetrieve200Response() {
  return {
    package: faker.string.alpha({ length: { min: 0, max: 2048 } }),
    versions: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      version: faker.string.alpha({ length: { min: 0, max: 1024 } }),
    })),
    flaw: faker.string.uuid(),
    uuid: faker.string.uuid(),
    embargoed: faker.datatype.boolean(),
    created_dt: faker.date.past(),
    updated_dt: faker.date.past(),
    dt: faker.date.past(),
    env: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}

export function getOsidbApiV1FlawsPackageVersionsUpdate200Response() {
  return {
    package: faker.string.alpha({ length: { min: 0, max: 2048 } }),
    versions: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      version: faker.string.alpha({ length: { min: 0, max: 1024 } }),
    })),
    flaw: faker.string.uuid(),
    uuid: faker.string.uuid(),
    embargoed: faker.datatype.boolean(),
    created_dt: faker.date.past(),
    updated_dt: faker.date.past(),
    dt: faker.date.past(),
    env: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}

export function getOsidbApiV1FlawsPackageVersionsDestroy200Response() {
  return {
    dt: faker.date.past(),
    env: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}

export function getOsidbApiV1FlawsPromoteCreate200Response() {
  return {
    dt: faker.date.past(),
    env: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}

export function getOsidbApiV1FlawsReferencesList200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?offset=400&limit=100",
    previous: "http://api.example.org/accounts/?offset=200&limit=100",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      description: faker.lorem.words(),
      flaw: faker.string.uuid(),
      type: faker.helpers.arrayElement(["ARTICLE", "EXTERNAL", "SOURCE"]),
      url: faker.internet.url(),
      uuid: faker.string.uuid(),
      embargoed: faker.datatype.boolean(),
      alerts: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        uuid: faker.string.uuid(),
        name: faker.person.fullName(),
        description: faker.lorem.words(),
        alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
        resolution_steps: faker.lorem.words(),
        parent_uuid: faker.lorem.words(),
        parent_model: faker.lorem.words(),
      })),
      created_dt: faker.date.past(),
      updated_dt: faker.date.past(),
    })),
    dt: faker.date.past(),
    env: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}

export function getOsidbApiV1FlawsReferencesCreate201Response() {
  return {
    description: faker.lorem.words(),
    flaw: faker.string.uuid(),
    type: faker.helpers.arrayElement(["ARTICLE", "EXTERNAL", "SOURCE"]),
    url: faker.internet.url(),
    uuid: faker.string.uuid(),
    embargoed: faker.datatype.boolean(),
    alerts: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      uuid: faker.string.uuid(),
      name: faker.person.fullName(),
      description: faker.lorem.words(),
      alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
      resolution_steps: faker.lorem.words(),
      parent_uuid: faker.lorem.words(),
      parent_model: faker.lorem.words(),
    })),
    created_dt: faker.date.past(),
    updated_dt: faker.date.past(),
    dt: faker.date.past(),
    env: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}

export function getOsidbApiV1FlawsReferencesRetrieve200Response() {
  return {
    description: faker.lorem.words(),
    flaw: faker.string.uuid(),
    type: faker.helpers.arrayElement(["ARTICLE", "EXTERNAL", "SOURCE"]),
    url: faker.internet.url(),
    uuid: faker.string.uuid(),
    embargoed: faker.datatype.boolean(),
    alerts: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      uuid: faker.string.uuid(),
      name: faker.person.fullName(),
      description: faker.lorem.words(),
      alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
      resolution_steps: faker.lorem.words(),
      parent_uuid: faker.lorem.words(),
      parent_model: faker.lorem.words(),
    })),
    created_dt: faker.date.past(),
    updated_dt: faker.date.past(),
    dt: faker.date.past(),
    env: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}

export function getOsidbApiV1FlawsReferencesUpdate200Response() {
  return {
    description: faker.lorem.words(),
    flaw: faker.string.uuid(),
    type: faker.helpers.arrayElement(["ARTICLE", "EXTERNAL", "SOURCE"]),
    url: faker.internet.url(),
    uuid: faker.string.uuid(),
    embargoed: faker.datatype.boolean(),
    alerts: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      uuid: faker.string.uuid(),
      name: faker.person.fullName(),
      description: faker.lorem.words(),
      alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
      resolution_steps: faker.lorem.words(),
      parent_uuid: faker.lorem.words(),
      parent_model: faker.lorem.words(),
    })),
    created_dt: faker.date.past(),
    updated_dt: faker.date.past(),
    dt: faker.date.past(),
    env: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}

export function getOsidbApiV1FlawsReferencesDestroy200Response() {
  return {
    dt: faker.date.past(),
    env: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}

export function getOsidbApiV1FlawsRejectCreate200Response() {
  return {
    dt: faker.date.past(),
    env: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}

export function getOsidbApiV1FlawsRetrieve200Response() {
  return {
    uuid: faker.string.uuid(),
    cve_id: faker.lorem.words(),
    impact: faker.helpers.arrayElement([
      faker.helpers.arrayElement(["LOW", "MODERATE", "IMPORTANT", "CRITICAL"]),
      faker.helpers.arrayElement([""]),
    ]),
    components: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.string.alpha({ length: { min: 0, max: 100 } })),
    title: faker.lorem.words(),
    trackers: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.words()),
    comment_zero: faker.lorem.words(),
    cve_description: faker.lorem.words(),
    requires_cve_description: faker.helpers.arrayElement([
      faker.helpers.arrayElement(["REQUESTED", "APPROVED", "REJECTED"]),
      faker.helpers.arrayElement([""]),
    ]),
    statement: faker.lorem.words(),
    cwe_id: faker.string.alpha({ length: { min: 0, max: 255 } }),
    unembargo_dt: faker.date.past(),
    source: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        "ADOBE",
        "APPLE",
        "ASF",
        "BIND",
        "BK",
        "BUGTRAQ",
        "BUGZILLA",
        "CERT",
        "CERTIFI",
        "CORELABS",
        "CUSTOMER",
        "CVE",
        "CVEORG",
        "DAILYDAVE",
        "DEBIAN",
        "DISTROS",
        "FEDORA",
        "FETCHMAIL",
        "FREEDESKTOP",
        "FREERADIUS",
        "FRSIRT",
        "FULLDISCLOSURE",
        "GAIM",
        "GENTOO",
        "GENTOOBZ",
        "GIT",
        "GNOME",
        "GNUPG",
        "GOOGLE",
        "HP",
        "HW_VENDOR",
        "IBM",
        "IDEFENSE",
        "INTERNET",
        "ISC",
        "ISEC",
        "IT",
        "JBOSS",
        "JPCERT",
        "KERNELBUGZILLA",
        "KERNELSEC",
        "LKML",
        "LWN",
        "MACROMEDIA",
        "MAGEIA",
        "MAILINGLIST",
        "MILW0RM",
        "MIT",
        "MITRE",
        "MOZILLA",
        "MUTTDEV",
        "NETDEV",
        "NISCC",
        "NVD",
        "OCERT",
        "OPENOFFICE",
        "OPENSSL",
        "OPENSUSE",
        "ORACLE",
        "OSS",
        "OSSSECURITY",
        "OSV",
        "PHP",
        "PIDGIN",
        "POSTGRESQL",
        "PRESS",
        "REAL",
        "REDHAT",
        "RESEARCHER",
        "RT",
        "SAMBA",
        "SECALERT",
        "SECUNIA",
        "SECURITYFOCUS",
        "SKO",
        "SQUID",
        "SQUIRRELMAIL",
        "SUN",
        "SUNSOLVE",
        "SUSE",
        "TWITTER",
        "UBUNTU",
        "UPSTREAM",
        "VENDORSEC",
        "VULNWATCH",
        "WIRESHARK",
        "XCHAT",
        "XEN",
        "XPDF",
      ]),
      faker.helpers.arrayElement([""]),
    ]),
    reported_dt: faker.date.past(),
    mitigation: faker.lorem.words(),
    major_incident_state: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        "REQUESTED",
        "REJECTED",
        "APPROVED",
        "CISA_APPROVED",
        "INVALID",
      ]),
      faker.helpers.arrayElement([""]),
    ]),
    major_incident_start_dt: faker.date.past(),
    nist_cvss_validation: faker.helpers.arrayElement([
      faker.helpers.arrayElement(["REQUESTED", "APPROVED", "REJECTED"]),
      faker.helpers.arrayElement([""]),
    ]),
    affects: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      uuid: faker.string.uuid(),
      flaw: faker.string.uuid(),
      affectedness: faker.helpers.arrayElement([
        faker.helpers.arrayElement(["NEW", "AFFECTED", "NOTAFFECTED"]),
        faker.helpers.arrayElement([""]),
      ]),
      resolution: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          "FIX",
          "DEFER",
          "WONTFIX",
          "OOSS",
          "DELEGATED",
          "WONTREPORT",
        ]),
        faker.helpers.arrayElement([""]),
      ]),
      ps_module: faker.string.alpha({ length: { min: 0, max: 100 } }),
      ps_product: faker.lorem.words(),
      ps_component: faker.string.alpha({ length: { min: 0, max: 255 } }),
      impact: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          "LOW",
          "MODERATE",
          "IMPORTANT",
          "CRITICAL",
        ]),
        faker.helpers.arrayElement([""]),
      ]),
      trackers: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        affects: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.string.uuid()),
        errata: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          et_id: faker.number.int(),
          advisory_name: faker.person.fullName(),
          shipped_dt: faker.date.past(),
          created_dt: faker.date.past(),
          updated_dt: faker.date.past(),
        })),
        external_system_id: faker.lorem.words(),
        meta_attr: {
          bz_id: faker.lorem.words(),
          owner: faker.lorem.words(),
          qe_owner: faker.lorem.words(),
          ps_component: faker.lorem.words(),
          ps_module: faker.lorem.words(),
          ps_update_stream: faker.lorem.words(),
          resolution: faker.lorem.words(),
          status: faker.lorem.words(),
        },
        ps_update_stream: faker.string.alpha({ length: { min: 0, max: 100 } }),
        status: faker.lorem.words(),
        resolution: faker.lorem.words(),
        type: faker.helpers.arrayElement(["JIRA", "BUGZILLA"]),
        uuid: faker.string.uuid(),
        embargoed: faker.datatype.boolean(),
        alerts: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          uuid: faker.string.uuid(),
          name: faker.person.fullName(),
          description: faker.lorem.words(),
          alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
          resolution_steps: faker.lorem.words(),
          parent_uuid: faker.lorem.words(),
          parent_model: faker.lorem.words(),
        })),
        created_dt: faker.date.past(),
        updated_dt: faker.date.past(),
        sync_to_bz: faker.datatype.boolean(),
      })),
      meta_attr: {
        affectedness: faker.lorem.words(),
        component: faker.lorem.words(),
        impact: faker.lorem.words(),
        module_name: faker.person.fullName(),
        module_stream: faker.lorem.words(),
        ps_component: faker.lorem.words(),
        ps_module: faker.lorem.words(),
        ps_product: faker.lorem.words(),
        resolution: faker.lorem.words(),
      },
      delegated_resolution: faker.lorem.words(),
      cvss_scores: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        affect: faker.string.uuid(),
        comment: faker.lorem.words(),
        cvss_version: faker.helpers.arrayElement(["V2", "V3", "V4"]),
        issuer: faker.helpers.arrayElement(["CVEORG", "RH", "NIST", "OSV"]),
        score: faker.number.int(),
        uuid: faker.string.uuid(),
        vector: faker.string.alpha({ length: { min: 0, max: 200 } }),
        embargoed: faker.datatype.boolean(),
        alerts: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          uuid: faker.string.uuid(),
          name: faker.person.fullName(),
          description: faker.lorem.words(),
          alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
          resolution_steps: faker.lorem.words(),
          parent_uuid: faker.lorem.words(),
          parent_model: faker.lorem.words(),
        })),
        created_dt: faker.date.past(),
        updated_dt: faker.date.past(),
      })),
      embargoed: faker.datatype.boolean(),
      alerts: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        uuid: faker.string.uuid(),
        name: faker.person.fullName(),
        description: faker.lorem.words(),
        alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
        resolution_steps: faker.lorem.words(),
        parent_uuid: faker.lorem.words(),
        parent_model: faker.lorem.words(),
      })),
      created_dt: faker.date.past(),
      updated_dt: faker.date.past(),
    })),
    comments: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      uuid: faker.string.uuid(),
      text: faker.lorem.words(),
      external_system_id: faker.string.alpha({ length: { min: 0, max: 100 } }),
      order: faker.number.int({ min: -2147483648, max: 2147483647 }),
      creator: faker.string.alpha({ length: { min: 0, max: 100 } }),
      is_private: faker.datatype.boolean(),
      alerts: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        uuid: faker.string.uuid(),
        name: faker.person.fullName(),
        description: faker.lorem.words(),
        alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
        resolution_steps: faker.lorem.words(),
        parent_uuid: faker.lorem.words(),
        parent_model: faker.lorem.words(),
      })),
      created_dt: faker.date.past(),
      updated_dt: faker.date.past(),
    })),
    meta_attr: {
      acknowledgments: faker.lorem.words(),
      acks_not_needed: faker.lorem.words(),
      affects: faker.lorem.words(),
      alias: faker.lorem.words(),
      bz_datascore: faker.lorem.words(),
      bz_id: faker.lorem.words(),
      checklists: faker.lorem.words(),
      classification: faker.lorem.words(),
      cwe: faker.lorem.words(),
      depends_on: faker.lorem.words(),
      impact: faker.lorem.words(),
      jira_trackers: faker.lorem.words(),
      mitigate: faker.lorem.words(),
      mitigation: faker.lorem.words(),
      public: faker.lorem.words(),
      references: faker.lorem.words(),
      related_cves: faker.lorem.words(),
      reported: faker.lorem.words(),
      source: faker.lorem.words(),
      statement: faker.lorem.words(),
      task_owner: faker.lorem.words(),
    },
    package_versions: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      package: faker.string.alpha({ length: { min: 0, max: 2048 } }),
      versions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        version: faker.string.alpha({ length: { min: 0, max: 1024 } }),
        status: faker.lorem.words(),
      })),
      alerts: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        uuid: faker.string.uuid(),
        name: faker.person.fullName(),
        description: faker.lorem.words(),
        alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
        resolution_steps: faker.lorem.words(),
        parent_uuid: faker.lorem.words(),
        parent_model: faker.lorem.words(),
      })),
    })),
    acknowledgments: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      name: faker.person.fullName(),
      affiliation: faker.string.alpha({ length: { min: 0, max: 255 } }),
      from_upstream: faker.datatype.boolean(),
      flaw: faker.string.uuid(),
      uuid: faker.string.uuid(),
      embargoed: faker.datatype.boolean(),
      alerts: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        uuid: faker.string.uuid(),
        name: faker.person.fullName(),
        description: faker.lorem.words(),
        alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
        resolution_steps: faker.lorem.words(),
        parent_uuid: faker.lorem.words(),
        parent_model: faker.lorem.words(),
      })),
      created_dt: faker.date.past(),
      updated_dt: faker.date.past(),
    })),
    references: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      description: faker.lorem.words(),
      flaw: faker.string.uuid(),
      type: faker.helpers.arrayElement(["ARTICLE", "EXTERNAL", "SOURCE"]),
      url: faker.internet.url(),
      uuid: faker.string.uuid(),
      embargoed: faker.datatype.boolean(),
      alerts: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        uuid: faker.string.uuid(),
        name: faker.person.fullName(),
        description: faker.lorem.words(),
        alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
        resolution_steps: faker.lorem.words(),
        parent_uuid: faker.lorem.words(),
        parent_model: faker.lorem.words(),
      })),
      created_dt: faker.date.past(),
      updated_dt: faker.date.past(),
    })),
    cvss_scores: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      flaw: faker.string.uuid(),
      comment: faker.lorem.words(),
      cvss_version: faker.helpers.arrayElement(["V2", "V3", "V4"]),
      issuer: faker.helpers.arrayElement(["CVEORG", "RH", "NIST", "OSV"]),
      score: faker.number.int(),
      uuid: faker.string.uuid(),
      vector: faker.string.alpha({ length: { min: 0, max: 200 } }),
      embargoed: faker.datatype.boolean(),
      alerts: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        uuid: faker.string.uuid(),
        name: faker.person.fullName(),
        description: faker.lorem.words(),
        alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
        resolution_steps: faker.lorem.words(),
        parent_uuid: faker.lorem.words(),
        parent_model: faker.lorem.words(),
      })),
      created_dt: faker.date.past(),
      updated_dt: faker.date.past(),
    })),
    embargoed: faker.datatype.boolean(),
    created_dt: faker.date.past(),
    updated_dt: faker.date.past(),
    classification: {
      workflow: faker.lorem.words(),
      state: faker.helpers.arrayElement([
        "",
        "NEW",
        "TRIAGE",
        "PRE_SECONDARY_ASSESSMENT",
        "SECONDARY_ASSESSMENT",
        "DONE",
        "REJECTED",
      ]),
    },
    group_key: faker.string.alpha({ length: { min: 0, max: 60 } }),
    owner: faker.string.alpha({ length: { min: 0, max: 60 } }),
    task_key: faker.string.alpha({ length: { min: 0, max: 60 } }),
    team_id: faker.string.alpha({ length: { min: 0, max: 8 } }),
    alerts: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      uuid: faker.string.uuid(),
      name: faker.person.fullName(),
      description: faker.lorem.words(),
      alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
      resolution_steps: faker.lorem.words(),
      parent_uuid: faker.lorem.words(),
      parent_model: faker.lorem.words(),
    })),
    dt: faker.date.past(),
    env: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}

export function getOsidbApiV1FlawsUpdate200Response() {
  return {
    uuid: faker.string.uuid(),
    cve_id: faker.lorem.words(),
    impact: faker.helpers.arrayElement([
      faker.helpers.arrayElement(["LOW", "MODERATE", "IMPORTANT", "CRITICAL"]),
      faker.helpers.arrayElement([""]),
    ]),
    components: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.string.alpha({ length: { min: 0, max: 100 } })),
    title: faker.lorem.words(),
    trackers: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.words()),
    comment_zero: faker.lorem.words(),
    cve_description: faker.lorem.words(),
    requires_cve_description: faker.helpers.arrayElement([
      faker.helpers.arrayElement(["REQUESTED", "APPROVED", "REJECTED"]),
      faker.helpers.arrayElement([""]),
    ]),
    statement: faker.lorem.words(),
    cwe_id: faker.string.alpha({ length: { min: 0, max: 255 } }),
    unembargo_dt: faker.date.past(),
    source: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        "ADOBE",
        "APPLE",
        "ASF",
        "BIND",
        "BK",
        "BUGTRAQ",
        "BUGZILLA",
        "CERT",
        "CERTIFI",
        "CORELABS",
        "CUSTOMER",
        "CVE",
        "CVEORG",
        "DAILYDAVE",
        "DEBIAN",
        "DISTROS",
        "FEDORA",
        "FETCHMAIL",
        "FREEDESKTOP",
        "FREERADIUS",
        "FRSIRT",
        "FULLDISCLOSURE",
        "GAIM",
        "GENTOO",
        "GENTOOBZ",
        "GIT",
        "GNOME",
        "GNUPG",
        "GOOGLE",
        "HP",
        "HW_VENDOR",
        "IBM",
        "IDEFENSE",
        "INTERNET",
        "ISC",
        "ISEC",
        "IT",
        "JBOSS",
        "JPCERT",
        "KERNELBUGZILLA",
        "KERNELSEC",
        "LKML",
        "LWN",
        "MACROMEDIA",
        "MAGEIA",
        "MAILINGLIST",
        "MILW0RM",
        "MIT",
        "MITRE",
        "MOZILLA",
        "MUTTDEV",
        "NETDEV",
        "NISCC",
        "NVD",
        "OCERT",
        "OPENOFFICE",
        "OPENSSL",
        "OPENSUSE",
        "ORACLE",
        "OSS",
        "OSSSECURITY",
        "OSV",
        "PHP",
        "PIDGIN",
        "POSTGRESQL",
        "PRESS",
        "REAL",
        "REDHAT",
        "RESEARCHER",
        "RT",
        "SAMBA",
        "SECALERT",
        "SECUNIA",
        "SECURITYFOCUS",
        "SKO",
        "SQUID",
        "SQUIRRELMAIL",
        "SUN",
        "SUNSOLVE",
        "SUSE",
        "TWITTER",
        "UBUNTU",
        "UPSTREAM",
        "VENDORSEC",
        "VULNWATCH",
        "WIRESHARK",
        "XCHAT",
        "XEN",
        "XPDF",
      ]),
      faker.helpers.arrayElement([""]),
    ]),
    reported_dt: faker.date.past(),
    mitigation: faker.lorem.words(),
    major_incident_state: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        "REQUESTED",
        "REJECTED",
        "APPROVED",
        "CISA_APPROVED",
        "INVALID",
      ]),
      faker.helpers.arrayElement([""]),
    ]),
    major_incident_start_dt: faker.date.past(),
    nist_cvss_validation: faker.helpers.arrayElement([
      faker.helpers.arrayElement(["REQUESTED", "APPROVED", "REJECTED"]),
      faker.helpers.arrayElement([""]),
    ]),
    affects: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      uuid: faker.string.uuid(),
      flaw: faker.string.uuid(),
      affectedness: faker.helpers.arrayElement([
        faker.helpers.arrayElement(["NEW", "AFFECTED", "NOTAFFECTED"]),
        faker.helpers.arrayElement([""]),
      ]),
      resolution: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          "FIX",
          "DEFER",
          "WONTFIX",
          "OOSS",
          "DELEGATED",
          "WONTREPORT",
        ]),
        faker.helpers.arrayElement([""]),
      ]),
      ps_module: faker.string.alpha({ length: { min: 0, max: 100 } }),
      ps_product: faker.lorem.words(),
      ps_component: faker.string.alpha({ length: { min: 0, max: 255 } }),
      impact: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          "LOW",
          "MODERATE",
          "IMPORTANT",
          "CRITICAL",
        ]),
        faker.helpers.arrayElement([""]),
      ]),
      trackers: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        affects: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.string.uuid()),
        errata: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          et_id: faker.number.int(),
          advisory_name: faker.person.fullName(),
          shipped_dt: faker.date.past(),
          created_dt: faker.date.past(),
          updated_dt: faker.date.past(),
        })),
        external_system_id: faker.lorem.words(),
        meta_attr: {
          bz_id: faker.lorem.words(),
          owner: faker.lorem.words(),
          qe_owner: faker.lorem.words(),
          ps_component: faker.lorem.words(),
          ps_module: faker.lorem.words(),
          ps_update_stream: faker.lorem.words(),
          resolution: faker.lorem.words(),
          status: faker.lorem.words(),
        },
        ps_update_stream: faker.string.alpha({ length: { min: 0, max: 100 } }),
        status: faker.lorem.words(),
        resolution: faker.lorem.words(),
        type: faker.helpers.arrayElement(["JIRA", "BUGZILLA"]),
        uuid: faker.string.uuid(),
        embargoed: faker.datatype.boolean(),
        alerts: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          uuid: faker.string.uuid(),
          name: faker.person.fullName(),
          description: faker.lorem.words(),
          alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
          resolution_steps: faker.lorem.words(),
          parent_uuid: faker.lorem.words(),
          parent_model: faker.lorem.words(),
        })),
        created_dt: faker.date.past(),
        updated_dt: faker.date.past(),
        sync_to_bz: faker.datatype.boolean(),
      })),
      meta_attr: {
        affectedness: faker.lorem.words(),
        component: faker.lorem.words(),
        impact: faker.lorem.words(),
        module_name: faker.person.fullName(),
        module_stream: faker.lorem.words(),
        ps_component: faker.lorem.words(),
        ps_module: faker.lorem.words(),
        ps_product: faker.lorem.words(),
        resolution: faker.lorem.words(),
      },
      delegated_resolution: faker.lorem.words(),
      cvss_scores: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        affect: faker.string.uuid(),
        comment: faker.lorem.words(),
        cvss_version: faker.helpers.arrayElement(["V2", "V3", "V4"]),
        issuer: faker.helpers.arrayElement(["CVEORG", "RH", "NIST", "OSV"]),
        score: faker.number.int(),
        uuid: faker.string.uuid(),
        vector: faker.string.alpha({ length: { min: 0, max: 200 } }),
        embargoed: faker.datatype.boolean(),
        alerts: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          uuid: faker.string.uuid(),
          name: faker.person.fullName(),
          description: faker.lorem.words(),
          alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
          resolution_steps: faker.lorem.words(),
          parent_uuid: faker.lorem.words(),
          parent_model: faker.lorem.words(),
        })),
        created_dt: faker.date.past(),
        updated_dt: faker.date.past(),
      })),
      embargoed: faker.datatype.boolean(),
      alerts: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        uuid: faker.string.uuid(),
        name: faker.person.fullName(),
        description: faker.lorem.words(),
        alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
        resolution_steps: faker.lorem.words(),
        parent_uuid: faker.lorem.words(),
        parent_model: faker.lorem.words(),
      })),
      created_dt: faker.date.past(),
      updated_dt: faker.date.past(),
    })),
    comments: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      uuid: faker.string.uuid(),
      text: faker.lorem.words(),
      external_system_id: faker.string.alpha({ length: { min: 0, max: 100 } }),
      order: faker.number.int({ min: -2147483648, max: 2147483647 }),
      creator: faker.string.alpha({ length: { min: 0, max: 100 } }),
      is_private: faker.datatype.boolean(),
      alerts: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        uuid: faker.string.uuid(),
        name: faker.person.fullName(),
        description: faker.lorem.words(),
        alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
        resolution_steps: faker.lorem.words(),
        parent_uuid: faker.lorem.words(),
        parent_model: faker.lorem.words(),
      })),
      created_dt: faker.date.past(),
      updated_dt: faker.date.past(),
    })),
    meta_attr: {
      acknowledgments: faker.lorem.words(),
      acks_not_needed: faker.lorem.words(),
      affects: faker.lorem.words(),
      alias: faker.lorem.words(),
      bz_datascore: faker.lorem.words(),
      bz_id: faker.lorem.words(),
      checklists: faker.lorem.words(),
      classification: faker.lorem.words(),
      cwe: faker.lorem.words(),
      depends_on: faker.lorem.words(),
      impact: faker.lorem.words(),
      jira_trackers: faker.lorem.words(),
      mitigate: faker.lorem.words(),
      mitigation: faker.lorem.words(),
      public: faker.lorem.words(),
      references: faker.lorem.words(),
      related_cves: faker.lorem.words(),
      reported: faker.lorem.words(),
      source: faker.lorem.words(),
      statement: faker.lorem.words(),
      task_owner: faker.lorem.words(),
    },
    package_versions: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      package: faker.string.alpha({ length: { min: 0, max: 2048 } }),
      versions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        version: faker.string.alpha({ length: { min: 0, max: 1024 } }),
        status: faker.lorem.words(),
      })),
      alerts: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        uuid: faker.string.uuid(),
        name: faker.person.fullName(),
        description: faker.lorem.words(),
        alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
        resolution_steps: faker.lorem.words(),
        parent_uuid: faker.lorem.words(),
        parent_model: faker.lorem.words(),
      })),
    })),
    acknowledgments: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      name: faker.person.fullName(),
      affiliation: faker.string.alpha({ length: { min: 0, max: 255 } }),
      from_upstream: faker.datatype.boolean(),
      flaw: faker.string.uuid(),
      uuid: faker.string.uuid(),
      embargoed: faker.datatype.boolean(),
      alerts: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        uuid: faker.string.uuid(),
        name: faker.person.fullName(),
        description: faker.lorem.words(),
        alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
        resolution_steps: faker.lorem.words(),
        parent_uuid: faker.lorem.words(),
        parent_model: faker.lorem.words(),
      })),
      created_dt: faker.date.past(),
      updated_dt: faker.date.past(),
    })),
    references: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      description: faker.lorem.words(),
      flaw: faker.string.uuid(),
      type: faker.helpers.arrayElement(["ARTICLE", "EXTERNAL", "SOURCE"]),
      url: faker.internet.url(),
      uuid: faker.string.uuid(),
      embargoed: faker.datatype.boolean(),
      alerts: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        uuid: faker.string.uuid(),
        name: faker.person.fullName(),
        description: faker.lorem.words(),
        alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
        resolution_steps: faker.lorem.words(),
        parent_uuid: faker.lorem.words(),
        parent_model: faker.lorem.words(),
      })),
      created_dt: faker.date.past(),
      updated_dt: faker.date.past(),
    })),
    cvss_scores: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      flaw: faker.string.uuid(),
      comment: faker.lorem.words(),
      cvss_version: faker.helpers.arrayElement(["V2", "V3", "V4"]),
      issuer: faker.helpers.arrayElement(["CVEORG", "RH", "NIST", "OSV"]),
      score: faker.number.int(),
      uuid: faker.string.uuid(),
      vector: faker.string.alpha({ length: { min: 0, max: 200 } }),
      embargoed: faker.datatype.boolean(),
      alerts: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        uuid: faker.string.uuid(),
        name: faker.person.fullName(),
        description: faker.lorem.words(),
        alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
        resolution_steps: faker.lorem.words(),
        parent_uuid: faker.lorem.words(),
        parent_model: faker.lorem.words(),
      })),
      created_dt: faker.date.past(),
      updated_dt: faker.date.past(),
    })),
    embargoed: faker.datatype.boolean(),
    created_dt: faker.date.past(),
    updated_dt: faker.date.past(),
    classification: {
      workflow: faker.lorem.words(),
      state: faker.helpers.arrayElement([
        "",
        "NEW",
        "TRIAGE",
        "PRE_SECONDARY_ASSESSMENT",
        "SECONDARY_ASSESSMENT",
        "DONE",
        "REJECTED",
      ]),
    },
    group_key: faker.string.alpha({ length: { min: 0, max: 60 } }),
    owner: faker.string.alpha({ length: { min: 0, max: 60 } }),
    task_key: faker.string.alpha({ length: { min: 0, max: 60 } }),
    team_id: faker.string.alpha({ length: { min: 0, max: 8 } }),
    alerts: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      uuid: faker.string.uuid(),
      name: faker.person.fullName(),
      description: faker.lorem.words(),
      alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
      resolution_steps: faker.lorem.words(),
      parent_uuid: faker.lorem.words(),
      parent_model: faker.lorem.words(),
    })),
    dt: faker.date.past(),
    env: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}

export function getOsidbApiV1TrackersList200Response() {
  return {
    count: 123,
    next: "http://api.example.org/accounts/?offset=400&limit=100",
    previous: "http://api.example.org/accounts/?offset=200&limit=100",
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      affects: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.string.uuid()),
      errata: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        et_id: faker.number.int(),
        advisory_name: faker.person.fullName(),
        shipped_dt: faker.date.past(),
        created_dt: faker.date.past(),
        updated_dt: faker.date.past(),
      })),
      external_system_id: faker.lorem.words(),
      meta_attr: {
        bz_id: faker.lorem.words(),
        owner: faker.lorem.words(),
        qe_owner: faker.lorem.words(),
        ps_component: faker.lorem.words(),
        ps_module: faker.lorem.words(),
        ps_update_stream: faker.lorem.words(),
        resolution: faker.lorem.words(),
        status: faker.lorem.words(),
      },
      ps_update_stream: faker.string.alpha({ length: { min: 0, max: 100 } }),
      status: faker.lorem.words(),
      resolution: faker.lorem.words(),
      type: faker.helpers.arrayElement(["JIRA", "BUGZILLA"]),
      uuid: faker.string.uuid(),
      embargoed: faker.datatype.boolean(),
      alerts: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        uuid: faker.string.uuid(),
        name: faker.person.fullName(),
        description: faker.lorem.words(),
        alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
        resolution_steps: faker.lorem.words(),
        parent_uuid: faker.lorem.words(),
        parent_model: faker.lorem.words(),
      })),
      created_dt: faker.date.past(),
      updated_dt: faker.date.past(),
      sync_to_bz: faker.datatype.boolean(),
    })),
    dt: faker.date.past(),
    env: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}

export function getOsidbApiV1TrackersCreate201Response() {
  return {
    affects: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.string.uuid()),
    errata: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      et_id: faker.number.int(),
      advisory_name: faker.person.fullName(),
      shipped_dt: faker.date.past(),
      created_dt: faker.date.past(),
      updated_dt: faker.date.past(),
    })),
    meta_attr: {
      bz_id: faker.lorem.words(),
      owner: faker.lorem.words(),
      qe_owner: faker.lorem.words(),
      ps_component: faker.lorem.words(),
      ps_module: faker.lorem.words(),
      ps_update_stream: faker.lorem.words(),
      resolution: faker.lorem.words(),
      status: faker.lorem.words(),
    },
    ps_update_stream: faker.string.alpha({ length: { min: 0, max: 100 } }),
    status: faker.lorem.words(),
    resolution: faker.lorem.words(),
    type: faker.helpers.arrayElement(["JIRA", "BUGZILLA"]),
    uuid: faker.string.uuid(),
    embargoed: faker.datatype.boolean(),
    alerts: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      uuid: faker.string.uuid(),
      name: faker.person.fullName(),
      description: faker.lorem.words(),
      alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
      resolution_steps: faker.lorem.words(),
      parent_uuid: faker.lorem.words(),
      parent_model: faker.lorem.words(),
    })),
    created_dt: faker.date.past(),
    updated_dt: faker.date.past(),
    sync_to_bz: faker.datatype.boolean(),
    dt: faker.date.past(),
    env: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}

export function getOsidbApiV1TrackersRetrieve200Response() {
  return {
    affects: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.string.uuid()),
    errata: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      et_id: faker.number.int(),
      advisory_name: faker.person.fullName(),
      shipped_dt: faker.date.past(),
      created_dt: faker.date.past(),
      updated_dt: faker.date.past(),
    })),
    external_system_id: faker.lorem.words(),
    meta_attr: {
      bz_id: faker.lorem.words(),
      owner: faker.lorem.words(),
      qe_owner: faker.lorem.words(),
      ps_component: faker.lorem.words(),
      ps_module: faker.lorem.words(),
      ps_update_stream: faker.lorem.words(),
      resolution: faker.lorem.words(),
      status: faker.lorem.words(),
    },
    ps_update_stream: faker.string.alpha({ length: { min: 0, max: 100 } }),
    status: faker.lorem.words(),
    resolution: faker.lorem.words(),
    type: faker.helpers.arrayElement(["JIRA", "BUGZILLA"]),
    uuid: faker.string.uuid(),
    embargoed: faker.datatype.boolean(),
    alerts: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      uuid: faker.string.uuid(),
      name: faker.person.fullName(),
      description: faker.lorem.words(),
      alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
      resolution_steps: faker.lorem.words(),
      parent_uuid: faker.lorem.words(),
      parent_model: faker.lorem.words(),
    })),
    created_dt: faker.date.past(),
    updated_dt: faker.date.past(),
    sync_to_bz: faker.datatype.boolean(),
    dt: faker.date.past(),
    env: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}

export function getOsidbApiV1TrackersUpdate200Response() {
  return {
    affects: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.string.uuid()),
    errata: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      et_id: faker.number.int(),
      advisory_name: faker.person.fullName(),
      shipped_dt: faker.date.past(),
      created_dt: faker.date.past(),
      updated_dt: faker.date.past(),
    })),
    external_system_id: faker.lorem.words(),
    meta_attr: {
      bz_id: faker.lorem.words(),
      owner: faker.lorem.words(),
      qe_owner: faker.lorem.words(),
      ps_component: faker.lorem.words(),
      ps_module: faker.lorem.words(),
      ps_update_stream: faker.lorem.words(),
      resolution: faker.lorem.words(),
      status: faker.lorem.words(),
    },
    ps_update_stream: faker.string.alpha({ length: { min: 0, max: 100 } }),
    status: faker.lorem.words(),
    resolution: faker.lorem.words(),
    type: faker.helpers.arrayElement(["JIRA", "BUGZILLA"]),
    uuid: faker.string.uuid(),
    embargoed: faker.datatype.boolean(),
    alerts: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      uuid: faker.string.uuid(),
      name: faker.person.fullName(),
      description: faker.lorem.words(),
      alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
      resolution_steps: faker.lorem.words(),
      parent_uuid: faker.lorem.words(),
      parent_model: faker.lorem.words(),
    })),
    created_dt: faker.date.past(),
    updated_dt: faker.date.past(),
    sync_to_bz: faker.datatype.boolean(),
    dt: faker.date.past(),
    env: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}

export function getTrackersApiV1FileCreate200Response() {
  return {
    modules_components: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      ps_module: faker.lorem.words(),
      ps_component: faker.lorem.words(),
      streams: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        ps_update_stream: faker.lorem.words(),
        selected: faker.datatype.boolean(),
        acked: faker.datatype.boolean(),
        eus: faker.datatype.boolean(),
        aus: faker.datatype.boolean(),
      })),
      selected: faker.datatype.boolean(),
      affect: {
        uuid: faker.string.uuid(),
        flaw: faker.string.uuid(),
        affectedness: faker.helpers.arrayElement([
          faker.helpers.arrayElement(["NEW", "AFFECTED", "NOTAFFECTED"]),
          faker.helpers.arrayElement([""]),
        ]),
        resolution: faker.helpers.arrayElement([
          faker.helpers.arrayElement([
            "FIX",
            "DEFER",
            "WONTFIX",
            "OOSS",
            "DELEGATED",
            "WONTREPORT",
          ]),
          faker.helpers.arrayElement([""]),
        ]),
        ps_module: faker.string.alpha({ length: { min: 0, max: 100 } }),
        ps_product: faker.lorem.words(),
        ps_component: faker.string.alpha({ length: { min: 0, max: 255 } }),
        impact: faker.helpers.arrayElement([
          faker.helpers.arrayElement([
            "LOW",
            "MODERATE",
            "IMPORTANT",
            "CRITICAL",
          ]),
          faker.helpers.arrayElement([""]),
        ]),
        trackers: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          affects: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => faker.string.uuid()),
          errata: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            et_id: faker.number.int(),
            advisory_name: faker.person.fullName(),
            shipped_dt: faker.date.past(),
            created_dt: faker.date.past(),
            updated_dt: faker.date.past(),
          })),
          external_system_id: faker.lorem.words(),
          meta_attr: {
            bz_id: faker.lorem.words(),
            owner: faker.lorem.words(),
            qe_owner: faker.lorem.words(),
            ps_component: faker.lorem.words(),
            ps_module: faker.lorem.words(),
            ps_update_stream: faker.lorem.words(),
            resolution: faker.lorem.words(),
            status: faker.lorem.words(),
          },
          ps_update_stream: faker.string.alpha({
            length: { min: 0, max: 100 },
          }),
          status: faker.lorem.words(),
          resolution: faker.lorem.words(),
          type: faker.helpers.arrayElement(["JIRA", "BUGZILLA"]),
          uuid: faker.string.uuid(),
          embargoed: faker.datatype.boolean(),
          alerts: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            uuid: faker.string.uuid(),
            name: faker.person.fullName(),
            description: faker.lorem.words(),
            alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
            resolution_steps: faker.lorem.words(),
            parent_uuid: faker.lorem.words(),
            parent_model: faker.lorem.words(),
          })),
          created_dt: faker.date.past(),
          updated_dt: faker.date.past(),
          sync_to_bz: faker.datatype.boolean(),
        })),
        meta_attr: {
          affectedness: faker.lorem.words(),
          component: faker.lorem.words(),
          impact: faker.lorem.words(),
          module_name: faker.person.fullName(),
          module_stream: faker.lorem.words(),
          ps_component: faker.lorem.words(),
          ps_module: faker.lorem.words(),
          ps_product: faker.lorem.words(),
          resolution: faker.lorem.words(),
        },
        delegated_resolution: faker.lorem.words(),
        cvss_scores: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          affect: faker.string.uuid(),
          comment: faker.lorem.words(),
          cvss_version: faker.helpers.arrayElement(["V2", "V3", "V4"]),
          issuer: faker.helpers.arrayElement(["CVEORG", "RH", "NIST", "OSV"]),
          score: faker.number.int(),
          uuid: faker.string.uuid(),
          vector: faker.string.alpha({ length: { min: 0, max: 200 } }),
          embargoed: faker.datatype.boolean(),
          alerts: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            uuid: faker.string.uuid(),
            name: faker.person.fullName(),
            description: faker.lorem.words(),
            alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
            resolution_steps: faker.lorem.words(),
            parent_uuid: faker.lorem.words(),
            parent_model: faker.lorem.words(),
          })),
          created_dt: faker.date.past(),
          updated_dt: faker.date.past(),
        })),
        embargoed: faker.datatype.boolean(),
        alerts: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          uuid: faker.string.uuid(),
          name: faker.person.fullName(),
          description: faker.lorem.words(),
          alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
          resolution_steps: faker.lorem.words(),
          parent_uuid: faker.lorem.words(),
          parent_model: faker.lorem.words(),
        })),
        created_dt: faker.date.past(),
        updated_dt: faker.date.past(),
      },
    })),
    not_applicable: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      uuid: faker.string.uuid(),
      flaw: faker.string.uuid(),
      affectedness: faker.helpers.arrayElement([
        faker.helpers.arrayElement(["NEW", "AFFECTED", "NOTAFFECTED"]),
        faker.helpers.arrayElement([""]),
      ]),
      resolution: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          "FIX",
          "DEFER",
          "WONTFIX",
          "OOSS",
          "DELEGATED",
          "WONTREPORT",
        ]),
        faker.helpers.arrayElement([""]),
      ]),
      ps_module: faker.string.alpha({ length: { min: 0, max: 100 } }),
      ps_product: faker.lorem.words(),
      ps_component: faker.string.alpha({ length: { min: 0, max: 255 } }),
      impact: faker.helpers.arrayElement([
        faker.helpers.arrayElement([
          "LOW",
          "MODERATE",
          "IMPORTANT",
          "CRITICAL",
        ]),
        faker.helpers.arrayElement([""]),
      ]),
      trackers: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        affects: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.string.uuid()),
        errata: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          et_id: faker.number.int(),
          advisory_name: faker.person.fullName(),
          shipped_dt: faker.date.past(),
          created_dt: faker.date.past(),
          updated_dt: faker.date.past(),
        })),
        external_system_id: faker.lorem.words(),
        meta_attr: {
          bz_id: faker.lorem.words(),
          owner: faker.lorem.words(),
          qe_owner: faker.lorem.words(),
          ps_component: faker.lorem.words(),
          ps_module: faker.lorem.words(),
          ps_update_stream: faker.lorem.words(),
          resolution: faker.lorem.words(),
          status: faker.lorem.words(),
        },
        ps_update_stream: faker.string.alpha({ length: { min: 0, max: 100 } }),
        status: faker.lorem.words(),
        resolution: faker.lorem.words(),
        type: faker.helpers.arrayElement(["JIRA", "BUGZILLA"]),
        uuid: faker.string.uuid(),
        embargoed: faker.datatype.boolean(),
        alerts: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          uuid: faker.string.uuid(),
          name: faker.person.fullName(),
          description: faker.lorem.words(),
          alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
          resolution_steps: faker.lorem.words(),
          parent_uuid: faker.lorem.words(),
          parent_model: faker.lorem.words(),
        })),
        created_dt: faker.date.past(),
        updated_dt: faker.date.past(),
        sync_to_bz: faker.datatype.boolean(),
      })),
      meta_attr: {
        affectedness: faker.lorem.words(),
        component: faker.lorem.words(),
        impact: faker.lorem.words(),
        module_name: faker.person.fullName(),
        module_stream: faker.lorem.words(),
        ps_component: faker.lorem.words(),
        ps_module: faker.lorem.words(),
        ps_product: faker.lorem.words(),
        resolution: faker.lorem.words(),
      },
      delegated_resolution: faker.lorem.words(),
      cvss_scores: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        affect: faker.string.uuid(),
        comment: faker.lorem.words(),
        cvss_version: faker.helpers.arrayElement(["V2", "V3", "V4"]),
        issuer: faker.helpers.arrayElement(["CVEORG", "RH", "NIST", "OSV"]),
        score: faker.number.int(),
        uuid: faker.string.uuid(),
        vector: faker.string.alpha({ length: { min: 0, max: 200 } }),
        embargoed: faker.datatype.boolean(),
        alerts: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          uuid: faker.string.uuid(),
          name: faker.person.fullName(),
          description: faker.lorem.words(),
          alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
          resolution_steps: faker.lorem.words(),
          parent_uuid: faker.lorem.words(),
          parent_model: faker.lorem.words(),
        })),
        created_dt: faker.date.past(),
        updated_dt: faker.date.past(),
      })),
      embargoed: faker.datatype.boolean(),
      alerts: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        uuid: faker.string.uuid(),
        name: faker.person.fullName(),
        description: faker.lorem.words(),
        alert_type: faker.helpers.arrayElement(["WARNING", "ERROR"]),
        resolution_steps: faker.lorem.words(),
        parent_uuid: faker.lorem.words(),
        parent_model: faker.lorem.words(),
      })),
      created_dt: faker.date.past(),
      updated_dt: faker.date.past(),
    })),
    dt: faker.date.past(),
    env: faker.lorem.words(),
    revision: faker.lorem.words(),
    version: faker.lorem.words(),
  };
}
